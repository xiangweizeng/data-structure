# 2. 栈和队列

## 2.1 栈

### 2.1.1 栈的基本概念

#### 栈的定义

* 栈是只允许在一端进行插入或删除操作的线性表。后进先出 LIFO
* 栈顶（Top）：线性表允许进行插入删除的那一端。
* 栈底（Bottom）：固定的，不允许进行插入和删除的另一端
* 空栈：不包含任何元素的空表

#### 栈的基本操作

```c
InitStack(&S):初始化一个空栈S
StackEmpty(S):判断一个栈是否为空，若栈S为空则返回true，否则返回false
Push(&S,x):进栈，若栈S未满，则将x加入使之成为新栈顶
Pop(&S,&x):出栈，若栈S非空，则弹出栈顶元素，并用x返回
GetTop(S,&x):读取栈顶元素，若栈S非空，则用x返回栈顶元素
DestroyStack(&S):销毁栈，并释放栈S占用的存储空间
```

### 2.1.2 栈的顺序存储结构

#### 顺序栈的实现

利用一组地址连续的存储单元存放自栈底到栈顶的数据元素，并附设一个指针`top`指示当前栈顶元素的位置

```c
#define MaxSize 50            //定义栈中元素最大个数
typedef struct{
    Elemtype data[MaxSize];    //存放栈中元素
    int top;//栈顶指针
}
```

* 栈顶指针：`S.top`，初始时设置`S.top=-1`；栈顶元素：`S.data[S.top]`
* 进栈操作：栈不满时，栈顶指针先加 1，再送值到栈顶元素
* 出栈操作：栈非空时，先取栈顶元素值，再将栈顶指针减 1
* 栈空条件：`S.top==-1`；栈满条件：`S.top==MaxSize-1`；栈长：`S.top+1`

#### 共享栈

利用栈底位置相对不变的特性，可让两个顺序栈共享一个一维数组空间，将两个栈的栈底分别设置在共享空间的两端，两个栈顶共享空间的中间延伸。

* 两个栈的栈顶指针都指向栈顶元素

* `top0=-1`时 0 号栈为空，`top1=MaxSize`时`1`号栈为空

* `top1-top0==1`为栈满

* 当`0`号栈进栈时`top0`先加 1 再赋值，`1`号栈进栈时`top1`先减 1 再赋值；出栈是刚好相反

### 2.1.3 栈的链式存储结构

采用链式存储的栈称为**链栈**，链栈的优点是便于多个栈共享存储空间和提高其效率，且不存在栈满上溢的情况。这里规定链栈没有头结点，`Lhead`指向栈顶元素

```c
typedef struct Linknode{
    ElemType data;//数据域
    struct Linknode *next;//指针域
} *LiStack;//栈类型定义
```

## 2.2 队列

### 2.2.1 队列的基本概念

#### 队列的定义

* 队列简称队，也是一种操作受限的线性表，只允许在表的一端进行插入，而在表的另一端进行删除。
* 向队列中插入元素称为**入队**或**进队**
* 删除元素称为**出队**或**离队**
* 操作的特性是先进先出

#### 队列常见的基本操作

```c
InitQueue(&Q):初始化队列，构造一个空队列Q
QueueEmpty(Q):判队列空
EnQueue(&Q,x):入队，若队列Q非满，将x加入，使之成为新的队尾
DeQueue(&Q,&x):出队，若队列Q非空，删除队头元素，并用x返回
GetHead(Q,&x):读队头元素，若队列Q非空，则将队头元素赋值给x
```

### 2.2.2 队列的顺序存储结构

#### 队列的顺序存储

队列的顺序实现是指分配一块连续的存储单元存放队列中的元素，并附设两个指针：队头指针`front`指向队头元素，队尾指针`rear`指向队尾元素的下一个位置

```c
#define MaxSize 50//定义队列中元素的最大个数
typedef struct{
    ElemType data[MaxSize];//存放队列元素
    int front,rear;//队头指针和队尾指针
} SqQueue;
```

* 初始状态：`Q.front==Q.rear==0`
* 进队操作：队不满时，先送值到队尾元素，再将队尾指针加 1
* 出队操作：队不空时，先取队头元素值，再将队头指针加 1

#### 循环队列

将顺序队列臆造为一个环状的空间，即把存储队列元素的表从逻辑上视为一个环，称为循环队列。当队首指针`Q.front=MaxSize-1`后，再前进一个位置就自动到 0，这可以利用除法取余运算`%`来实现

* 初始状态：`Q.front=Q.rear=0`
* 队首指针进 1：`Q.front=(Q.front+1)%MaxSize`
* 队尾指针进 1：`Q.rear=(Q.rear+1)%MaxSize`
* 队列长度：`(Q.rear+MaxSize-Q.front)%MaxSize`
* 出队入队时：指针都按顺时针方向进 1

**判断循环队列队空或队满的三种方式**

1. 牺牲一个单元来区分队空和队满，入队时少用一个队列单元，约定以 “队头指针在队尾指针的下一位置作为队满的标志”
   
   * 队满条件：`(Q.rear+1)%MaxSize==Q.front`
   * 队空条件：`Q.front=Q.rear`
   * 队列中元素的个数：`(Q.rear-Q.front+MaxSize)%MaxSize`

2. 类型中增设表示元素个数的数据成员。
   
   * 队空条件：`Q.size==0`
   * 队满条件：`Q.size==MaxSize`

3. 类型中增设`tag`数据成员，以区分是队满还是队空。
   
   * `tag=0`时，若因删除导致`Q.front==Q.rear`, 则为队空
   
   * `tag=1`时，若因插入导致`Q.front==Q.rear`, 则为队满

### 2.2.3 队列的链式存储结构

#### 队列的链式存储

队列的链式表示称为链队列，它实际是一个同时带有队头指针和队尾指针的单链表。头指针指向队头结点，尾指针指向队尾结点。

```c
typedef struct{//链式队列结点
    ElemType data;
    struct LinkNdoe *next;
}LinkNode;
typedef struct{//链式队列
    LinkNode *front,*rear;//队列的队头和队尾指针
}LinkQueue;
```

通常将链式队列设计成一个带头结点对的单链表，这样插入和删除就统一了

### 2.2.4 双端队列

双端队列是指允许两端都可进行入队和出队操作的队列，其元素的逻辑结构仍是线性结构。将队列的两端分别称为前端和后端。

* 输出受限的双端队列：允许在一端进行插入和删除，另一端只允许插入的双端队列
* 输入受限的双端队列：允许在一端进行插入和删除，另一端只允许删除的双端队列

## 2.3 栈和队列的应用

#### 栈在括号匹配中的应用

* 初始设置一个空栈，顺序读入括号
* 若是右括号，则或者置于栈顶的最急迫期待得以消解，或者是不合法的情况
* 若是左括号，则作为一个新的更急迫的期待压入栈中
* 算法结束时，栈为空，否则括号序列不匹配

#### 栈在表达式求值中的应用

##### 后续表达式计算方式

顺序扫描表达式的每一项，然后根据它的类型作出如下相应操作：若该项是操作数，则将其压入栈中；若该项是操作符`<op>`，则连续从栈中退出两个操作数`Y`和`X`，形成运算指令`X<op>Y`，并将计算结果重新压入栈中。当表达式的所有项扫描并处理完毕后，栈顶存放的就是最后的结果

##### 中缀表达式转换为前缀或后缀表达式的手工做法

* 按照运算符的优先级对所有的运算单位加括号
* 转换为前缀或后缀表达式。前缀把运算符移动到对应的括号前面，后缀把运算符移动到对应的括号后面
* 把括号去掉

##### 中缀表达式转换为后缀表达式的算法思路

* 从左向右开始扫描中缀表达式
* 遇到数字时，加入后缀表达式
* 遇到运算符时
  * 若为`(`, 入栈
  * 若为`)`，则依次把栈中的运算符加入后缀表达式，直到出现`(`, 从栈中删除`(`
  * 若为除括号外的其他运算符，当其优先级高于除`(`外的栈顶运算符时，直接入栈。否则从栈顶开始，依次弹出比当前处理的运算符优先级高和优先级相等的运算符，直到一个比它优先级低的或遇到一个左括号为止。

#### 栈在递归中的应用

可以将递归算法转换为非递归算法。通常需要借助栈来实现这种转换

#### 队列在层次遍历中的应用

1. 根节点入队
2. 若队空，则结束遍历；否则重复`3`操作
3. 队列中第一个结点出队，并访问之。若其没有左孩子，则将左孩子入队，若其有左孩子，则将其右孩子入队，返回`2`

#### 队列在计算机系统中的应用

* 解决主机与外部设备之间速度不匹配的问题
* 解决由多用户引起的资源竞争问题

## 2.4 特殊矩阵的压缩存储

#### 数组的定义

**数组**是由 n 个相同类型的数据元素构成的有限序列，每个数据元素成为一个**数据元素**，每个元素在 n 个线性关系中的序号称为该元素的**下标**，下标的取值范围称为数组的**维界**

数组是线性表的推广。一维数组可视为一个线性表；二维数组可视为其元素也是定长线性表的线性表。

#### 数组的存储结构

多维数组的映方法：按行优先和按列优先

#### 矩阵的压缩存储

指为多个值相同的元素只分配一个存储空间，对零元素不分配存储空间。其目的是节省存储空间

#### 稀疏矩阵

矩阵中非零元素的个数远远小于矩阵元素的个数

使用**三元组**（行、列、值）或**十字链表法**存储，失去了**随机存取特性**