# 4. 树

## 4.1 树

### 4.1.1 树的定义

* 有且仅有一个特定的称为根的结点
* 当 $n>1$时，其余结点可分为 $m$ 个互不相交的有限集 $T_1,T_2,...,T_m$​, 其中每个集合本身又是一棵树，并且称为根的子树

### 4.1.2 基本术语

祖先、子孙、双亲、孩子、兄弟

结点的度、树的度

分支结点、叶子节点

节点的深度、高度、层次

有序树和无序树

路径和路径长度

森林

### 4.1.3 树的性质

* 树中的节点数等于所有结点的度数之和加 1
* 总结点数 = $n_0+n_1+n_2+...+n_m$​
* 总分支数 = $1n_1+2n_2+...+mn_m$​
* 总结点数 = 总分支数 + 1

## 4.2 二叉树


### 4.2.1 二叉树的定义及其主要特性

#### 定义

每个节点至多只有两棵子树，并且二叉树的子树有左右之分，不能颠倒

#### 几个特殊的二叉树

* 满二叉树：一棵高度为 h，且含有 2 h − 1 2^h-1 2h−1 个结点的二叉树称为满二叉树，除叶子结点外每个结点度数为 2
* 完全二叉树：每个结点都与同等高度的满二叉树有同样的编号
    * 若 $i\leq \lfloor n/2 \rfloor$, 则结点`i`为分支结点，否则为叶子结点
    * 当 $2i\leq n$ 时，结点`i`的左孩子编号为 $2i$, 否则无左孩子
    * 当 $2i+1\leq n$时，结点`i`的右孩子编号为 $2i+1$, 否则无右孩子
    * 结点`i`所在的层次为 $\lfloor log_2i \rfloor$
    * 叶子结点只可能在层次最大的两层上出现，对于最大层次中的叶子结点，都依次排列在该层最左边的位置上
    * 若有度为 1 的节点，则只可能有一个，且只有左孩子没有右孩子
    * 若 n 为奇数，则每个分支结点都有左孩子和右孩子；若 n 为偶数，则编号最大的分支结点只有左孩子，没有右孩子
* 二叉排序树：左子树上所有节点的关键字小于根节点的关键字；右子树上的所有节点的关键字均大于根节点的关键字
* 平衡二叉树：树上任一节点的左子树和右子树的深度之差不超过 1

#### 二叉树的性质

* 非空二叉树上的叶子结点数等于度为 2 的结点数 + 1，即 $n_0=n_2+1$

### 4.2.2 二叉树的存储结构

#### 顺序存储结构

将完全二叉树上编号为`i`的结点元素存储在一维数组下标为`i-1`的分量中

**注意**：这种存储结构建议从数组下标 1 开始存储树中的结点，若从数组下标 0 开始存储，则计算其孩子结点时与之前描述的计算公式不一致，在书写程序时需要注意。

### 链式存储结构

`lchild`	| `data`	| `rchild`
--------|-------|-------

```c
typedef struct BiTNode{
    ElemType data;//数据域
    struct BiTNode *lchild,*rchild;//左、右孩子指针
}BiTNode,*BiTree;
```

n 个结点的二叉链表中，含有`n+1`个空链域

## 4.3 二叉树的遍历和线索二叉树

### 4.3.1 二叉树的遍历

二叉树的遍历是按照某条搜索路径访问树中每个结点，使得每个结点均被访问一次，而且仅被访问一次。共有先序遍历（NLR）、中序（LNR）、后续（LRN）三中遍历方法

#### 递归遍历算法

```c
void PreOrder(BiTree T){//PreOrder-先序、InOrder-中序、PostOrder-后序
    if(T!=NULL){
        visit(T);//访问根结点
        PreOrder(T->lchild);//遍历访问左子树
        PreOrder(T->rchlid);//遍历访问右子树
    }
}
```

#### 非递归遍历算法

* 先序遍历

```c
void PreOrder2(BiTree T){
    InitStack(S);BiTree p=T;
    while(p||!IsEmpty(S)){
        if(p){
            visit(p);Push(S,p);
            p = p->lchild;
        }
        else{
            Pop(S,p);
            p = p->rchild;
        }
    }
}
```

* 中序遍历

```c
void Inorder2(BiTree T){
    InitStack(S);BiTree p = T;//初始化S，p是遍历指针
    while(p||!IsEmpty(S)){
        if(p){//一路向左
            Push(S,p);//当前结点入栈
            p = p->lchild;//左孩子不空，一直往左走
        }
        else{//出栈，并转向出栈结点的左子树
            Pop(S,p);visit(p);//栈顶元素出栈，访问出栈结点
            p = p->rchild;//向右子树走
        }
    }

}
```

* 后序遍历

```c
void PostOrder(BiTree T){
    InitStack(S);
    P = T;
    r = NULL;
    while(p||!IsEmpty(S)){
        if(p){                    //走到最左边
            push(S,p);
            p = p->lchild;
        }
        else{                            //向右
            GetTop(S,p);                //读栈顶结点（非出栈）
            if(p->rchild&&r->rchild!=r)    //若右子树存在，且未被访问过
                p = p->rchild;            //转向右
            else{                        //否则，弹出结点并访问
                pop(S,p);                //将结点弹出
                visit(p->data);            //访问该结点
                r = p;                    //记录最近访问过的结点
                p = NULL;                //结点访问完，重置p指针
            }
        }//else
    }//while
}
```

* 层次遍历

```c
void LevelOrder(BiTree T){
    InitQueue(Q);
    BiTree p;
    EnQueue(Q,T);//将根结点入队
    while(!IsEmpty(Q)){
        DeQueue(Q,p);
        visit(p);
        if(p->lchild!=NULL)EnQueue(Q,p->lchild);
        if(p->rchild!=NULL)EnQueue(Q,p->rchild);
    }
}
```

#### 由遍历序列构造二叉树

由二叉树中序遍历结果和前序、后序、层次中的一个组合，就可唯一确定一棵二叉树

### 4.3.2 线索二叉树

#### 线索二叉树的基本概念

在含`n`个结点的二叉树中，有`n+1`个空指针。引入线索二叉树正是为了加快查找结点前驱和后继的速度。

规定：若无左子树，令`lchild`指向其前驱结点；若无右子树，令`rchild`指向其后继结点

`lchild` | `ltag`  | `data` |	`rtag` |	`rchild`
-------|-------|------|------|-------

$ltag= \begin{cases} 0,&lchild域指示结点的左孩子\\ 1，&lchild域指示结点的前驱 \end{cases}$

$rtag=\begin{cases} 0,&rchild域指示结点的右孩子\\ 1，&rchild域指示结点的后继 \end{cases}$

```c
typedef struct ThreadNode{
    ElemType data;
    struct ThreadNode *lchild,*rchild;
    int ltag,rtag;
}ThreadNode,*ThreadTree;
```

#### 中序线索二叉树的构造

线索化的实质就是遍历一次二叉树

#### 中序线索二叉树的遍历

在对其进行遍历时，只要先找到序列中的第一个节点，然后依次找结点的后继，直至后继为空。在中序线索二叉树中找结点后继的规律是：若其右标志为 “1”，则右链为线索，指示其后继，否则遍历右子树中第一个访问的结点为其后继。

#### 先序线索二叉树和后序线索二叉树

后序线索二叉树上找后继时需要知道结点双亲，即需采用带标志域的三叉链表作为存储结构。

## 4.3 树、森林


### 4.3.1 树的存储结构

#### 双亲表示法

采用一组连续空间来存储每个结点，同时在每个结点中增设一个伪指针，指示其双亲结点在数组中的位置。

根节点的下标为 0，其伪指针域为`-1`

该存储结构利用了每个结点只有唯一双亲对的性质，可以很快的得到每个结点的双亲结点，但求结点的孩子需要遍历整个结构。

 `data`	 | `parent_pos`
 --------|-----------

#### 孩子表示法

将每个结点的孩子结点都用单链表链接起来形成一个线性结构

这种存储方式寻找子女的操作非常直接，而寻找双亲的操作需要遍历 n 个结点中孩子结点指针域指向的 n 个孩子链表

#### 孩子兄弟表示法

又称**二叉树表示法**。孩子兄弟表示法使每个结点包括三部分内容：结点值、指向结点第一个孩子结点的指针，及指向结点下一个兄弟结点的指针。

`data`	| `firstchild` | `nextsibling`
--------|--------------|------------

### 4.3.3 树、森林与二叉树的转化

#### 树转换为二叉树
  
  * 规则：**左孩子右兄弟**。每个结点左指针指向它的第一个孩子，右指针指向它在树中的相邻右兄弟
  
  * 画法：
    * 1. 在兄弟结点之间加一连线；
    * 2. 对每个结点，只保留它与第一个孩子的连线，而与其他孩子的连线全部抹掉；
    * 3. 以树为轴心，顺时针旋转 45°
  
  * 特点：根无右子树

#### 森林转换二叉树
  
  * 规则：先将森林中的每棵树转换为二叉树；把第二棵树的根作为第一课树根的右兄弟，以此类推
  * 画法：
    * 1. 森林中的每棵树转换为相应的二叉树 
    * 2. 每棵树的根也可视为兄弟关系，在每棵树的根之间加一根连线；
    * 3. 以第一棵树的根为轴心顺时针旋转 45°
  * 特点：森林中每棵树的根节点从第二个开始依次连接到前一棵树的根的右孩子，因此最后一棵树的根节点的右指针为空。另外，每个非终端节点，其所有孩子结点在转换后，最后一个孩子的右指针也为空。

#### 二叉树转换为森林
  
若二叉树非空，则二叉树的根及其左子树为第一棵树的二叉树形式，故将根的右链断开。二叉树根的右子树又可视为由除第一棵树外的森林转换后的二叉树。

### 4.3.4 树和森林的遍历

#### 树的遍历

* 先根遍历
* 后根遍历

#### 森林的遍历

* 先序遍历森林
    * 访问森林中第一棵树的根节点
    * 先序遍历第一棵树的根节点的子树森林
    * 先序遍历除去第一棵树后剩余的树构成的森林

* 中序遍历森林（又称后根遍历）
    * 中序遍历森林中第一课树的根节点的子树森林
    * 访问第一课树的根结点
    * 中序遍历除去第一棵树后剩余的树构成的森林

## 4.4 树与二叉树的应用

### 4.4.1 二叉排序树 BST

#### 二叉排序树的定义
  
左子树上所有节点的关键字小于根节点的关键字；右子树上的所有节点的关键字均大于根节点的关键字

#### 二叉排序树的查找、插入、构造

#### 二叉排序树的剔除
  
  * 若被删除结点`z`是叶子结点，则直接删除
  * 若结点`z`只有一棵左子树或右子树，则让`z`的子树成为`z`父节点的子树，替代`z`的位置
  * 若结点`z`有左、右两棵子树，则令`z`的直接后继替代`z`，然后从二叉排序树中删去这个直接后继，这样就转换成了上面的两种情况

#### 二叉排序树的查找效率分析
  
  * $O(log_2n)$（平衡二叉树）~ $O(n)$(链表)
  * $ASL_a$​: 平均查找长度

### 4.4.2 平衡二叉树

#### 定义

任意结点的左右子树高度差的绝对值不超过 1 的二叉排序树

#### 二叉排序树的插入

- ①LL：在A的`左孩子的左子树`中插入导致A的不平衡，将A的`左孩子右上旋`。
- ②RR：在A的`右孩子的右子树`中插入导致A的不平衡，将A的`右孩子左上旋`。
- ③LR：在A的`左孩子的右子树`中插入导致A的不平衡，将A的`左孩子的右孩子，先左上旋再右上旋`。
- ④RL：在A的`右孩子的左子树`中插入导致A的不平衡，将A的`右孩子的左孩子，先右上旋再左上旋`。


#### 平衡二叉树的查找

* 含有 n 个结点的平衡二叉树的最大深度为 $O(log_2n)$, 平均查找长度为 $O(log_2n)$
* 平衡二叉树结点数的递推关系 $n_h=1+n_{h-1}+n_{h-2},n_0=0,n_1=1,n_2=2$, $n_h$​为构造此高度的平衡二叉树所需的最少结点数

### 4.4.3 哈夫曼树和哈夫曼编码

#### 定义

* 带权路径长度： $WPL=\sum_{i=1}^nw_il_i$

* 含有`n`个带权结点的二叉树中，带权路径长度`WPL`最小的二叉树称为哈夫曼树

#### 哈夫曼树的构造

1. 将 n 个结点分别作为`n`棵仅含有一个结点的二叉树，构成森林`F`

2. 构造一个新结点，从`F`中选取两棵根结点权值最小的树作为新结点的左、右子树，并且将新结点的权值置为左、右子树上根结点的权值之和

3. 从`F`中删除刚才选出的两棵树，同时将新得到的树加入`F`中

4. 重复 2-3 步骤

#### 哈夫曼树特点

* 每个初始节点最终都成为叶结点
* 构造过程中新建了`n-1`个结点，哈夫曼树中结点总数为`2n-1`
* 不存在度为`1`的节点

#### 哈夫曼编码

* 固定长度编码：对每个字符用相等长度的二进制位表示

* 可变长度编码：允许对不同字符用不等长的二进制位表示

* 前缀编码：没有一个编码是另一个编码的前缀

* 使用哈夫曼树得到哈夫曼编码：默认为左边为 0，右边为 1（不唯一，没明确规定）