

# 3. 串

## 3.1 串的定义和实现

### 串的定义

* **串**（String）是由零个或多个字符组成的有限序列。记为 $S='a_1a_2...a_n'​$

* 串中任意多个连续的字符组成的子序列称为该串的**子串**

* 包含子串的串称为**主串**

* 由一个或多个空格组成的串称为**空格串**

### 串的存储结构

#### 定长顺序存储表示

用一组地址连续的存储单元存储串值的字符序列

```c
#define MAXLEN 255//预定义最大串长为255
typedef struct{
    char ch[MAXLEN];//每个分量存储一个字符
    int length;//串的实际长度
}SString;
```

### 堆分配存储表示

堆分配存储仍然以一组地址连续的存储单元存放串值的字符序列，但他们的存储空间是在程序执行过程中动态分配得到的

```c
typedef struct{
    char *ch;//按串分配存储区，ch指向串的基地址
    int length;//串的长度
}HString;
```

在`C`语言中，存在一个称之为**堆**的自由存储区，并用`malloc()`和`free()`函数来完成动态存储管理

利用`malloc()`为每个新产生的串分配一块实际串长所需要的存储空间，若分配成功，则返回一个指向起始地址的指针，称为串的基地址，这个串由`ch`指针来指示; 若分配失败，则返回`NULL`。已分配的空间可用`free()`释放掉

### 块链存储表示

类似于线性表的链式存储结构，也可采用链表方式存储串值。由于串的特殊性，在具体实现时，每个节点即可以存放一个字符，也可以存放多个字符，每个节点称为**块**，整个链表称为**块链结构**

### 串的基本操作

```c
StrAssign(&T,chars):赋值操作。把串T赋值为chars
StrCopy(&T,S):复制操作。由串S复制得到串T
StrEmpty(S):判空操作。若S为空串，则返回TRUE，否则返回FALSE
StrCompare(S,T):比较操作，S>T则返回值>0;k若S=T，返回0，否则返回<0
StrLength(S):求串长
SubString(&Sub,S,pos,len):求子串。用Sub返回串S的第pos个字符起长度为len的子串
Concat(&T,S1,S2):串联接。用T返回S1和S2的联接
Index(S,T):定位操作
ClearString(&S):清空
DestroyString(&S):销毁串
```

## 3.2 串的模式匹配

### 简单的模式匹配算法 BF

子串的定位操作通常称为串的**模式匹配**，它求的是子串在主串中的位置

### KMP 算法

### 基础概念

* 前缀：除最后一个字符以外，字符串的所有头部子串
* 后缀：除第一个字符外，字符串的所有尾部子串
* 部分匹配值`PM`：字符串的前缀和后缀的最长相等前后缀长度

### 算法原理

编号 |	描述 |	1	|2	|3	|4|	5
-----|-------|-----|----|---|----|----
`S`	|字符	|a	|b|	c|	a|	c
`PM`	|子串右移位数=已匹配的字符数-对应的部分匹配值：`Move=(j-1)-PM[j-1]	`|0	|0	|0	|1	|0
`next`（`PM`右移一位）|	子串右移位数：`Move=(j-1)-next[j]`，子串的比较指针回退到：`j=next[j]+1` |	-1|	0|	0|	0|	1
`next=next+1`	|在子串的第j个字符与主串发生失配时，则跳到子串的`next[j]`位置重新与主串当前位置进行比较|	0	|1|	1|	1|	2

### next[] 推导方法

*  $$next[j]=\begin{cases} 0 & j=1 \\ max\{k|1<k<j且'p_1...p_{k-1}'='p_{j-k+1}...p_{j-1}'\}& 当此集合不空时(next[ ]推导公式) \\ 1& 其他情况 \end{cases}$$

* next 的推导步骤，`next[j]=k`, 求`next[j+1]`
  
  `next[j]=k`表明 $p_1...p_{k-1}=p_{j-k+1}...p_{j-1}​$
  
  1. 若 $p_k=p_j$​, 则`next[j+1]=next[j]+1`
  2. 若 $p_k \neq p_j$​。用前缀 $p_1...p_k$ ​去跟后缀 $p_{j-k+1}...p_j$​匹配，则当 $p_k \neq p_j$​是应将 $p_1...p_k$​向右滑动至以第`next[k]`个字符与 $p_j$​比较，如果 $p_{next[k]}$​与 $p_j$​还是不匹配, 那么需要寻找长度更短的相等前后缀，下一步继续用 $P_{next[next[k]]}$​与 $p_j$​比较, 直到找到`k'=next[next...[k]]`满足条件 $'p_1...p_{k'}'='p_{j-k'+1}...p_{j}'$​, 则`next[j+1]=k'+1`

### 说明

* 为什么`next[1]=0`：当模式串中的第一个字符与主串的的当前字符比较不相等时，`next[1]=0`, 表示模式串应该右移一位，主串当前指针后移一位，再和模式串的第一个字符进行比较
* 为什么要取`max{k}`：当主串的第`i`个字符与模式串的第`j`个字符失配时，主串`i`不回溯，则假定模式串的第`k`个字符与主串的第`i`个字符比较,`k`应满足条件 $1<k<j 且'p_1...p_{k-1}'='p_{j-k+1}...p_{j-1}'$​。为了不使向右移动丢失可能的匹配，右移距离应该取最小，由于 $j-k$ 表示右移距离，所以取 $max\{k\}$。

### KMP 算法的进一步优化

`nextval[]`, 如果出现了 $p_j=p_{next[j]}$​, 则将`next[j]`修正为`next[ next[j] ]`, 直到两者不相等