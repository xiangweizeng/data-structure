# 6. 查找

## 6.1 查找的概念

* **查找**：在数据集合中寻找满足某种条件的数据元素的过程称为查找。查找的结果分为**成功**和**失败**
* **查找表**：用于查找的数据集合称为查找表。对查找表进行的操作一般有四种
    * 查询
    * 查询关键字的其他信息
    * 插入
    * 删除
* 静态查找表：不涉及插入和删除的查找表
* 关键字：数据元素中唯一标识该元素的某个数据项的值
* 平均查找长度： $ASL=\sum_{i=1}^nP_iC_i$​, $P_i$​是概率， $C_i$​是比较次数

## 6.2 顺序查找和折半查找

### 6.2.1 顺序查找

#### 一般线性表的顺序查找

```c
typedef struct{
    ElemType *elem;
    int TableLen;
}SSTable;
int Search_Seq(SSTable ST,ElemType key){
    ST.elem[0] = key;    //哨兵
    for(i=ST>TableLen;ST.elem[i]!=key;--i);    //从后往前找
    return i;//若表中不存在关键字为key的元素，将查找到i为0时退出循环
}
```

* 哨兵：引入它的目的是可以不必判断数组是否会越界。引入哨兵可以避免很多不必要的判断语句，从而提高程序效率

#### 有序表的顺序查找

* 由于表的关键字是有序的，查找失败时可以不用比较到表的另一端就能返回失败信息

### 6.2.2 折半查找

* 折半查找又称二分查找，仅适用于有序的顺序表

* 仅适用于顺序存储结构，不适用于链式存储结构

* 生成的**判定树**
  
    * 是平衡二叉树
    * 有 n 个圆形结点代表原数据或成功结点，n+1 个方框结点代表不成功结点
    * 每个圆形结点都不是叶子结点，一定有方框子结点
    * 倒数第二层圆结点个数 = $n - 前面层所有结点数$
    * $倒数第二层方形结点个数 = 2^{h-1}- 倒数第二层圆结点$
    * $最后一层方结点个数 =n+1-倒数第二层方形结点个数$
    * 如果判定树是向上取整，则所有结点的左子树结点总数永远不小于右子树结点整数，向下取整同理

* 基本思想
  
  首先将给定的`key`与表的中间位置的关键字比较，成功后返回；否则根据`key`与关键字的大小判断查找左边还是右边
  
  折半查找整个算法中，关于 mid 的取值向上 / 向下需要统一

```c
int Binary_Search(SeqList L,ElemType key){
    int low=0,high=L.TableLen-1,mid;
    while(low<=high){
        mid = (low+high)/2;        //取中间位置
        if(L.elem[mid]==key)
            return mid;    
        else if(L.elem[mid]>key)
            high = mid-1;//从前半部分继续查找
        else
            low = mid+1;//从后半部分继续查找
    }
    return -1;        //查找失败，返回-1
}
```

### 6.2.3 分块查找

* 又称索引顺序查找，它吸取了顺序查找和折半查找各自的优点，既有动态结构，又适合快速查找

* 基本思想
  
  将查找表分成若干块。块内的元素可以是无序的。但块之间按照每个块的最大关键字进行排序
  
  建立一个索引表，索引表中的每个元素含有各块的最大关键字和各块的第一个元素的地址，索引表按关键字有序排列

* 分块查找的过程
  
  * 在索引表中确定待查记录所在的块，可以顺序查找或折半查找索引表
  * 在块内顺序查找

* 索引查找的平均查找长度 $L_I$​, 块内查找的平均查找长度 $L_S$

### 6.2.4 时间复杂度评价

查找算法 | $ASL_{成功}$ | $ASL_{失败}$
--------|----------|-------
顺序查找-无序表	| $\frac{n+1}{2}$ | $n+1$
顺序查找-有序表	| $\frac{n+1}{2}$ | $\frac{n} {2} +\frac{n}{n+1}$
折半查找	| $sum(圆形结点*对应层数)/n$|  $sum(方结点∗对应层数−1)/(n+1)$
分块查找	|$ASL=L_I+L_S$ | -

## 6.3 B 树和 B + 树

### 6.3.1 B 树及其基本操作

B 树又称**多路平衡查找树**，B 树中所有结点的孩子个数的最大值称为 B 树的阶，通常用`m`表示。

B 树是所有结点的平衡因子都等于 0 的多路平衡查找树

#### 定义

* 树中每个结点至多有 m 棵子树，即至多含有 m-1 个关键字
* 若根结点不是终端节点，则至少有两棵子树
* 除根结点外的所有非叶结点至少有 $\lceil m/2 \rceil$棵子树，即至少含有 $\lceil m/2 \rceil-1$ 个关键字
* 所有非叶子结点的结构如下:
$n$	| $P_0$ | $K_1$ | $P_1$ |$K_2$ | $P_2$ |$...$ |	$K_n$ | $P_n$
 其中， $K_i$为结点的关键字， $P_i$​为指向子树根结点的指针，且:
    - 指针 $P_{i-1}$ ​所指子树中所有结点的关键字均小于 $K_i$
    - 指针$P_i$​所指子树中所有结点的关键字均大于 $K_i$​
    - 结点的孩子个数等于该节点中关键字个数加 1

* 所有的叶节点都出现在同一层次上，并且不带信息，称为外部结点


#### B 树的高度

B 树的高度不包括最后的外部结点那一层

$\log_m(n+1) \leq h \leq \log_{\lceil m/2\rceil}((n+1)/2)+1$

#### B 树的查找

* 在 B 树中找结点，在磁盘中进行
* 在结点在找关键字，在内存中进行

#### B 树的插入

1. 定位：利用 B 树的查找算法，找出插入该关键字的最低层中的某个非叶结点
2. 插入：在 B 树中，每个失败结点的关键字个数都在区间 $[\ \lceil m/\rceil-1.m-1]$ 内。插入后的结点关键字个数小于 m，可以直接插入。如果插入后关键字个数大于`m-1`, 必须进行分裂
   * 分裂方法是
     * 取一个新结点，在插入 key 后的原结点，从中间位置将其中的关键字分为两部分
     * 左部分包含的关键字放在原结点中，右部分包含的关键字放到新结点中
     * 中间位置 1 的节点插入原节点的父节点。
     * 若此时导致父节点也超过了上限，则对父节点继续分裂

#### B 树的删除

* 当被删关键字`k`**不在终端结点**时，可以用 k 的前驱或后继`k'`替代`k`, 然后在相应的结点中删除`k'`。关键字`k'`必定落在某个终端节点中，则转换成了被删关键字在终端结点中的情形

* 当被删关键字`k`**在终端结点**中时
  
    * **直接删除关键字**：若被删除关键字所在结点的关键字个数 > $\lceil m/2 \rceil$, 表明删除该关键字后仍满足 B 树的定义，则直接是删除该关键字
    
    * **兄弟够借**：若被删除关键字所在结点的关键字个数 = $\lceil m/2 \rceil-1$, 且与此节点相邻的右（左）兄弟节点的关键字个数 $\geq \lceil m/2 \rceil$, 则需要调整该节点、右（左）兄弟结点及其双亲结点（父子换位法），以达到新的平衡
    
    * **兄弟不够借**：若被删除关键字所在结点的关键字个数 = $\lceil m/2 \rceil-1$, 且与此节点相邻的右（左）兄弟节点的关键字个数均 $\lceil m/2 \rceil-1$, 则将关键字删除后与左（或右）兄弟结点及双亲结点中的关键字进行合并。
    在合并过程中，双亲结点中的关键字个数会减 1。若其双亲结点是根结点且关键字个数减少至 0，则直接将根结点删除，合并后的新结点成为根；若其双亲结点不是根结点，且关键字减少超过下限，在继续合并操作。

### 6.3.2 B + 树的基本概念

* 每个分支结点最多有 m 棵子树
* 非叶根结点至少有两棵子树，其他每个分支结点至少有 $\lceil m/2 \rceil$棵子树
* 结点的子树个数与关键字个数相等
* 所有叶结点包含全部关键字及指向相应记录的指针，叶节点中将关键字按大小顺序排雷，并且相邻叶节点按大小顺序相互链接起来
* 所有分支结点中仅包含它的各个子节点中关键字的最大值及指向其子结点的指针

在 B + 树中查找时，非叶结点上的关键字值等于查找值时并不停止，而是继续往下找，直到叶结点上的该关键字为止。无论成功与否，每次查找都是一条从根结点到叶结点的路径

### 6.3.3 B 树 VSB + 树

   说明| B树	| B+树 
----|-----|-----
关键字个数为n的结点的子树个数	| n-1	| n
结点关键字个数n范围	|$\lceil m/2 \rceil \leq n \leq m⌈m/2⌉≤n≤m$| $\lceil m/2 \rceil -1\leq n \leq m -1$
  -| -|叶结点包含信息，所有非叶结点仅起索引作用，非叶结点中的每个索引项只含有对应子树的最大关键字和指向该子树的指针，不含有该关键字对应记录的存储地址
-|叶结点包含的关键字和其他结点包含的关键字是不重复的|	叶节点包含了全部关键字，即在非叶结点中出现的关键字也会出现在叶结点中


## 6.4 散列表

### 6.4.1 散列表的基本概念

* 散列函数：一个把查找表中关键字映射成该关键字对应的地址的函数，记为`Hash(key)=Addr`
* 冲突：散列函数把两个或两个以上的不同关键字映射到同一地址的现象
* 同义词：引起冲突的关键字
* 散列表：根据关键字而直接进行访问的数据结构。散列表建立了关键字和存储地址之间的一种直接映射关系

### 6.4.2 散列函数的构造方法

#### 散列函数的要求

* 定义域包含全部关键字，值域依赖于散列表的大小或地址范围
* 散列函数计算出的地址应该能等概率、均匀的分布在整个地址空间中，减少冲突发生
* 尽可能简单，能够快速计算出散列地址

常见构造函数 | 公式	|评价
------------|------|---------
直接定地法	| $H(key)=key$ 或H $H(key)=a \times key+b$|	最简单，不会产生冲突。适合关键字的分布基本连续的情况
除留余数法	| $H(key)=key\%p$，$p$ 为不大于散列表表长$m$但最接近或等于$m$的质数	|
数字分析法 |	设关键字是r进制数，选取数码分布比较均匀的若干位作为散列地址 |	适合于一致的关键字集合，若更换了关键字，则需要重新构造新的散列函数
平方取中法	| 取关键字对的平方值的中间几位作为散列值	|适用于关键字的每位取值都不均匀或均小于散列地址所需的位数

### 6.4.3 处理冲突的方法

* 开放定址法， $H_i=(H(key)+d_i)\%m$, $m$ 表示散列表表长，$d_i$​为增量序列

开放定址法	| $d_i$ | 补充说明
------------|------|---------
线性探测法	| $0,1,2,...,m-1$|可能出现大量元素在相邻地址上聚集，降低查找效率
平方探测法	| $0^2,1^2,-1^2,2^2,-2^2,...,k^2,-k^2$ |散列表长度m必须是一个可以表示成4k+3的素数
再散列法	| $i*Hash_2(key)$ | i是冲突的次数
伪随机序列法 |	$d_i==随机序列$ |	


* 拉链法
  
  把所有的同义词存储在一个线性链表中，这个线性链表由其散列地址唯一标识

### 6.4.4 散列查找及性能分析

#### 查找过程

1. 初始化`Addr=Hash(key)`
2. 检测查找表中地址为`Addr`的位置上是否有记录，若无记录，返回查找失败；若有记录。比较它与 key 的值，若相等，则返回查找成功的标志，否则执行步骤 3
3. 用给定的处理冲突方法计算 “下一个散列地址”，并将`Addr`置为此地址，转入步骤 2

**散列表的查找效率取决于散列函数、处理冲突的方法和装填因子**

* 装填因子$\alpha$定义为一个表的装满程度  
  $\alpha = \frac{表中记录数 n}{散列表长度 m}$