
# 7. 排序

## 7.1 排序的基本概念

* 排序：就是重新排列表中的元素，使表中的元素满足按关键字有序的过程
* 算法的稳定性：在排序之前关键字相同的元素，在排序后相对位置不变的排序算法是稳定的
* 内部排序：排序期间元素全部存放在内存中的排序
* 外部排序：排序期间元素无法全部同时同放在内存中，必须在排序的过程中根据要求不断的在内、外存之间移动的排序
* 可将排序算法分为：插入排序、交换排序、选择排序、归并排序和基数排序五大类

## 7.2 插入排序

基本思想：每次讲一个待排序的记录按其关键字大小插入前面已排好序的子序列，直到全部记录插入完成

### 7.2.1 直接插入排序

要将`L(i)`插入已有序的子序列`L[1...i-1]`，需要执行以下操作

* 查找出`L(i)`在`L[1...i-1]`中的插入位置`k`

* 将`L[k...i-1]`中的所有元素依次后移一个位置

* 将`L(i)`复制到`L(k)`

```c
void InsertSort(ElemType A[],int n){
    int i,j;
    for(i=2;i<=n;i++)    //依次将A[2]...A[n]插入到前面已排序的序列
        if(A[i]<A[i-1]){    //若A[i]小于前驱，则将其插入前面的有序表
            A[0] = A[i];    //哨兵
            for(j=i-1;A[0]<A[j];--j)    //从i-1开始比较，比较一次，向后移动一次
                A[j+1] = A[j];    
            A[j+1] = A[0];        //找到插入位置，赋值
        }
}
```

### 7.2.2 折半插入排序

* 查找有序子表时用折半查找来实现
* 确定待插入位置后，同意以地向后移动元素

```c
void InsertSort(ElemType A[],int n){
    int i,j,low,high,mid;
    for(i=2;i<=n;i++){        //依次将A[2]...A[n]插入到前面已排序的序列
        A[0] = A[i];        //暂存单元，不是哨兵
        low = 1;high = i-1;    
        while(low<=high){        //折半查找
            mid = (low+high)/2;
            if(A[min]>A[0]) high = mid-1;
            else low = mid+1;
        }
        for(j=i-1;j>=high+1;--j)    //统一后移元素
            A[j+1] = A[j];
        A[high+1] = A[0];            //赋值
    }
}
```

### 7.2.3 希尔排序

基本思想：先将待排序表分割成若干形如`L[i,i+d,i+2d,...,i+kd]`的特殊子表，即把相隔某个 “增量” 的记录组成一个子表，对每个子表分别进行直接插入排序，当整个表中的元素已呈 “毕本有序” 时，再对全体记录进行一次直接插入排序

**过程**

* 先取一个小于 n 的步长 $d_1$​, 把表中的全部记录分成 $d_1$​组，所有距离为 $d_1$​的倍数的记录放在同一组，在各组内进行直接插入排序
* 然后取第二个步长 $d_2<d_1$​.
* 重复上述过程，直到所取到的 $d_t=1$，即所有记录已放在同一组，再进行直接插入排序

**增量序列：** $d_1=n/2,d_{i+1}=\lfloor d_i/2 \rfloor$, 最后一个增量等于 1

```c
void ShellSort(ElemType A[],int n){
    //A[0]只是暂存单元，不是哨兵
    for(dk=n/2;dk>=1;dk=dk/2)        //步长变换
        for(i=dk+1;i<=n;i++)        //对d_i个组进行直接插入排序
            if(A[i]<A[i-dk]){        //需要将A[i]插入所在的有序子表中
                A[0] = A[i];        //暂存A[i]
                for(j=i-dk;j>0&&A[0]<A[j];j-=dk)//寻找插入位置
                    A[j+dk] = A[j];        //记录后移
                A[j+dk] = A[0];            //插入
            }
}
```

## 7.3 交换排序

### 7.3.1 冒泡排序

基本思想：从后往前（或从前往后）两两比较相邻元素的值，若为逆序则交换，指导序列比较完。

```c
void BubbleSort(ElemType A[],int n){
    for(i=0;i<n-1;i++){
        flag = false;                //表示本趟冒泡是否发生交换的标志
        for(j=n-1;j>i;j--)            //一趟冒泡过程
            if(A[j-1]>A[j]){        //若为逆序
                swap(A[j-1],A[j]);    //交换
                flag = true;
            }
        if(flag==false)
            return;            //本趟遍历后没有发生交换，说明表已经有序
    }
}
```

注意：冒泡排序所产生的有序子序列是全局有序的。每一趟排序都会将一个元素放置到其最终的位置上

### 7.3.2 快速排序

基本思想：在待排序表`L[1...n]`中任取一个元素`pivot`作为**枢轴**, 通过一趟排序将待排序表划分为独立的两个部分`L[1...k-1]`和`L[k+1...n]`, 使得`L[1...k-1]`中的所有元素小于`pivot`,`L[k+1...n]`中的所有元素大于等于`pivot`, 则`pivot`放在了其最终位置`L(k)`上，这个过程称为一趟快速排序。然后分别对左右两部分重复上述过程，直到每个部分只有一个元素。

```c
void QuickSort(ElemType A[],int low,int high){
    if(low<high){
        //Partition()就是划分操作，将表划分成满足条件的两个子表
        int pivotpos=Partition(A,low,high);    //划分
        QuickSort(A,low,pivotpos-1);
        QuickSort(A,pivots+1,high);
    }
}
```

```c
int Partition(ElemType A[],int low,int high){    //一趟划分
    ElemType pivot=A[low];
    while(low<high){
        while(low<high&&A[high]>=pivot) --high;
        A[low] = A[high];        //将比枢轴小的元素移动到左边
        while(low<high&&A[low]<=pivot) ++low;
        A[high] = A[low];        //将比枢轴大的元素移动到右边
    }
    A[low] = pivot;            //枢轴放到最终位置
    reutrn low;
}
```

快速排序是所有内部排序算法中平均性能最优的排序算法

### 7.4 选择排序


### 7.4.1 简单选择排序

基本思想：假设排序表为`L[1...n]`, 第`i`趟排序即从`L[i...n]`中选择关键字最小的元素与`L(i)`交换，每一趟排序可以确定一个元素的最终位置，经过 n-1 趟排序可以使整个排序表有序

```c
void SelectSort(ElemType A[],int n){
    for(i=0;i<n-1;i++){                //一共进行n-1趟
        min = i;                    //记录最小元素位置
        for(j=i+1;j<n;j++)            //在A[1...n-1]中选择最小的元素
            if(A[j]<A[min]) min = j;    //更新最小的元素
        if(min!=j) swap(A[i],A[min]);    //封装的swap()函数共移动3次
    }
}
```

### 7.4.2 堆排序

* 大根堆：`L(i)>=L(2i) & L(i)>=L(2i+1)`, 最大元素在根结点

* 小根堆：`L(i)<=L(2i) & L(i)<=L(2i+1)`, 最小元素在根结点

* 堆的插入：把新结点放到堆的末端，后进行向上调整

* 构造初始堆：
  
    * n 个结点的完全二叉树，最后一个结点是第 $\lfloor n/2 \rfloor$个结点的孩子。对第$\lfloor n/2 \rfloor$个结点为根的子树筛选（对于的大根堆，若根结点的关键字小于左右孩子中关键字较大者，则交换），使该子树成为堆。
    * 之后向前依次对各节点$\lfloor n/2 \rfloor-1 \sim 1$ 为根的子树进行筛选，看该结点值是否大于其左右子节点的值，不大于的话进行交换
    * 交换后可能会破坏下一级的堆，使用上述办法继续构造下一级的堆，直到以根结点形成堆为止

* 输出堆顶元素，重新构建堆，重复这一过程

```c
void BuildMaxHead(ElemType A[],int len){
    for(int i=len/2;i>0;i--)    //从i=n/2开始，反复调整堆
        HeadAdjust(A,i,len);    
}
void HeadAdjust(ElemType A[],int k,int len){
    //将元素k为根的子树进行调整
    A[0] = A[k];    //A[0]暂存子树的根节点
    for(i=2*k;i<=len;i*2){        //沿key较大的子节点向下筛选
        if(i<len&&A[i]<A[i+1])i++;    //取i为较大子结点
        if(A[0]>=A[i])break;    //筛选结束
        else{
            A[k]=A[i];            //将A[i]调整到双亲结点上
            k=i;        //修改k值，继续向下筛选
        }
    }
    A[k] = A[0];        //被筛选结点的值放入最终位置
}
```

```c
void HeapSort(ElemType A[],int len){
    BuildMAxHeap(A,len);
    for(i=len;i>1;i--){        //n-1趟的交换和建堆过程
        Swap(A[i],A[1]);    //输出堆顶元素，和堆底元素交换
        HeadAdjust(A,1,i-1);//调整，把剩余的i-1个元素整理成堆
    }
}
```

## 7.5 归并排序和基数排序

### 7.5.1 归并排序

假定待排序表含有 n 个记录，则可将其视为 n 个有序的子表，每个子表的长度为 1，然后两两合并，得到 $\lceil n/2 \rceil$个长度为 2 或 1 的有序表，继续两两合并。这种排序方法称为 2 路归并排序。

一趟归并排序的操作是，调用 $\lceil n/2h \rceil$ 次算法`merge()`, 将`L[1...n]`中前后相邻且长度为 h 的有序段进行两两归并，得到前后相邻、长度为 2h 的有序段进行两两归并，得到前后相邻、长度为 2h 的有序段，整个归并排序需要进行 $\lceil log_2n\rceil$趟

```c
ELemType *B=(ElemType *)malloc((n+1)*sizeof(ElemType));    //辅助数组B
void Merge(ElemType A[],int low,int mid,int high){
    for(int k=low;k<=high;k++)B[k] = A[k];    //将A中元素放到B中
    for(i=low,j=mid+1,k=i;i<=mid&&j<=high;k++){
        if(B[i]<=B[j])A[k] = B[i++];    //将较小值赋值到A中
        else A[k] = B[j++];
    }
    while(i<=mid) A[k++] = B[i++];    //若一个表未检测完，赋值
    while(j<=high) A[k++] = B[j++];    //若第二个表未检测完，赋值
}
void MergeSort(ElemType A[],int low,int high){
    if(low<high){
        int mid = (low+high)/2;
        MergeSort(A,low,mid);
        MergeSort(A,mid+1,high);
        Merge(A,low,mid,high);    //归并
    }
}
```

### 7.5.2 基数排序

* 最高位优先法`MSD`: 将关键字位权重递减一次逐层划分成若干更小的子序列，最后将所有子序列依次连接成一个有序序列
* 最低位优先法`LSD`：将关键字权重递增一次进行排序，最后形成一个有序序列

排序过程：

* 在排序中，使用 r 个队列 $Q_0,Q_1,...,Q_{r-1}$​

* 对 $i=0,1,...,d-1$，依次做一次**分配**和**收集**，每个关键字结点 $a_j$​由 d 元组组成

* 分配：开始时，把 $Q_0,Q_1,...,Q_{r-1}$​各个队列置成空队列，然后依次考察线性表中的每个结点 $a_j$​, 若 $a_j$ ​的关键字 $k_j^i=k$，就把 $a_j$ ​放进 $Q_k$ ​队列中

* 收集：把 $Q_0,Q_1,...,Q_{r-1}$​各个队列中的结点依次首尾相连，得到新的结点序列，从而组成新的线性表

## 7.6 各种内部排序算法比较及应用


### 7.6.1 内部排序算法的比较

算法种类	|时间复杂度-最好|	时间复杂度-平均|	时间复杂度-最坏	|空间复杂度	|是否稳定
------------|---------------|---------------|----------|----------|------
直接插入排序 |	$O(n)$	| $O(n^2)$ | $O(n^2)$ | $O(1)$ |	是
冒泡排序	 |  $O(n)$  | $O(n^2)$ | $O(n^2)$ | $O(1)$ |	是
简单选择排序 |	$O(n^2)$ | $O(n^2)$ | $O(n^2)$ | $O(1)$ |	否
希尔排序	|			|          |         | $O(1)$  |	否
快速排序	|   $O(n\log_2n)$| $O(n\log_2n)$ | $O(n^2)$|	$O(\log_2n)$ |	否
堆排序	| $O(n\log_2n)$  | $O(n\log_2n)$ | $O(n\log_2n)$ | $O(1)$|	否
2路归并排序	|$O(n\log_2n)$ | $O(n\log_2n)$ | $O(n\log_2n)$ | $O(n)$	|是
基数排序	| $O(d(n+r))$ | $O(d(n+r))$ | $O(d(n+r))$ | $O(r)$|	是


#### 选取排序方法需要考虑的因素

* 待排序的元素数目 n：较小考虑直接插入和简单选择排序，较大考虑快排】堆排序、归并排序
* 元素本身信息量的大小：是否选取移动量较少的排序方法
* 关键字的结构及其分布情况：如已经有序，则选取直接插入或冒泡排序
* 稳定性的要求
* 语言工具的要求，存储结构及辅助空间的大小等

## 7.7 外部排序

* 外部排序指待排序文件较大，内存一次放不下，需存放在外存的文件的排序
* 为减少平衡归并中外存读写次数所采取的方法：增大归并路数和减少归并段个数
* 利用败者树增大归并路数
* 利用置换 - 选择排序增大归并段长度来减少归并段的个数

### 7.7.1 外部排序的基本概念

在许多应用中，经常需要对大文件进行排序，因为文件中的记录很多、信息量庞大，无法将整个文件复制进内存中进行排序。因此，需要将待排序的记录存储在外存之上，排序时再把数据一部分一部分地调进内存进行排序，在排序过程中需要多次进行内存和外存之间的交换。这种排序方法就称为**外部排序**

### 7.7.2 外部排序的方法

* 根据内存缓冲区的大小，将外存上的文件分成若干长度为 $l$ 的子文件，依次读入内存并利用内部排序方法对它们进行排序，并将排序后得到的有序子文件重新写回外存，称这些有序子文件称为归并段或顺串
* 对这些归并段进行逐趟归并，使归并段逐渐由小到大，直至得到整个有序文件为止
* `外部排序的总时间=内部排序所需时间+外存信息读写的时间+内部归并所需的时间`
* 在进行归并的时候，需要使用输入缓冲区和输出缓冲区，在内存和外存中传输数据
* 对`r`个初始段归并，做`k`路平衡归并，归并树可用严格 k 叉树来表示，树的高度 = $\lceil \log_kr\rceil$ = 归并趟数 S

### 7.7.3 多路平衡归并与败者树

* 做内部归并时，在 k 个元素中选择关键字最小的记录需要比较 k-1 次，S 趟归并总需的比较次数是 $S(n-1)(k-1)=\lceil \log_kr\rceil(n-1)(k-1)=\lceil \log_2r \rceil (n-1)(k-1)\lceil \log_2k \rceil$

* 引入败者树后，在 k 个元素中选择关键字最小的记录需要比较 $\lceil \log_2k \rceil$ 次，内部归并的比较次数与 k 无关。因此只要内存允许，增大归并路数 k 将有效减少归并树的高度，提高外部排序饿的速度

* 败者树
  
    * k 个叶结点分别存放 k 个归并段在归并过程中当前参加比较的记录
    * 内存结点用来记忆左右子树中的失败者，而让胜者往上继续比较，一直到根结点
    * 根结点记录胜者
    * 叶结点进行编号 $b0 \sim bk$, 内存结点编号 $ls[0] \sim ls[k]$, $ls[0]$ 为根结点

### 7.7.4 置换 - 选择排序（生成初始归并段）

初始待排文件`FI`, 初始归并段输出文件为`FO`, 内存工作区为`WA`,`FO`与`WA`的初始状态为空，`WA`可容纳 w w w 个记录

1. 从`FI`输入 w 个记录到工作区`WA`
2. 从`WA`中选出其中关键字取最小值的记录，记为`MINIMAX`
3. 将`MINIMAX`就输出到`FO`中去
4. 若`FI`不为空，则从 FI 输入下一个记录到`WA`中
5. 从`WA`中鄋关键字比`MINIMAX`记录的关键字大的记录中选出最小关键字记录，作为新的`MINIMAX`
6. 重复`3-5`，直至在`WA`中选不出新的`MINIMAX`记录为止，由此得到一个初始归并段，输出一个归并段的结束标志至`FO`中去
7. 重复`2-6`，直至`WA`为空，由此得到全部初始归并段

### 7.7.5 最佳归并树

把归并段的长度作为权值，进行严格 k 叉树的哈夫曼树思想，构造最佳归并树

* $(n_0-1)\%(k-1)=0$, 不需要添加
* $(n_0-1)\%(k-1)=u\neq0$, 需要添加 $k-1-u$ 个长度为 0 的虚段