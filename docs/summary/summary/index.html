
<!doctype html>
<html lang="zh" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      <link rel="icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.3.0, mkdocs-material-8.3.9">
    
    
      
        <title>核心知识点 - 数据结构总结</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.1d29e8d0.min.css">
      
        
        <link rel="stylesheet" href="../../assets/stylesheets/palette.cbb835fc.min.css">
        
          
          
          <meta name="theme-color" content="#2094f3">
        
      
      
    
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../../stylesheets/extra.css">
    
    <script>__md_scope=new URL("../..",location),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="" data-md-color-primary="blue" data-md-color-accent="">
  
    
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#_1" class="md-skip">
          跳转至
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="页眉">
    <a href="../.." title="数据结构总结" class="md-header__button md-logo" aria-label="数据结构总结" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            数据结构总结
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              核心知识点
            
          </span>
        </div>
      </div>
    </div>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="搜索" placeholder="搜索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="查找">
        
        <button type="reset" class="md-search__icon md-icon" aria-label="清空当前内容" tabindex="-1">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            正在初始化搜索引擎
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
            
<nav class="md-tabs" aria-label="标签" data-md-component="tabs">
  <div class="md-tabs__inner md-grid">
    <ul class="md-tabs__list">
      
        
  
  


  
  
  
    <li class="md-tabs__item">
      <a href="../../00-%E7%BB%AA%E8%AE%BA/0.%E7%BB%AA%E8%AE%BA/" class="md-tabs__link">
        知识精要
      </a>
    </li>
  

      
        
  
  
    
  


  <li class="md-tabs__item">
    <a href="./" class="md-tabs__link md-tabs__link--active">
      核心知识点
    </a>
  </li>

      
        
  
  


  <li class="md-tabs__item">
    <a href="../question/" class="md-tabs__link">
      核心考点
    </a>
  </li>

      
    </ul>
  </div>
</nav>
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

  


<nav class="md-nav md-nav--primary md-nav--lifted" aria-label="导航栏" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="数据结构总结" class="md-nav__button md-logo" aria-label="数据结构总结" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    数据结构总结
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_1" type="checkbox" id="__nav_1" >
      
      
      
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
      
      
        <label class="md-nav__link" for="__nav_1">
          知识精要
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="知识精要" data-md-level="1">
        <label class="md-nav__title" for="__nav_1">
          <span class="md-nav__icon md-icon"></span>
          知识精要
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../00-%E7%BB%AA%E8%AE%BA/0.%E7%BB%AA%E8%AE%BA/" class="md-nav__link">
        0.绪论
      </a>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_1_2" type="checkbox" id="__nav_1_2" >
      
      
      
        
          
        
          
        
          
        
          
        
          
        
          
        
      
      
        <label class="md-nav__link" for="__nav_1_2">
          1.线性表
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="1.线性表" data-md-level="2">
        <label class="md-nav__title" for="__nav_1_2">
          <span class="md-nav__icon md-icon"></span>
          1.线性表
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../01-%E7%BA%BF%E6%80%A7%E8%A1%A8/1.1%E7%BA%BF%E6%80%A7%E8%A1%A8/" class="md-nav__link">
        1.1线性表
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../01-%E7%BA%BF%E6%80%A7%E8%A1%A8/1.2%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%A4%BA/" class="md-nav__link">
        1.2线性表的顺序存储
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../01-%E7%BA%BF%E6%80%A7%E8%A1%A8/1.3%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8/" class="md-nav__link">
        1.3线性表的链式存储
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../01-%E7%BA%BF%E6%80%A7%E8%A1%A8/1.4%E5%8F%8C%E9%93%BE%E8%A1%A8/" class="md-nav__link">
        1.4双链表
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../01-%E7%BA%BF%E6%80%A7%E8%A1%A8/1.5%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/" class="md-nav__link">
        1.5循环链表
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../01-%E7%BA%BF%E6%80%A7%E8%A1%A8/1.6%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8/" class="md-nav__link">
        1.6静态链表
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_1_3" type="checkbox" id="__nav_1_3" >
      
      
      
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
      
      
        <label class="md-nav__link" for="__nav_1_3">
          2.栈和队列
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="2.栈和队列" data-md-level="2">
        <label class="md-nav__title" for="__nav_1_3">
          <span class="md-nav__icon md-icon"></span>
          2.栈和队列
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../02-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/2.1%E6%A0%88/" class="md-nav__link">
        2.1栈
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../02-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/2.2%E6%A0%88%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8/" class="md-nav__link">
        2.2栈的顺序存储
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../02-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/2.3%E6%A0%88%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8/" class="md-nav__link">
        2.3栈的链式存储
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../02-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/2.4%E9%98%9F%E5%88%97/" class="md-nav__link">
        2.4队列
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../02-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/2.5%E9%98%9F%E5%88%97%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8/" class="md-nav__link">
        2.5队列的顺序存储
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../02-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/2.6%E9%98%9F%E5%88%97%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8/" class="md-nav__link">
        2.6队列的链式存储
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../02-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/2.7%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97/" class="md-nav__link">
        2.7双端队列
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../02-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/2.8%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8/" class="md-nav__link">
        2.8栈和队列的应用
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../02-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/2.9%E7%89%B9%E6%AE%8A%E7%9F%A9%E9%98%B5%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%AD%98%E5%82%A8/" class="md-nav__link">
        2.9特殊矩阵的压缩存储
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_1_4" type="checkbox" id="__nav_1_4" >
      
      
      
        
          
        
          
        
          
        
      
      
        <label class="md-nav__link" for="__nav_1_4">
          3.串
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="3.串" data-md-level="2">
        <label class="md-nav__title" for="__nav_1_4">
          <span class="md-nav__icon md-icon"></span>
          3.串
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../03-%E4%B8%B2/3.1%E4%B8%B2/" class="md-nav__link">
        3.1串
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../03-%E4%B8%B2/3.2%E4%B8%B2%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/" class="md-nav__link">
        3.2串的存储结构
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../03-%E4%B8%B2/3.3%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/" class="md-nav__link">
        3.3字符串模式匹配
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_1_5" type="checkbox" id="__nav_1_5" >
      
      
      
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
      
      
        <label class="md-nav__link" for="__nav_1_5">
          4.树
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="4.树" data-md-level="2">
        <label class="md-nav__title" for="__nav_1_5">
          <span class="md-nav__icon md-icon"></span>
          4.树
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../04-%E6%A0%91/4.1%E6%A0%91/" class="md-nav__link">
        4.1树
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../04-%E6%A0%91/4.2%E4%BA%8C%E5%8F%89%E6%A0%91/" class="md-nav__link">
        4.2二叉树
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../04-%E6%A0%91/4.3%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/" class="md-nav__link">
        4.3线索二叉树
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../04-%E6%A0%91/4.4%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/" class="md-nav__link">
        4.4树的存储结构
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../04-%E6%A0%91/4.5%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/" class="md-nav__link">
        4.5二叉排序树
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../04-%E6%A0%91/4.6%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/" class="md-nav__link">
        4.6平衡二叉树
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../04-%E6%A0%91/4.7%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/" class="md-nav__link">
        4.7哈夫曼树
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_1_6" type="checkbox" id="__nav_1_6" >
      
      
      
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
      
      
        <label class="md-nav__link" for="__nav_1_6">
          5.图
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="5.图" data-md-level="2">
        <label class="md-nav__title" for="__nav_1_6">
          <span class="md-nav__icon md-icon"></span>
          5.图
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../05-%E5%9B%BE/5.1%E5%9B%BE/" class="md-nav__link">
        5.1图
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../05-%E5%9B%BE/5.2%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/" class="md-nav__link">
        5.2图的存储结构
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../05-%E5%9B%BE/5.3%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/" class="md-nav__link">
        5.3图的基本操作
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../05-%E5%9B%BE/5.4%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86%28BFS%E3%80%81DFS%29/" class="md-nav__link">
        5.4图的遍历(BFS、DFS)
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../05-%E5%9B%BE/5.5%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/" class="md-nav__link">
        5.5最小生成树
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../05-%E5%9B%BE/5.6%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/" class="md-nav__link">
        5.6最短路径
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../05-%E5%9B%BE/5.7%E6%9C%89%E5%90%91%E6%97%A0%E7%8E%AF%E5%9B%BE/" class="md-nav__link">
        5.7有向无环图
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../05-%E5%9B%BE/5.8%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/" class="md-nav__link">
        5.8拓扑排序
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../05-%E5%9B%BE/5.9%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/" class="md-nav__link">
        5.9关键路径
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_1_7" type="checkbox" id="__nav_1_7" >
      
      
      
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
      
      
        <label class="md-nav__link" for="__nav_1_7">
          6.查找
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="6.查找" data-md-level="2">
        <label class="md-nav__title" for="__nav_1_7">
          <span class="md-nav__icon md-icon"></span>
          6.查找
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../06-%E6%9F%A5%E6%89%BE/6.1%E6%9F%A5%E6%89%BE/" class="md-nav__link">
        6.1查找
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../06-%E6%9F%A5%E6%89%BE/6.2%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE/" class="md-nav__link">
        6.2顺序查找
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../06-%E6%9F%A5%E6%89%BE/6.3%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE/" class="md-nav__link">
        6.3折半查找
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../06-%E6%9F%A5%E6%89%BE/6.4%E5%88%86%E5%9D%97%E6%9F%A5%E6%89%BE/" class="md-nav__link">
        6.4分块查找
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../06-%E6%9F%A5%E6%89%BE/6.5B%E6%A0%91/" class="md-nav__link">
        6.5B树
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../06-%E6%9F%A5%E6%89%BE/6.6B%2B%E6%A0%91/" class="md-nav__link">
        6.6B+树
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../06-%E6%9F%A5%E6%89%BE/6.7%E6%95%A3%E5%88%97%E6%9F%A5%E6%89%BE%28%E5%93%88%E5%B8%8C%E6%9F%A5%E6%89%BE%29/" class="md-nav__link">
        6.7散列查找(哈希查找)
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_1_8" type="checkbox" id="__nav_1_8" >
      
      
      
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
      
      
        <label class="md-nav__link" for="__nav_1_8">
          7.排序
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="7.排序" data-md-level="2">
        <label class="md-nav__title" for="__nav_1_8">
          <span class="md-nav__icon md-icon"></span>
          7.排序
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../07-%E6%8E%92%E5%BA%8F/7.1%E6%8E%92%E5%BA%8F/" class="md-nav__link">
        7.1排序
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../07-%E6%8E%92%E5%BA%8F/7.2%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%EF%BC%88%E7%A8%B3%E5%AE%9A%EF%BC%89/" class="md-nav__link">
        7.2插入排序（稳定）
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../07-%E6%8E%92%E5%BA%8F/7.3%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%EF%BC%88%E4%B8%8D%E7%A8%B3%E5%AE%9A%EF%BC%89/" class="md-nav__link">
        7.3希尔排序（不稳定）
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../07-%E6%8E%92%E5%BA%8F/7.4%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%EF%BC%88%E7%A8%B3%E5%AE%9A%EF%BC%89/" class="md-nav__link">
        7.4冒泡排序（稳定）
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../07-%E6%8E%92%E5%BA%8F/7.5%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%EF%BC%88%E4%B8%8D%E7%A8%B3%E5%AE%9A%EF%BC%89/" class="md-nav__link">
        7.5快速排序（不稳定）
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../07-%E6%8E%92%E5%BA%8F/7.6%E7%AE%80%E5%8D%95%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%EF%BC%88%E4%B8%8D%E7%A8%B3%E5%AE%9A%EF%BC%89/" class="md-nav__link">
        7.6简单选择排序（不稳定）
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../07-%E6%8E%92%E5%BA%8F/7.7%E5%A0%86%E6%8E%92%E5%BA%8F%EF%BC%88%E4%B8%8D%E7%A8%B3%E5%AE%9A%EF%BC%89/" class="md-nav__link">
        7.7堆排序（不稳定）
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../07-%E6%8E%92%E5%BA%8F/7.8%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%EF%BC%88%E7%A8%B3%E5%AE%9A%EF%BC%89/" class="md-nav__link">
        7.8归并排序（稳定）
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../07-%E6%8E%92%E5%BA%8F/7.9%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F%EF%BC%88%E7%A8%B3%E5%AE%9A%EF%BC%89/" class="md-nav__link">
        7.9基数排序（稳定）
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
    
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" data-md-toggle="toc" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          核心知识点
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        核心知识点
      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#0" class="md-nav__link">
    0. 绪论
  </a>
  
    <nav class="md-nav" aria-label="0. 绪论">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#01" class="md-nav__link">
    0.1 数据结构基本概念
  </a>
  
    <nav class="md-nav" aria-label="0.1 数据结构基本概念">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#011" class="md-nav__link">
    0.1.1 基本概念和术语
  </a>
  
    <nav class="md-nav" aria-label="0.1.1 基本概念和术语">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    数据类型
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    抽象数据类型的定义格式
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#012" class="md-nav__link">
    0.1.2 数据结构三要素
  </a>
  
    <nav class="md-nav" aria-label="0.1.2 数据结构三要素">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_4" class="md-nav__link">
    逻辑结构
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_5" class="md-nav__link">
    存储结构
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_6" class="md-nav__link">
    数据的运算
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#02" class="md-nav__link">
    0.2 算法和算法评价
  </a>
  
    <nav class="md-nav" aria-label="0.2 算法和算法评价">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#021" class="md-nav__link">
    0.2.1 算法的定义、特性和评价标准
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#022" class="md-nav__link">
    0.2.2 算法效率的度量
  </a>
  
    <nav class="md-nav" aria-label="0.2.2 算法效率的度量">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_7" class="md-nav__link">
    算法复杂度分析步骤
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#1" class="md-nav__link">
    1. 线性表
  </a>
  
    <nav class="md-nav" aria-label="1. 线性表">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#11" class="md-nav__link">
    1.1 线性表的定义和基本操作
  </a>
  
    <nav class="md-nav" aria-label="1.1 线性表的定义和基本操作">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_8" class="md-nav__link">
    定义
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_9" class="md-nav__link">
    特点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_10" class="md-nav__link">
    基本操作
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#12" class="md-nav__link">
    1.2线性表的顺序表示
  </a>
  
    <nav class="md-nav" aria-label="1.2线性表的顺序表示">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_11" class="md-nav__link">
    顺序表的定义
  </a>
  
    <nav class="md-nav" aria-label="顺序表的定义">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_12" class="md-nav__link">
    特点
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_13" class="md-nav__link">
    顺序表的实现
  </a>
  
    <nav class="md-nav" aria-label="顺序表的实现">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_14" class="md-nav__link">
    插入
  </a>
  
    <nav class="md-nav" aria-label="插入">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_15" class="md-nav__link">
    插入的时间复杂度：
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_16" class="md-nav__link">
    删除
  </a>
  
    <nav class="md-nav" aria-label="删除">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_17" class="md-nav__link">
    删除的时间复杂度：
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_18" class="md-nav__link">
    查找
  </a>
  
    <nav class="md-nav" aria-label="查找">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_19" class="md-nav__link">
    按位查找
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_20" class="md-nav__link">
    # 按位查找的时间复杂度
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_21" class="md-nav__link">
    按值查找
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_22" class="md-nav__link">
    # 按值查找的时间复杂度
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#13" class="md-nav__link">
    1.3 线性表的链式表示
  </a>
  
    <nav class="md-nav" aria-label="1.3 线性表的链式表示">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_23" class="md-nav__link">
    单链表
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_24" class="md-nav__link">
    单链表的实现
  </a>
  
    <nav class="md-nav" aria-label="单链表的实现">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_25" class="md-nav__link">
    删除
  </a>
  
    <nav class="md-nav" aria-label="删除">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_26" class="md-nav__link">
    按位序删除
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_27" class="md-nav__link">
    # 按位序删除的时间复杂度：
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_28" class="md-nav__link">
    指定结点的删除
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_29" class="md-nav__link">
    查找
  </a>
  
    <nav class="md-nav" aria-label="查找">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_30" class="md-nav__link">
    按位查找
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_31" class="md-nav__link">
    按值查找
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_32" class="md-nav__link">
    求表长
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_33" class="md-nav__link">
    遍历
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_34" class="md-nav__link">
    双链表
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_35" class="md-nav__link">
    循环链表
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_36" class="md-nav__link">
    静态链表
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#2" class="md-nav__link">
    2. 栈和队列
  </a>
  
    <nav class="md-nav" aria-label="2. 栈和队列">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#21" class="md-nav__link">
    2.1 栈
  </a>
  
    <nav class="md-nav" aria-label="2.1 栈">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#211" class="md-nav__link">
    2.1.1 栈的基本概念
  </a>
  
    <nav class="md-nav" aria-label="2.1.1 栈的基本概念">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_37" class="md-nav__link">
    栈的定义
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_38" class="md-nav__link">
    栈的基本操作
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#212" class="md-nav__link">
    2.1.2 栈的顺序存储结构
  </a>
  
    <nav class="md-nav" aria-label="2.1.2 栈的顺序存储结构">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_39" class="md-nav__link">
    顺序栈的实现
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_40" class="md-nav__link">
    共享栈
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#213" class="md-nav__link">
    2.1.3 栈的链式存储结构
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#22" class="md-nav__link">
    2.2 队列
  </a>
  
    <nav class="md-nav" aria-label="2.2 队列">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#221" class="md-nav__link">
    2.2.1 队列的基本概念
  </a>
  
    <nav class="md-nav" aria-label="2.2.1 队列的基本概念">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_41" class="md-nav__link">
    队列的定义
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_42" class="md-nav__link">
    队列常见的基本操作
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#222" class="md-nav__link">
    2.2.2 队列的顺序存储结构
  </a>
  
    <nav class="md-nav" aria-label="2.2.2 队列的顺序存储结构">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_43" class="md-nav__link">
    队列的顺序存储
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_44" class="md-nav__link">
    循环队列
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#223" class="md-nav__link">
    2.2.3 队列的链式存储结构
  </a>
  
    <nav class="md-nav" aria-label="2.2.3 队列的链式存储结构">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_45" class="md-nav__link">
    队列的链式存储
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#224" class="md-nav__link">
    2.2.4 双端队列
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#23" class="md-nav__link">
    2.3 栈和队列的应用
  </a>
  
    <nav class="md-nav" aria-label="2.3 栈和队列的应用">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_46" class="md-nav__link">
    栈在括号匹配中的应用
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_47" class="md-nav__link">
    栈在表达式求值中的应用
  </a>
  
    <nav class="md-nav" aria-label="栈在表达式求值中的应用">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_48" class="md-nav__link">
    后续表达式计算方式
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_49" class="md-nav__link">
    中缀表达式转换为前缀或后缀表达式的手工做法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_50" class="md-nav__link">
    中缀表达式转换为后缀表达式的算法思路
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_51" class="md-nav__link">
    栈在递归中的应用
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_52" class="md-nav__link">
    队列在层次遍历中的应用
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_53" class="md-nav__link">
    队列在计算机系统中的应用
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#24" class="md-nav__link">
    2.4 特殊矩阵的压缩存储
  </a>
  
    <nav class="md-nav" aria-label="2.4 特殊矩阵的压缩存储">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_54" class="md-nav__link">
    数组的定义
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#241" class="md-nav__link">
    2.4.1 数组的存储结构
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#242" class="md-nav__link">
    2.4.2 特殊矩阵的存储
  </a>
  
    <nav class="md-nav" aria-label="2.4.2 特殊矩阵的存储">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_55" class="md-nav__link">
    对称矩阵的压缩存储
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_56" class="md-nav__link">
    三角矩阵的压缩存储
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_57" class="md-nav__link">
    三对角矩阵的压缩存储
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_58" class="md-nav__link">
    稀疏矩阵的压缩存储
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#25" class="md-nav__link">
    2.5 广义表
  </a>
  
    <nav class="md-nav" aria-label="2.5 广义表">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#251" class="md-nav__link">
    2.5.1 定义
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#252" class="md-nav__link">
    2.5.2 广义表的长度
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#253" class="md-nav__link">
    2.5.3 广义表的深度
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#254" class="md-nav__link">
    2.5.4 广义表获取表头和表尾
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#255" class="md-nav__link">
    2.5.5 存储结构
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#256" class="md-nav__link">
    2.5.6 例题
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#3" class="md-nav__link">
    3. 串
  </a>
  
    <nav class="md-nav" aria-label="3. 串">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#31" class="md-nav__link">
    3.1 串的定义和实现
  </a>
  
    <nav class="md-nav" aria-label="3.1 串的定义和实现">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_59" class="md-nav__link">
    串的定义
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_60" class="md-nav__link">
    串的存储结构
  </a>
  
    <nav class="md-nav" aria-label="串的存储结构">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_61" class="md-nav__link">
    定长顺序存储表示
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_62" class="md-nav__link">
    堆分配存储表示
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_63" class="md-nav__link">
    块链存储表示
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_64" class="md-nav__link">
    串的基本操作
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#32" class="md-nav__link">
    3.2 串的模式匹配
  </a>
  
    <nav class="md-nav" aria-label="3.2 串的模式匹配">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#bf" class="md-nav__link">
    简单的模式匹配算法 BF
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#kmp" class="md-nav__link">
    KMP 算法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_65" class="md-nav__link">
    基础概念
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_66" class="md-nav__link">
    算法原理
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#next" class="md-nav__link">
    next[] 推导方法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_67" class="md-nav__link">
    说明
  </a>
  
    <nav class="md-nav" aria-label="说明">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#kmp_1" class="md-nav__link">
    KMP算法的时间复杂度：
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#kmp_2" class="md-nav__link">
    KMP 算法的进一步优化
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#4" class="md-nav__link">
    4. 树
  </a>
  
    <nav class="md-nav" aria-label="4. 树">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#41" class="md-nav__link">
    4.1 树
  </a>
  
    <nav class="md-nav" aria-label="4.1 树">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#411" class="md-nav__link">
    4.1.1 树的定义
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#412" class="md-nav__link">
    4.1.2 基本术语
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#413" class="md-nav__link">
    4.1.3 树的性质
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#42" class="md-nav__link">
    4.2 二叉树
  </a>
  
    <nav class="md-nav" aria-label="4.2 二叉树">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#421" class="md-nav__link">
    4.2.1 二叉树的定义及其主要特性
  </a>
  
    <nav class="md-nav" aria-label="4.2.1 二叉树的定义及其主要特性">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_68" class="md-nav__link">
    定义
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_69" class="md-nav__link">
    几个特殊的二叉树
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_70" class="md-nav__link">
    二叉树的性质
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#422" class="md-nav__link">
    4.2.2 二叉树的存储结构
  </a>
  
    <nav class="md-nav" aria-label="4.2.2 二叉树的存储结构">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_71" class="md-nav__link">
    顺序存储结构
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_72" class="md-nav__link">
    链式存储结构
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#43" class="md-nav__link">
    4.3 二叉树的遍历和线索二叉树
  </a>
  
    <nav class="md-nav" aria-label="4.3 二叉树的遍历和线索二叉树">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#431" class="md-nav__link">
    4.3.1 二叉树的遍历
  </a>
  
    <nav class="md-nav" aria-label="4.3.1 二叉树的遍历">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_73" class="md-nav__link">
    递归遍历算法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_74" class="md-nav__link">
    非递归遍历算法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_75" class="md-nav__link">
    由遍历序列构造二叉树
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#432" class="md-nav__link">
    4.3.2 线索二叉树
  </a>
  
    <nav class="md-nav" aria-label="4.3.2 线索二叉树">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_76" class="md-nav__link">
    线索二叉树的基本概念
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_77" class="md-nav__link">
    中序线索二叉树的构造
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_78" class="md-nav__link">
    中序线索二叉树的遍历
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_79" class="md-nav__link">
    先序线索二叉树和后序线索二叉树
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#44" class="md-nav__link">
    4.4 树、森林
  </a>
  
    <nav class="md-nav" aria-label="4.4 树、森林">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#441" class="md-nav__link">
    4.4.1 树的存储结构
  </a>
  
    <nav class="md-nav" aria-label="4.4.1 树的存储结构">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#4411" class="md-nav__link">
    4.4.1.1 双亲表示法（顺序存储）
  </a>
  
    <nav class="md-nav" aria-label="4.4.1.1 双亲表示法（顺序存储）">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_80" class="md-nav__link">
    类型描述
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_81" class="md-nav__link">
    增加一个结点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_82" class="md-nav__link">
    删除一个结点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_83" class="md-nav__link">
    查找一个结点
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#4412" class="md-nav__link">
    4.4.1.2 孩子表示法（顺序+链式存储）
  </a>
  
    <nav class="md-nav" aria-label="4.4.1.2 孩子表示法（顺序+链式存储）">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_84" class="md-nav__link">
    类型描述
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_85" class="md-nav__link">
    增加一个结点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_86" class="md-nav__link">
    删除一个结点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_87" class="md-nav__link">
    查找一个结点
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#4413" class="md-nav__link">
    4.4.1.3 孩子兄弟表示法（顺序+链式存储）
  </a>
  
    <nav class="md-nav" aria-label="4.4.1.3 孩子兄弟表示法（顺序+链式存储）">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_88" class="md-nav__link">
    类型描述
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#442" class="md-nav__link">
    4.4.2 树、森林与二叉树的转化
  </a>
  
    <nav class="md-nav" aria-label="4.4.2 树、森林与二叉树的转化">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_89" class="md-nav__link">
    树转换为二叉树
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_90" class="md-nav__link">
    森林转换二叉树
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_91" class="md-nav__link">
    二叉树转换为森林
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#443" class="md-nav__link">
    4.4.3 树和森林的遍历
  </a>
  
    <nav class="md-nav" aria-label="4.4.3 树和森林的遍历">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_92" class="md-nav__link">
    树的遍历
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_93" class="md-nav__link">
    森林的遍历
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#45" class="md-nav__link">
    4.5 树与二叉树的应用
  </a>
  
    <nav class="md-nav" aria-label="4.5 树与二叉树的应用">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#451-bst" class="md-nav__link">
    4.5.1 二叉排序树 BST
  </a>
  
    <nav class="md-nav" aria-label="4.5.1 二叉排序树 BST">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_94" class="md-nav__link">
    二叉排序树的定义
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_95" class="md-nav__link">
    二叉排序树的查找、插入、构造
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_96" class="md-nav__link">
    二叉排序树的剔除
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_97" class="md-nav__link">
    二叉排序树的查找效率分析
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#452" class="md-nav__link">
    4.5.2 平衡二叉树
  </a>
  
    <nav class="md-nav" aria-label="4.5.2 平衡二叉树">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_98" class="md-nav__link">
    定义
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_99" class="md-nav__link">
    二叉排序树的插入
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_100" class="md-nav__link">
    平衡二叉树的查找
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#453" class="md-nav__link">
    4.5.3 哈夫曼树和哈夫曼编码
  </a>
  
    <nav class="md-nav" aria-label="4.5.3 哈夫曼树和哈夫曼编码">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_101" class="md-nav__link">
    定义
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_102" class="md-nav__link">
    哈夫曼树的构造
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_103" class="md-nav__link">
    哈夫曼树特点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_104" class="md-nav__link">
    哈夫曼编码
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#5" class="md-nav__link">
    5. 图
  </a>
  
    <nav class="md-nav" aria-label="5. 图">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#51" class="md-nav__link">
    5.1 图的基本概念
  </a>
  
    <nav class="md-nav" aria-label="5.1 图的基本概念">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#511" class="md-nav__link">
    5.1.1 图的定义
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#512" class="md-nav__link">
    5.1.2 基本术语
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#52" class="md-nav__link">
    5.2 图的存储及基本操作
  </a>
  
    <nav class="md-nav" aria-label="5.2 图的存储及基本操作">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#521" class="md-nav__link">
    5.2.1 邻接矩阵法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#522" class="md-nav__link">
    5.2.2 邻接表法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#523" class="md-nav__link">
    5.2.3 十字链表
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#524" class="md-nav__link">
    5.2.4 邻接多重表
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#525" class="md-nav__link">
    5.2.5 图的基本操作
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#53" class="md-nav__link">
    5.3 图的遍历
  </a>
  
    <nav class="md-nav" aria-label="5.3 图的遍历">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#531" class="md-nav__link">
    5.3.1 广度优先算法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#532" class="md-nav__link">
    5.3.2 深度优先搜索
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_105" class="md-nav__link">
    性能
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#54" class="md-nav__link">
    5.4 图的应用
  </a>
  
    <nav class="md-nav" aria-label="5.4 图的应用">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#541" class="md-nav__link">
    5.4.1 最小生成树
  </a>
  
    <nav class="md-nav" aria-label="5.4.1 最小生成树">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#prim" class="md-nav__link">
    Prim 算法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#kruskal" class="md-nav__link">
    Kruskal 算法
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#542" class="md-nav__link">
    5.4.2 最短路径
  </a>
  
    <nav class="md-nav" aria-label="5.4.2 最短路径">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#dijkstra" class="md-nav__link">
    Dijkstra 算法求单源最短路径
  </a>
  
    <nav class="md-nav" aria-label="Dijkstra 算法求单源最短路径">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_106" class="md-nav__link">
    辅助数组
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_107" class="md-nav__link">
    算法步骤
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_108" class="md-nav__link">
    案例：
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#floyd" class="md-nav__link">
    Floyd 算法求个定点之间最短路径
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#543" class="md-nav__link">
    5.4.3 有向无环图描述表达式
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#544" class="md-nav__link">
    5.4.4 拓扑排序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#545" class="md-nav__link">
    5.4.5 关键路径
  </a>
  
    <nav class="md-nav" aria-label="5.4.5 关键路径">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_109" class="md-nav__link">
    计算步骤
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#6" class="md-nav__link">
    6. 查找
  </a>
  
    <nav class="md-nav" aria-label="6. 查找">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#61" class="md-nav__link">
    6.1 查找的概念
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#62" class="md-nav__link">
    6.2 顺序查找和折半查找
  </a>
  
    <nav class="md-nav" aria-label="6.2 顺序查找和折半查找">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#621" class="md-nav__link">
    6.2.1 顺序查找
  </a>
  
    <nav class="md-nav" aria-label="6.2.1 顺序查找">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_110" class="md-nav__link">
    一般线性表的顺序查找
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_111" class="md-nav__link">
    有序表的顺序查找
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#622" class="md-nav__link">
    6.2.2 折半查找
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#623" class="md-nav__link">
    6.2.3 分块查找
  </a>
  
    <nav class="md-nav" aria-label="6.2.3 分块查找">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_112" class="md-nav__link">
    用折半查找索引表：
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_113" class="md-nav__link">
    查找效率分析
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_114" class="md-nav__link">
    分块查找的优化
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#624" class="md-nav__link">
    6.2.4 时间复杂度评价
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#63-b-b" class="md-nav__link">
    6.3 B 树和 B + 树
  </a>
  
    <nav class="md-nav" aria-label="6.3 B 树和 B + 树">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#631-b" class="md-nav__link">
    6.3.1 B 树及其基本操作
  </a>
  
    <nav class="md-nav" aria-label="6.3.1 B 树及其基本操作">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_115" class="md-nav__link">
    定义
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#b" class="md-nav__link">
    B 树的高度
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#b_1" class="md-nav__link">
    B 树的查找
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#b_2" class="md-nav__link">
    B 树的插入
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#b_3" class="md-nav__link">
    B 树的删除
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#632-b" class="md-nav__link">
    6.3.2 B + 树的基本概念
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#633-b-vsb" class="md-nav__link">
    6.3.3 B 树 VSB + 树
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#64" class="md-nav__link">
    6.4 散列表
  </a>
  
    <nav class="md-nav" aria-label="6.4 散列表">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#641" class="md-nav__link">
    6.4.1 散列表的基本概念
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#642" class="md-nav__link">
    6.4.2 散列函数的构造方法
  </a>
  
    <nav class="md-nav" aria-label="6.4.2 散列函数的构造方法">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_116" class="md-nav__link">
    散列函数的要求
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#643" class="md-nav__link">
    6.4.3 处理冲突的方法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#644" class="md-nav__link">
    6.4.4 散列查找及性能分析
  </a>
  
    <nav class="md-nav" aria-label="6.4.4 散列查找及性能分析">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_117" class="md-nav__link">
    查找过程
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#7" class="md-nav__link">
    7. 排序
  </a>
  
    <nav class="md-nav" aria-label="7. 排序">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#71" class="md-nav__link">
    7.1 排序的基本概念
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#72" class="md-nav__link">
    7.2 插入排序
  </a>
  
    <nav class="md-nav" aria-label="7.2 插入排序">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#721" class="md-nav__link">
    7.2.1 直接插入排序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#722" class="md-nav__link">
    7.2.2 折半插入排序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#723" class="md-nav__link">
    7.2.3 希尔排序
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#73" class="md-nav__link">
    7.3 交换排序
  </a>
  
    <nav class="md-nav" aria-label="7.3 交换排序">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#731" class="md-nav__link">
    7.3.1 冒泡排序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#732" class="md-nav__link">
    7.3.2 快速排序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#74" class="md-nav__link">
    7.4 选择排序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#741" class="md-nav__link">
    7.4.1 简单选择排序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#742" class="md-nav__link">
    7.4.2 堆排序
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#75" class="md-nav__link">
    7.5 归并排序和基数排序
  </a>
  
    <nav class="md-nav" aria-label="7.5 归并排序和基数排序">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#751" class="md-nav__link">
    7.5.1 归并排序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#752" class="md-nav__link">
    7.5.2 基数排序
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#76" class="md-nav__link">
    7.6 各种内部排序算法比较及应用
  </a>
  
    <nav class="md-nav" aria-label="7.6 各种内部排序算法比较及应用">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#761" class="md-nav__link">
    7.6.1 内部排序算法的比较
  </a>
  
    <nav class="md-nav" aria-label="7.6.1 内部排序算法的比较">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_118" class="md-nav__link">
    选取排序方法需要考虑的因素
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#77" class="md-nav__link">
    7.7 外部排序
  </a>
  
    <nav class="md-nav" aria-label="7.7 外部排序">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#771" class="md-nav__link">
    7.7.1 外部排序的基本概念
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#772" class="md-nav__link">
    7.7.2 外部排序的方法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#773" class="md-nav__link">
    7.7.3 多路平衡归并与败者树
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#774-" class="md-nav__link">
    7.7.4 置换 - 选择排序（生成初始归并段）
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#775" class="md-nav__link">
    7.7.5 最佳归并树
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../question/" class="md-nav__link">
        核心考点
      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#0" class="md-nav__link">
    0. 绪论
  </a>
  
    <nav class="md-nav" aria-label="0. 绪论">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#01" class="md-nav__link">
    0.1 数据结构基本概念
  </a>
  
    <nav class="md-nav" aria-label="0.1 数据结构基本概念">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#011" class="md-nav__link">
    0.1.1 基本概念和术语
  </a>
  
    <nav class="md-nav" aria-label="0.1.1 基本概念和术语">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    数据类型
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    抽象数据类型的定义格式
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#012" class="md-nav__link">
    0.1.2 数据结构三要素
  </a>
  
    <nav class="md-nav" aria-label="0.1.2 数据结构三要素">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_4" class="md-nav__link">
    逻辑结构
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_5" class="md-nav__link">
    存储结构
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_6" class="md-nav__link">
    数据的运算
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#02" class="md-nav__link">
    0.2 算法和算法评价
  </a>
  
    <nav class="md-nav" aria-label="0.2 算法和算法评价">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#021" class="md-nav__link">
    0.2.1 算法的定义、特性和评价标准
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#022" class="md-nav__link">
    0.2.2 算法效率的度量
  </a>
  
    <nav class="md-nav" aria-label="0.2.2 算法效率的度量">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_7" class="md-nav__link">
    算法复杂度分析步骤
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#1" class="md-nav__link">
    1. 线性表
  </a>
  
    <nav class="md-nav" aria-label="1. 线性表">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#11" class="md-nav__link">
    1.1 线性表的定义和基本操作
  </a>
  
    <nav class="md-nav" aria-label="1.1 线性表的定义和基本操作">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_8" class="md-nav__link">
    定义
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_9" class="md-nav__link">
    特点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_10" class="md-nav__link">
    基本操作
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#12" class="md-nav__link">
    1.2线性表的顺序表示
  </a>
  
    <nav class="md-nav" aria-label="1.2线性表的顺序表示">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_11" class="md-nav__link">
    顺序表的定义
  </a>
  
    <nav class="md-nav" aria-label="顺序表的定义">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_12" class="md-nav__link">
    特点
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_13" class="md-nav__link">
    顺序表的实现
  </a>
  
    <nav class="md-nav" aria-label="顺序表的实现">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_14" class="md-nav__link">
    插入
  </a>
  
    <nav class="md-nav" aria-label="插入">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_15" class="md-nav__link">
    插入的时间复杂度：
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_16" class="md-nav__link">
    删除
  </a>
  
    <nav class="md-nav" aria-label="删除">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_17" class="md-nav__link">
    删除的时间复杂度：
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_18" class="md-nav__link">
    查找
  </a>
  
    <nav class="md-nav" aria-label="查找">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_19" class="md-nav__link">
    按位查找
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_20" class="md-nav__link">
    # 按位查找的时间复杂度
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_21" class="md-nav__link">
    按值查找
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_22" class="md-nav__link">
    # 按值查找的时间复杂度
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#13" class="md-nav__link">
    1.3 线性表的链式表示
  </a>
  
    <nav class="md-nav" aria-label="1.3 线性表的链式表示">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_23" class="md-nav__link">
    单链表
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_24" class="md-nav__link">
    单链表的实现
  </a>
  
    <nav class="md-nav" aria-label="单链表的实现">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_25" class="md-nav__link">
    删除
  </a>
  
    <nav class="md-nav" aria-label="删除">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_26" class="md-nav__link">
    按位序删除
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_27" class="md-nav__link">
    # 按位序删除的时间复杂度：
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_28" class="md-nav__link">
    指定结点的删除
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_29" class="md-nav__link">
    查找
  </a>
  
    <nav class="md-nav" aria-label="查找">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_30" class="md-nav__link">
    按位查找
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_31" class="md-nav__link">
    按值查找
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_32" class="md-nav__link">
    求表长
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_33" class="md-nav__link">
    遍历
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_34" class="md-nav__link">
    双链表
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_35" class="md-nav__link">
    循环链表
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_36" class="md-nav__link">
    静态链表
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#2" class="md-nav__link">
    2. 栈和队列
  </a>
  
    <nav class="md-nav" aria-label="2. 栈和队列">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#21" class="md-nav__link">
    2.1 栈
  </a>
  
    <nav class="md-nav" aria-label="2.1 栈">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#211" class="md-nav__link">
    2.1.1 栈的基本概念
  </a>
  
    <nav class="md-nav" aria-label="2.1.1 栈的基本概念">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_37" class="md-nav__link">
    栈的定义
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_38" class="md-nav__link">
    栈的基本操作
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#212" class="md-nav__link">
    2.1.2 栈的顺序存储结构
  </a>
  
    <nav class="md-nav" aria-label="2.1.2 栈的顺序存储结构">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_39" class="md-nav__link">
    顺序栈的实现
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_40" class="md-nav__link">
    共享栈
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#213" class="md-nav__link">
    2.1.3 栈的链式存储结构
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#22" class="md-nav__link">
    2.2 队列
  </a>
  
    <nav class="md-nav" aria-label="2.2 队列">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#221" class="md-nav__link">
    2.2.1 队列的基本概念
  </a>
  
    <nav class="md-nav" aria-label="2.2.1 队列的基本概念">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_41" class="md-nav__link">
    队列的定义
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_42" class="md-nav__link">
    队列常见的基本操作
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#222" class="md-nav__link">
    2.2.2 队列的顺序存储结构
  </a>
  
    <nav class="md-nav" aria-label="2.2.2 队列的顺序存储结构">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_43" class="md-nav__link">
    队列的顺序存储
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_44" class="md-nav__link">
    循环队列
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#223" class="md-nav__link">
    2.2.3 队列的链式存储结构
  </a>
  
    <nav class="md-nav" aria-label="2.2.3 队列的链式存储结构">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_45" class="md-nav__link">
    队列的链式存储
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#224" class="md-nav__link">
    2.2.4 双端队列
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#23" class="md-nav__link">
    2.3 栈和队列的应用
  </a>
  
    <nav class="md-nav" aria-label="2.3 栈和队列的应用">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_46" class="md-nav__link">
    栈在括号匹配中的应用
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_47" class="md-nav__link">
    栈在表达式求值中的应用
  </a>
  
    <nav class="md-nav" aria-label="栈在表达式求值中的应用">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_48" class="md-nav__link">
    后续表达式计算方式
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_49" class="md-nav__link">
    中缀表达式转换为前缀或后缀表达式的手工做法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_50" class="md-nav__link">
    中缀表达式转换为后缀表达式的算法思路
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_51" class="md-nav__link">
    栈在递归中的应用
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_52" class="md-nav__link">
    队列在层次遍历中的应用
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_53" class="md-nav__link">
    队列在计算机系统中的应用
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#24" class="md-nav__link">
    2.4 特殊矩阵的压缩存储
  </a>
  
    <nav class="md-nav" aria-label="2.4 特殊矩阵的压缩存储">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_54" class="md-nav__link">
    数组的定义
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#241" class="md-nav__link">
    2.4.1 数组的存储结构
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#242" class="md-nav__link">
    2.4.2 特殊矩阵的存储
  </a>
  
    <nav class="md-nav" aria-label="2.4.2 特殊矩阵的存储">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_55" class="md-nav__link">
    对称矩阵的压缩存储
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_56" class="md-nav__link">
    三角矩阵的压缩存储
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_57" class="md-nav__link">
    三对角矩阵的压缩存储
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_58" class="md-nav__link">
    稀疏矩阵的压缩存储
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#25" class="md-nav__link">
    2.5 广义表
  </a>
  
    <nav class="md-nav" aria-label="2.5 广义表">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#251" class="md-nav__link">
    2.5.1 定义
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#252" class="md-nav__link">
    2.5.2 广义表的长度
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#253" class="md-nav__link">
    2.5.3 广义表的深度
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#254" class="md-nav__link">
    2.5.4 广义表获取表头和表尾
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#255" class="md-nav__link">
    2.5.5 存储结构
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#256" class="md-nav__link">
    2.5.6 例题
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#3" class="md-nav__link">
    3. 串
  </a>
  
    <nav class="md-nav" aria-label="3. 串">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#31" class="md-nav__link">
    3.1 串的定义和实现
  </a>
  
    <nav class="md-nav" aria-label="3.1 串的定义和实现">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_59" class="md-nav__link">
    串的定义
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_60" class="md-nav__link">
    串的存储结构
  </a>
  
    <nav class="md-nav" aria-label="串的存储结构">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_61" class="md-nav__link">
    定长顺序存储表示
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_62" class="md-nav__link">
    堆分配存储表示
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_63" class="md-nav__link">
    块链存储表示
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_64" class="md-nav__link">
    串的基本操作
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#32" class="md-nav__link">
    3.2 串的模式匹配
  </a>
  
    <nav class="md-nav" aria-label="3.2 串的模式匹配">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#bf" class="md-nav__link">
    简单的模式匹配算法 BF
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#kmp" class="md-nav__link">
    KMP 算法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_65" class="md-nav__link">
    基础概念
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_66" class="md-nav__link">
    算法原理
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#next" class="md-nav__link">
    next[] 推导方法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_67" class="md-nav__link">
    说明
  </a>
  
    <nav class="md-nav" aria-label="说明">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#kmp_1" class="md-nav__link">
    KMP算法的时间复杂度：
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#kmp_2" class="md-nav__link">
    KMP 算法的进一步优化
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#4" class="md-nav__link">
    4. 树
  </a>
  
    <nav class="md-nav" aria-label="4. 树">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#41" class="md-nav__link">
    4.1 树
  </a>
  
    <nav class="md-nav" aria-label="4.1 树">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#411" class="md-nav__link">
    4.1.1 树的定义
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#412" class="md-nav__link">
    4.1.2 基本术语
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#413" class="md-nav__link">
    4.1.3 树的性质
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#42" class="md-nav__link">
    4.2 二叉树
  </a>
  
    <nav class="md-nav" aria-label="4.2 二叉树">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#421" class="md-nav__link">
    4.2.1 二叉树的定义及其主要特性
  </a>
  
    <nav class="md-nav" aria-label="4.2.1 二叉树的定义及其主要特性">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_68" class="md-nav__link">
    定义
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_69" class="md-nav__link">
    几个特殊的二叉树
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_70" class="md-nav__link">
    二叉树的性质
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#422" class="md-nav__link">
    4.2.2 二叉树的存储结构
  </a>
  
    <nav class="md-nav" aria-label="4.2.2 二叉树的存储结构">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_71" class="md-nav__link">
    顺序存储结构
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_72" class="md-nav__link">
    链式存储结构
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#43" class="md-nav__link">
    4.3 二叉树的遍历和线索二叉树
  </a>
  
    <nav class="md-nav" aria-label="4.3 二叉树的遍历和线索二叉树">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#431" class="md-nav__link">
    4.3.1 二叉树的遍历
  </a>
  
    <nav class="md-nav" aria-label="4.3.1 二叉树的遍历">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_73" class="md-nav__link">
    递归遍历算法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_74" class="md-nav__link">
    非递归遍历算法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_75" class="md-nav__link">
    由遍历序列构造二叉树
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#432" class="md-nav__link">
    4.3.2 线索二叉树
  </a>
  
    <nav class="md-nav" aria-label="4.3.2 线索二叉树">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_76" class="md-nav__link">
    线索二叉树的基本概念
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_77" class="md-nav__link">
    中序线索二叉树的构造
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_78" class="md-nav__link">
    中序线索二叉树的遍历
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_79" class="md-nav__link">
    先序线索二叉树和后序线索二叉树
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#44" class="md-nav__link">
    4.4 树、森林
  </a>
  
    <nav class="md-nav" aria-label="4.4 树、森林">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#441" class="md-nav__link">
    4.4.1 树的存储结构
  </a>
  
    <nav class="md-nav" aria-label="4.4.1 树的存储结构">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#4411" class="md-nav__link">
    4.4.1.1 双亲表示法（顺序存储）
  </a>
  
    <nav class="md-nav" aria-label="4.4.1.1 双亲表示法（顺序存储）">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_80" class="md-nav__link">
    类型描述
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_81" class="md-nav__link">
    增加一个结点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_82" class="md-nav__link">
    删除一个结点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_83" class="md-nav__link">
    查找一个结点
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#4412" class="md-nav__link">
    4.4.1.2 孩子表示法（顺序+链式存储）
  </a>
  
    <nav class="md-nav" aria-label="4.4.1.2 孩子表示法（顺序+链式存储）">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_84" class="md-nav__link">
    类型描述
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_85" class="md-nav__link">
    增加一个结点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_86" class="md-nav__link">
    删除一个结点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_87" class="md-nav__link">
    查找一个结点
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#4413" class="md-nav__link">
    4.4.1.3 孩子兄弟表示法（顺序+链式存储）
  </a>
  
    <nav class="md-nav" aria-label="4.4.1.3 孩子兄弟表示法（顺序+链式存储）">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_88" class="md-nav__link">
    类型描述
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#442" class="md-nav__link">
    4.4.2 树、森林与二叉树的转化
  </a>
  
    <nav class="md-nav" aria-label="4.4.2 树、森林与二叉树的转化">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_89" class="md-nav__link">
    树转换为二叉树
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_90" class="md-nav__link">
    森林转换二叉树
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_91" class="md-nav__link">
    二叉树转换为森林
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#443" class="md-nav__link">
    4.4.3 树和森林的遍历
  </a>
  
    <nav class="md-nav" aria-label="4.4.3 树和森林的遍历">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_92" class="md-nav__link">
    树的遍历
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_93" class="md-nav__link">
    森林的遍历
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#45" class="md-nav__link">
    4.5 树与二叉树的应用
  </a>
  
    <nav class="md-nav" aria-label="4.5 树与二叉树的应用">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#451-bst" class="md-nav__link">
    4.5.1 二叉排序树 BST
  </a>
  
    <nav class="md-nav" aria-label="4.5.1 二叉排序树 BST">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_94" class="md-nav__link">
    二叉排序树的定义
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_95" class="md-nav__link">
    二叉排序树的查找、插入、构造
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_96" class="md-nav__link">
    二叉排序树的剔除
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_97" class="md-nav__link">
    二叉排序树的查找效率分析
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#452" class="md-nav__link">
    4.5.2 平衡二叉树
  </a>
  
    <nav class="md-nav" aria-label="4.5.2 平衡二叉树">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_98" class="md-nav__link">
    定义
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_99" class="md-nav__link">
    二叉排序树的插入
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_100" class="md-nav__link">
    平衡二叉树的查找
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#453" class="md-nav__link">
    4.5.3 哈夫曼树和哈夫曼编码
  </a>
  
    <nav class="md-nav" aria-label="4.5.3 哈夫曼树和哈夫曼编码">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_101" class="md-nav__link">
    定义
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_102" class="md-nav__link">
    哈夫曼树的构造
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_103" class="md-nav__link">
    哈夫曼树特点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_104" class="md-nav__link">
    哈夫曼编码
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#5" class="md-nav__link">
    5. 图
  </a>
  
    <nav class="md-nav" aria-label="5. 图">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#51" class="md-nav__link">
    5.1 图的基本概念
  </a>
  
    <nav class="md-nav" aria-label="5.1 图的基本概念">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#511" class="md-nav__link">
    5.1.1 图的定义
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#512" class="md-nav__link">
    5.1.2 基本术语
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#52" class="md-nav__link">
    5.2 图的存储及基本操作
  </a>
  
    <nav class="md-nav" aria-label="5.2 图的存储及基本操作">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#521" class="md-nav__link">
    5.2.1 邻接矩阵法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#522" class="md-nav__link">
    5.2.2 邻接表法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#523" class="md-nav__link">
    5.2.3 十字链表
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#524" class="md-nav__link">
    5.2.4 邻接多重表
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#525" class="md-nav__link">
    5.2.5 图的基本操作
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#53" class="md-nav__link">
    5.3 图的遍历
  </a>
  
    <nav class="md-nav" aria-label="5.3 图的遍历">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#531" class="md-nav__link">
    5.3.1 广度优先算法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#532" class="md-nav__link">
    5.3.2 深度优先搜索
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_105" class="md-nav__link">
    性能
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#54" class="md-nav__link">
    5.4 图的应用
  </a>
  
    <nav class="md-nav" aria-label="5.4 图的应用">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#541" class="md-nav__link">
    5.4.1 最小生成树
  </a>
  
    <nav class="md-nav" aria-label="5.4.1 最小生成树">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#prim" class="md-nav__link">
    Prim 算法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#kruskal" class="md-nav__link">
    Kruskal 算法
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#542" class="md-nav__link">
    5.4.2 最短路径
  </a>
  
    <nav class="md-nav" aria-label="5.4.2 最短路径">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#dijkstra" class="md-nav__link">
    Dijkstra 算法求单源最短路径
  </a>
  
    <nav class="md-nav" aria-label="Dijkstra 算法求单源最短路径">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_106" class="md-nav__link">
    辅助数组
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_107" class="md-nav__link">
    算法步骤
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_108" class="md-nav__link">
    案例：
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#floyd" class="md-nav__link">
    Floyd 算法求个定点之间最短路径
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#543" class="md-nav__link">
    5.4.3 有向无环图描述表达式
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#544" class="md-nav__link">
    5.4.4 拓扑排序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#545" class="md-nav__link">
    5.4.5 关键路径
  </a>
  
    <nav class="md-nav" aria-label="5.4.5 关键路径">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_109" class="md-nav__link">
    计算步骤
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#6" class="md-nav__link">
    6. 查找
  </a>
  
    <nav class="md-nav" aria-label="6. 查找">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#61" class="md-nav__link">
    6.1 查找的概念
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#62" class="md-nav__link">
    6.2 顺序查找和折半查找
  </a>
  
    <nav class="md-nav" aria-label="6.2 顺序查找和折半查找">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#621" class="md-nav__link">
    6.2.1 顺序查找
  </a>
  
    <nav class="md-nav" aria-label="6.2.1 顺序查找">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_110" class="md-nav__link">
    一般线性表的顺序查找
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_111" class="md-nav__link">
    有序表的顺序查找
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#622" class="md-nav__link">
    6.2.2 折半查找
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#623" class="md-nav__link">
    6.2.3 分块查找
  </a>
  
    <nav class="md-nav" aria-label="6.2.3 分块查找">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_112" class="md-nav__link">
    用折半查找索引表：
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_113" class="md-nav__link">
    查找效率分析
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_114" class="md-nav__link">
    分块查找的优化
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#624" class="md-nav__link">
    6.2.4 时间复杂度评价
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#63-b-b" class="md-nav__link">
    6.3 B 树和 B + 树
  </a>
  
    <nav class="md-nav" aria-label="6.3 B 树和 B + 树">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#631-b" class="md-nav__link">
    6.3.1 B 树及其基本操作
  </a>
  
    <nav class="md-nav" aria-label="6.3.1 B 树及其基本操作">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_115" class="md-nav__link">
    定义
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#b" class="md-nav__link">
    B 树的高度
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#b_1" class="md-nav__link">
    B 树的查找
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#b_2" class="md-nav__link">
    B 树的插入
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#b_3" class="md-nav__link">
    B 树的删除
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#632-b" class="md-nav__link">
    6.3.2 B + 树的基本概念
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#633-b-vsb" class="md-nav__link">
    6.3.3 B 树 VSB + 树
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#64" class="md-nav__link">
    6.4 散列表
  </a>
  
    <nav class="md-nav" aria-label="6.4 散列表">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#641" class="md-nav__link">
    6.4.1 散列表的基本概念
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#642" class="md-nav__link">
    6.4.2 散列函数的构造方法
  </a>
  
    <nav class="md-nav" aria-label="6.4.2 散列函数的构造方法">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_116" class="md-nav__link">
    散列函数的要求
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#643" class="md-nav__link">
    6.4.3 处理冲突的方法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#644" class="md-nav__link">
    6.4.4 散列查找及性能分析
  </a>
  
    <nav class="md-nav" aria-label="6.4.4 散列查找及性能分析">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_117" class="md-nav__link">
    查找过程
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#7" class="md-nav__link">
    7. 排序
  </a>
  
    <nav class="md-nav" aria-label="7. 排序">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#71" class="md-nav__link">
    7.1 排序的基本概念
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#72" class="md-nav__link">
    7.2 插入排序
  </a>
  
    <nav class="md-nav" aria-label="7.2 插入排序">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#721" class="md-nav__link">
    7.2.1 直接插入排序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#722" class="md-nav__link">
    7.2.2 折半插入排序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#723" class="md-nav__link">
    7.2.3 希尔排序
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#73" class="md-nav__link">
    7.3 交换排序
  </a>
  
    <nav class="md-nav" aria-label="7.3 交换排序">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#731" class="md-nav__link">
    7.3.1 冒泡排序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#732" class="md-nav__link">
    7.3.2 快速排序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#74" class="md-nav__link">
    7.4 选择排序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#741" class="md-nav__link">
    7.4.1 简单选择排序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#742" class="md-nav__link">
    7.4.2 堆排序
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#75" class="md-nav__link">
    7.5 归并排序和基数排序
  </a>
  
    <nav class="md-nav" aria-label="7.5 归并排序和基数排序">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#751" class="md-nav__link">
    7.5.1 归并排序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#752" class="md-nav__link">
    7.5.2 基数排序
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#76" class="md-nav__link">
    7.6 各种内部排序算法比较及应用
  </a>
  
    <nav class="md-nav" aria-label="7.6 各种内部排序算法比较及应用">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#761" class="md-nav__link">
    7.6.1 内部排序算法的比较
  </a>
  
    <nav class="md-nav" aria-label="7.6.1 内部排序算法的比较">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_118" class="md-nav__link">
    选取排序方法需要考虑的因素
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#77" class="md-nav__link">
    7.7 外部排序
  </a>
  
    <nav class="md-nav" aria-label="7.7 外部排序">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#771" class="md-nav__link">
    7.7.1 外部排序的基本概念
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#772" class="md-nav__link">
    7.7.2 外部排序的方法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#773" class="md-nav__link">
    7.7.3 多路平衡归并与败者树
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#774-" class="md-nav__link">
    7.7.4 置换 - 选择排序（生成初始归并段）
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#775" class="md-nav__link">
    7.7.5 最佳归并树
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content" data-md-component="content">
            <article class="md-content__inner md-typeset">
              
                


<h1 id="_1">数据结构关键知识点<a class="headerlink" href="#_1" title="Permanent link">&para;</a></h1>
<h2 id="0">0. 绪论<a class="headerlink" href="#0" title="Permanent link">&para;</a></h2>
<h3 id="01">0.1 数据结构基本概念<a class="headerlink" href="#01" title="Permanent link">&para;</a></h3>
<h4 id="011">0.1.1 基本概念和术语<a class="headerlink" href="#011" title="Permanent link">&para;</a></h4>
<table>
<thead>
<tr>
<th>术语</th>
<th>定义</th>
</tr>
</thead>
<tbody>
<tr>
<td>数据</td>
<td>数据是信息的载体，是描述客观事物属性的数、字符及所有能输入到计算机中并被计算机程序识别和处理的符号的集合</td>
</tr>
<tr>
<td>数据元素</td>
<td>数据元素是数据的基本单位，通常作为一个整体进行考虑和处理，含有多个数据项</td>
</tr>
<tr>
<td>数据项</td>
<td>是构成数据元素的不可分割的最小单位</td>
</tr>
<tr>
<td>数据对象</td>
<td>具有相同性质的数据元素的集合，是数据的一个子集</td>
</tr>
<tr>
<td>数据类型</td>
<td 原子类型、结构类型、抽象数据类型="原子类型、结构类型、抽象数据类型">一个值的集合和定义在此集合上的一组操作的总称</td>
</tr>
<tr>
<td>数据结构</td>
<td>相互之间存在一种或多种特定关系的数据元素的集合</td>
</tr>
</tbody>
</table>
<h5 id="_2">数据类型<a class="headerlink" href="#_2" title="Permanent link">&para;</a></h5>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>定义</th>
</tr>
</thead>
<tbody>
<tr>
<td>原子类型</td>
<td>其值不可再分的数据类型</td>
</tr>
<tr>
<td>结构类型</td>
<td>其值可以再分解为若干成分的数据类型</td>
</tr>
<tr>
<td>抽象数据类型 ADT</td>
<td>抽象数据组织及与之相关的操作</td>
</tr>
</tbody>
</table>
<h5 id="_3">抽象数据类型的定义格式<a class="headerlink" href="#_3" title="Permanent link">&para;</a></h5>
<div class="highlight"><pre><span></span><code><a id="__codelineno-0-1" name="__codelineno-0-1" href="#__codelineno-0-1"></a><span class="n">ADT</span><span class="w"> </span><span class="n">抽象数据类型名</span><span class="p">{</span><span class="c1">//抽象数据类型定义格式</span>
<a id="__codelineno-0-2" name="__codelineno-0-2" href="#__codelineno-0-2"></a><span class="w">    </span><span class="nl">数据对象</span><span class="p">:</span><span class="o">&lt;</span><span class="n">数据对象的定义</span><span class="o">&gt;</span><span class="w">      </span><span class="c1">//自然语言</span>
<a id="__codelineno-0-3" name="__codelineno-0-3" href="#__codelineno-0-3"></a><span class="w">    </span><span class="nl">数据关系</span><span class="p">:</span><span class="o">&lt;</span><span class="n">数据关系的定义</span><span class="o">&gt;</span><span class="w">      </span><span class="c1">//自然语言</span>
<a id="__codelineno-0-4" name="__codelineno-0-4" href="#__codelineno-0-4"></a><span class="w">    </span><span class="nl">基本操作</span><span class="p">:</span><span class="o">&lt;</span><span class="n">基本操作的定义</span><span class="o">&gt;</span><span class="w"></span>
<a id="__codelineno-0-5" name="__codelineno-0-5" href="#__codelineno-0-5"></a><span class="p">}</span><span class="n">ADT</span><span class="w"> </span><span class="n">抽象数据类型名</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-0-6" name="__codelineno-0-6" href="#__codelineno-0-6"></a>
<a id="__codelineno-0-7" name="__codelineno-0-7" href="#__codelineno-0-7"></a><span class="c1">//基本操作的定义格式</span>
<a id="__codelineno-0-8" name="__codelineno-0-8" href="#__codelineno-0-8"></a><span class="n">基本操作名</span><span class="p">(</span><span class="n">参数表</span><span class="p">)</span><span class="w">  </span><span class="c1">//参数表中赋值参数只提供输入值，引用参数以&amp;打头，可提供输入值和返回操作结果</span>
<a id="__codelineno-0-9" name="__codelineno-0-9" href="#__codelineno-0-9"></a><span class="w">    </span><span class="nl">初始条件</span><span class="p">:</span><span class="o">&lt;</span><span class="n">初始条件描述</span><span class="o">&gt;</span><span class="w"></span>
<a id="__codelineno-0-10" name="__codelineno-0-10" href="#__codelineno-0-10"></a><span class="w">    </span><span class="nl">操作结果</span><span class="p">:</span><span class="o">&lt;</span><span class="n">操作结果描述</span><span class="o">&gt;</span><span class="w"></span>
</code></pre></div>
<h4 id="012">0.1.2 数据结构三要素<a class="headerlink" href="#012" title="Permanent link">&para;</a></h4>
<h5 id="_4">逻辑结构<a class="headerlink" href="#_4" title="Permanent link">&para;</a></h5>
<p>定义：逻辑结构是指数据元素之间的逻辑关系，即从逻辑关系上描述数据。</p>
<p>分类：</p>
<ul>
<li>线性结构：一般线性表、受限线性表（栈和队列）、线性表推广（数组）</li>
<li>非线性结构：集合结构、树结构、图结构</li>
</ul>
<h5 id="_5">存储结构<a class="headerlink" href="#_5" title="Permanent link">&para;</a></h5>
<p>定义：存储结构是指数据结构在计算机中的表示，也称物理结构</p>
<p>分类：</p>
<table>
<thead>
<tr>
<th>存储结构</th>
<th>定义</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>顺序存储</td>
<td>把逻辑上相邻的元素存储在物理位置上也相邻的存储单元中，元素之间的关系由存储单元的邻接关系来体现</td>
<td>随机存取，占用空间少</td>
<td>使用一整块相邻的存储单元，产生较多碎片</td>
</tr>
<tr>
<td>链式存储</td>
<td>不要求逻辑上相邻的元素在物理位置上也相邻，借助指示元素存储地址的指针来表示元素之间的逻辑关系</td>
<td>不会出现碎片，充分利用所有存储单元</td>
<td>需要额外空间，只能顺序存取</td>
</tr>
<tr>
<td>索引存储</td>
<td>在存储元素信息的同时，还建立附加的索引表。</td>
<td>检索速度快</td>
<td>附加的索引表需要额外空间。增删数据修改索引表时花费时间</td>
</tr>
<tr>
<td>散列存储</td>
<td>根据元素的关键字直接计算出该元素的存储地址，又称哈希(Hash)存储。</td>
<td>检索、增加和删除结点的操作很快</td>
<td>可能出现元素存储单元的冲突，解决冲突会增加时间和空间开销</td>
</tr>
</tbody>
</table>
<h5 id="_6">数据的运算<a class="headerlink" href="#_6" title="Permanent link">&para;</a></h5>
<p>定义：施加在数据上的运算包括运算的定义和实现。</p>
<ul>
<li>定义是针对逻辑结构的，指出运算的功能；</li>
<li>运算的实现是针对存储结构的，指出运算的具体操作步骤。</li>
</ul>
<h3 id="02">0.2 算法和算法评价<a class="headerlink" href="#02" title="Permanent link">&para;</a></h3>
<h4 id="021">0.2.1 算法的定义、特性和评价标准<a class="headerlink" href="#021" title="Permanent link">&para;</a></h4>
<p>定义：算法是针对特定问题求解步骤的一种描述，它是指令的有限序列，其中的每条指令表示一个或多个操作。</p>
<p>特性：</p>
<ul>
<li>输入，零个或多个</li>
<li>输出，一个或多个</li>
<li>确定性，每条指令含义确定，相同的输入得出相同的结果</li>
<li>有穷性</li>
<li>可行性，所有操作可以通过已经实现的基础运算操作有限次来实现</li>
</ul>
<p>评价标准:</p>
<ul>
<li>正确性：正确结果</li>
<li>可读性</li>
<li>健壮性：输入数据非法时，能够适当的作出反应或相应处理，不会产生莫名其妙的输出结果</li>
<li>高效性：时间和空间</li>
</ul>
<h4 id="022">0.2.2 算法效率的度量<a class="headerlink" href="#022" title="Permanent link">&para;</a></h4>
<ul>
<li>
<p>算法效率分为时间效率和空间效率</p>
</li>
<li>
<p>时间复杂度定义: <span class="arithmatex">\(T(n)=O(f(n)\)</span></p>
</li>
<li>
<p>空间复杂度定义: <span class="arithmatex">\(S(n)=O(g(n))\)</span></p>
</li>
<li>
<p>函数渐近的界<span class="arithmatex">\(O(g(n))\)</span>,存在正数<span class="arithmatex">\(c\)</span>和<span class="arithmatex">\(n_0\)</span>使得对于一切<span class="arithmatex">\(n\geq n_0, 0\leq f(n)\leq cg(n)\)</span></p>
</li>
</ul>
<p>注意：</p>
<ul>
<li>原地工作的算法的空间复杂度为O(1);</li>
<li>算法的时间复杂度不仅仅依赖于数据的规模，也取决于待输入数据的性质，如数据的初始状态；</li>
</ul>
<h5 id="_7">算法复杂度分析步骤<a class="headerlink" href="#_7" title="Permanent link">&para;</a></h5>
<ul>
<li>确定表示输入规模的参数</li>
<li>找出算法的基本操作</li>
<li>检查基本操作的执行次数是否只依赖于输入规模。这决定是否需要考虑最差、平均以及最优情况下的复杂性</li>
<li>对于非递归算法，建立算法基本操作执行次数的求和表达式；</li>
<li>对于递归算法，建立算法基本操作执行次数的递推关系及其初始条件，利用求和公式和法则建立一个操作次数的闭合公式，或者求解递推公式，确定增长的阶</li>
</ul>
<p>加法法则：</p>
<div class="arithmatex">\[T(n)=T_1(n)+T_2(n)=O(f(n))+O(g(n))=O(max(f(n),g(n)))\]</div>
<p>乘法法则：</p>
<div class="arithmatex">\[T(n)=T_1(n)\times T_2(n)=O(f(n))\times O(g(n))=O(f(n))\times O(g(n))\]</div>
<p>常见的复杂度：</p>
<div class="arithmatex">\[O(1) \leq O(log_2n)\leq O(n) \leq O(n log_2n) \leq O(n^2)\]</div>
<div class="arithmatex">\[\leq O(n^3) \leq O(2^n) \leq O(n!) \leq O(n^n)\]</div>
<p>两类递归算法问题的复杂度求解：</p>
<ul>
<li>线性分解</li>
</ul>
<div class="arithmatex">\[T(n)=\begin{cases} O(1) &amp; n=1\\ aT(n-1)+f(n)&amp; n&gt;1 \end{cases}\]</div>
<div class="arithmatex">\[T (n) = a^{n-1}T(1)+\sum_{i=2}^n a^{n-i}f(i)\]</div>
<ul>
<li>指数分解</li>
</ul>
<div class="arithmatex">\[T(n)=\begin{cases} O(1) &amp; n=1\\ aT(\frac nb)+f(n)&amp; n&gt;1 \end{cases}\]</div>
<div class="arithmatex">\[T(n)=n^{log_b a}T(1)+\sum_{j=0}^{log_b n-1}a^jf(\frac n{b^j})\]</div>
<h2 id="1">1. 线性表<a class="headerlink" href="#1" title="Permanent link">&para;</a></h2>
<h3 id="11">1.1 线性表的定义和基本操作<a class="headerlink" href="#11" title="Permanent link">&para;</a></h3>
<h5 id="_8">定义<a class="headerlink" href="#_8" title="Permanent link">&para;</a></h5>
<p>线性表是具有<strong>相同数据类型</strong>的 n 个数据元素的<strong>有限序列</strong>。其中 n 为表长，当 n=0 时线性表是一个空表。若用 L 命名线性表，则其一般表示为 <span class="arithmatex">\(L=(a_1,a_2,...,a_i,a_{i+1},...,a_n)\)</span>。</p>
<h5 id="_9">特点<a class="headerlink" href="#_9" title="Permanent link">&para;</a></h5>
<ul>
<li><span class="arithmatex">\(a_1\)</span>​是唯一的 “第一个” 数据元素，又称表头元素</li>
<li><span class="arithmatex">\(a_n\)</span>​是唯一的 “最后一个” 数据元素，又称表尾元素</li>
<li>除第一个元素外，每个元素有且仅有一个直接前驱。除最后一个元素外，每个元素有且仅有一个直接后继。</li>
</ul>
<h5 id="_10">基本操作<a class="headerlink" href="#_10" title="Permanent link">&para;</a></h5>
<div class="highlight"><pre><span></span><code><a id="__codelineno-1-1" name="__codelineno-1-1" href="#__codelineno-1-1"></a><span class="n">InitList</span><span class="p">(</span><span class="o">&amp;</span><span class="n">L</span><span class="p">);</span><span class="w">     </span><span class="c1">//初始化表：构造一个空的线性表L，分配内存空间</span>
<a id="__codelineno-1-2" name="__codelineno-1-2" href="#__codelineno-1-2"></a><span class="n">DestoryList</span><span class="p">(</span><span class="o">&amp;</span><span class="n">L</span><span class="p">);</span><span class="w">  </span><span class="c1">//销毁操作：销毁线性表，并释放线性表L所占用的内存空间</span>
<a id="__codelineno-1-3" name="__codelineno-1-3" href="#__codelineno-1-3"></a>
<a id="__codelineno-1-4" name="__codelineno-1-4" href="#__codelineno-1-4"></a><span class="n">ListInsert</span><span class="p">(</span><span class="o">&amp;</span><span class="n">L</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">e</span><span class="p">);</span><span class="w">  </span><span class="c1">//插入操作：在表L中第i个位置上查入指定元素e</span>
<a id="__codelineno-1-5" name="__codelineno-1-5" href="#__codelineno-1-5"></a><span class="n">ListDelete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">L</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="o">&amp;</span><span class="n">e</span><span class="p">);</span><span class="w"> </span><span class="c1">//删除操作：删除表L中第i个位置的元素，/*并用e反回删除元素的值*/</span>
<a id="__codelineno-1-6" name="__codelineno-1-6" href="#__codelineno-1-6"></a>
<a id="__codelineno-1-7" name="__codelineno-1-7" href="#__codelineno-1-7"></a><span class="n">LocateElem</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">e</span><span class="p">);</span><span class="w"> </span><span class="c1">//按值查找操作</span>
<a id="__codelineno-1-8" name="__codelineno-1-8" href="#__codelineno-1-8"></a><span class="n">GetElem</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">i</span><span class="p">);</span><span class="w">    </span><span class="c1">//按位查找操作</span>
<a id="__codelineno-1-9" name="__codelineno-1-9" href="#__codelineno-1-9"></a>
<a id="__codelineno-1-10" name="__codelineno-1-10" href="#__codelineno-1-10"></a><span class="c1">//其它常用操作</span>
<a id="__codelineno-1-11" name="__codelineno-1-11" href="#__codelineno-1-11"></a><span class="n">Length</span><span class="p">(</span><span class="n">L</span><span class="p">);</span><span class="w">  </span><span class="c1">//求表长</span>
<a id="__codelineno-1-12" name="__codelineno-1-12" href="#__codelineno-1-12"></a><span class="n">Print</span><span class="p">(</span><span class="n">L</span><span class="p">);</span><span class="w">   </span><span class="c1">//输出操作</span>
<a id="__codelineno-1-13" name="__codelineno-1-13" href="#__codelineno-1-13"></a><span class="n">Empty</span><span class="p">(</span><span class="n">L</span><span class="p">);</span><span class="w">   </span><span class="c1">//判空操作</span>
</code></pre></div>
<h3 id="12">1.2线性表的顺序表示<a class="headerlink" href="#12" title="Permanent link">&para;</a></h3>
<h4 id="_11">顺序表的定义<a class="headerlink" href="#_11" title="Permanent link">&para;</a></h4>
<p>线性表的顺序存储又称顺序表。它是用一组地址连续的存储单元依次存储线性表中的数据元素，从而使得逻辑上相邻的两个元素在物理位置上也相邻。顺序表的特点是表中元素的逻辑顺序与物理顺序相同。</p>
<ul>
<li>线性表 A 中第<code>i</code>个元素的内存地址：<code>&amp;(A[0])+i*sizeof(ElemType)</code></li>
<li>一维数组可以是静态分配，也可以动态分配</li>
<li>静态分配时，数组的大小和空间事先已经固定，一旦空间占满，再加入新的数据就会产生溢出，进而导致程序崩溃</li>
<li>动态分配时，存储数组的空间是在程序执行过程中通过动态存储分配语句分配的，一旦数据空间占满，就另外开辟一块更大的存储空间，用以替换原来的存储空间。</li>
</ul>
<p><strong>静态分配的实现</strong></p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-2-1" name="__codelineno-2-1" href="#__codelineno-2-1"></a><span class="cp">#define MaxSize 50                </span><span class="c1">//定义线性表的最大长度</span>
<a id="__codelineno-2-2" name="__codelineno-2-2" href="#__codelineno-2-2"></a><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="p">{</span><span class="w"></span>
<a id="__codelineno-2-3" name="__codelineno-2-3" href="#__codelineno-2-3"></a><span class="w">    </span><span class="n">ElemType</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="n">MaxSize</span><span class="p">];</span><span class="w">        </span><span class="c1">//顺序表的元素</span>
<a id="__codelineno-2-4" name="__codelineno-2-4" href="#__codelineno-2-4"></a><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">length</span><span class="p">;</span><span class="w">                    </span><span class="c1">//顺序表的当前长度</span>
<a id="__codelineno-2-5" name="__codelineno-2-5" href="#__codelineno-2-5"></a><span class="p">}</span><span class="n">SqList</span><span class="p">;</span><span class="w">                        </span><span class="c1">//顺序表的类型定义</span>
</code></pre></div>
<p><strong>动态分配的实现</strong></p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-3-1" name="__codelineno-3-1" href="#__codelineno-3-1"></a><span class="cp">#define InitSize 100            </span><span class="c1">//表长度的初始定义</span>
<a id="__codelineno-3-2" name="__codelineno-3-2" href="#__codelineno-3-2"></a><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="p">{</span><span class="w">                </span>
<a id="__codelineno-3-3" name="__codelineno-3-3" href="#__codelineno-3-3"></a><span class="w">    </span><span class="n">ElemType</span><span class="w"> </span><span class="o">*</span><span class="n">data</span><span class="p">;</span><span class="w">                </span><span class="c1">//指示动态分配数组的指针</span>
<a id="__codelineno-3-4" name="__codelineno-3-4" href="#__codelineno-3-4"></a><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">MaxSize</span><span class="p">,</span><span class="n">length</span><span class="p">;</span><span class="w">            </span><span class="c1">//数组的最大容量和当前个数</span>
<a id="__codelineno-3-5" name="__codelineno-3-5" href="#__codelineno-3-5"></a><span class="p">}</span><span class="n">SqList</span><span class="p">;</span><span class="w">                        </span><span class="c1">//动态分配数组顺序表的类型定义</span>
<a id="__codelineno-3-6" name="__codelineno-3-6" href="#__codelineno-3-6"></a><span class="c1">//C的初始动态分配语句</span>
<a id="__codelineno-3-7" name="__codelineno-3-7" href="#__codelineno-3-7"></a><span class="n">L</span><span class="p">.</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">ElemType</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">ElemType</span><span class="p">)</span><span class="o">*</span><span class="n">InitSize</span><span class="p">);</span><span class="w"></span>
<a id="__codelineno-3-8" name="__codelineno-3-8" href="#__codelineno-3-8"></a><span class="n">free</span><span class="p">(</span><span class="n">L</span><span class="p">);</span><span class="w"></span>
<a id="__codelineno-3-9" name="__codelineno-3-9" href="#__codelineno-3-9"></a>
<a id="__codelineno-3-10" name="__codelineno-3-10" href="#__codelineno-3-10"></a><span class="c1">//C++的初始动态分配语句</span>
<a id="__codelineno-3-11" name="__codelineno-3-11" href="#__codelineno-3-11"></a><span class="n">L</span><span class="p">.</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="n">ElemType</span><span class="p">[</span><span class="n">InitSize</span><span class="p">];</span><span class="w"></span>
<a id="__codelineno-3-12" name="__codelineno-3-12" href="#__codelineno-3-12"></a><span class="n">delete</span><span class="w"> </span><span class="n">L</span><span class="p">;</span><span class="w"></span>
</code></pre></div>
<h5 id="_12">特点<a class="headerlink" href="#_12" title="Permanent link">&para;</a></h5>
<ul>
<li>随机访问</li>
<li>存储密度高</li>
<li>插入删除需要移动大量元素</li>
</ul>
<h4 id="_13">顺序表的实现<a class="headerlink" href="#_13" title="Permanent link">&para;</a></h4>
<p><code>注意算法对i的描述是第i个元素，它是以1为起点的</code></p>
<h5 id="_14">插入<a class="headerlink" href="#_14" title="Permanent link">&para;</a></h5>
<div class="highlight"><pre><span></span><code><a id="__codelineno-4-1" name="__codelineno-4-1" href="#__codelineno-4-1"></a><span class="c1">//插入操作：在顺序表L的第i个(位序)上插入x</span>
<a id="__codelineno-4-2" name="__codelineno-4-2" href="#__codelineno-4-2"></a><span class="kt">bool</span><span class="w"> </span><span class="nf">ListInsert</span><span class="p">(</span><span class="n">SqList</span><span class="w"> </span><span class="o">&amp;</span><span class="n">L</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="kt">int</span><span class="w"> </span><span class="n">e</span><span class="p">){</span><span class="w"></span>
<a id="__codelineno-4-3" name="__codelineno-4-3" href="#__codelineno-4-3"></a><span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">||</span><span class="n">i</span><span class="o">&gt;</span><span class="n">L</span><span class="p">.</span><span class="n">length</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="w">       </span><span class="c1">//判断i的范围是否有效</span>
<a id="__codelineno-4-4" name="__codelineno-4-4" href="#__codelineno-4-4"></a><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-4-5" name="__codelineno-4-5" href="#__codelineno-4-5"></a><span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">L</span><span class="p">.</span><span class="n">length</span><span class="o">&gt;=</span><span class="n">MaxSize</span><span class="p">)</span><span class="w">       </span><span class="c1">//当存储空间已满时，不能插入</span>
<a id="__codelineno-4-6" name="__codelineno-4-6" href="#__codelineno-4-6"></a><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-4-7" name="__codelineno-4-7" href="#__codelineno-4-7"></a><span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="o">=</span><span class="n">L</span><span class="p">.</span><span class="n">length</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">&gt;=</span><span class="n">i</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">--</span><span class="p">)</span><span class="w"></span>
<a id="__codelineno-4-8" name="__codelineno-4-8" href="#__codelineno-4-8"></a><span class="w">        </span><span class="n">L</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="n">L</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="mi">-1</span><span class="p">];</span><span class="w">  </span><span class="c1">//将第i个及后面的元素后移</span>
<a id="__codelineno-4-9" name="__codelineno-4-9" href="#__codelineno-4-9"></a><span class="w">    </span><span class="n">L</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="mi">-1</span><span class="p">]</span><span class="o">=</span><span class="n">e</span><span class="p">;</span><span class="w">              </span><span class="c1">//将e放到第i个位置</span>
<a id="__codelineno-4-10" name="__codelineno-4-10" href="#__codelineno-4-10"></a><span class="w">    </span><span class="n">L</span><span class="p">.</span><span class="n">length</span><span class="o">++</span><span class="p">;</span><span class="w">                 </span><span class="c1">//长度+1</span>
<a id="__codelineno-4-11" name="__codelineno-4-11" href="#__codelineno-4-11"></a><span class="p">}</span><span class="w"></span>
</code></pre></div>
<h6 id="_15">插入的时间复杂度：<a class="headerlink" href="#_15" title="Permanent link">&para;</a></h6>
<p>最好情况：插到表尾，不需移动元素，循环0次，<code>最好时间复杂度</code>=O(1)</p>
<p>最坏情况：插到表头，移动n个元素，循环n次，<code>最坏时间复杂度</code>=O(n)</p>
<p>平均情况：设插入概率为p=1/n+1，则循环np+(n-1)p+…+1p=n/2，<code>平均时间复杂度</code>=O(n)</p>
<h5 id="_16">删除<a class="headerlink" href="#_16" title="Permanent link">&para;</a></h5>
<div class="highlight"><pre><span></span><code><a id="__codelineno-5-1" name="__codelineno-5-1" href="#__codelineno-5-1"></a><span class="c1">//删除操作：删除顺序表L中第i个元素并返回其元素值</span>
<a id="__codelineno-5-2" name="__codelineno-5-2" href="#__codelineno-5-2"></a><span class="kt">bool</span><span class="w"> </span><span class="nf">ListDelete</span><span class="p">(</span><span class="n">SqList</span><span class="w"> </span><span class="o">&amp;</span><span class="n">L</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="kt">int</span><span class="w"> </span><span class="o">&amp;</span><span class="n">e</span><span class="p">){</span><span class="w"></span>
<a id="__codelineno-5-3" name="__codelineno-5-3" href="#__codelineno-5-3"></a><span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">||</span><span class="n">i</span><span class="o">&gt;</span><span class="n">L</span><span class="p">.</span><span class="n">length</span><span class="o">+</span><span class="mi">1</span><span class="p">){</span><span class="w">             </span><span class="c1">//判断i的范围是否有效</span>
<a id="__codelineno-5-4" name="__codelineno-5-4" href="#__codelineno-5-4"></a><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-5-5" name="__codelineno-5-5" href="#__codelineno-5-5"></a><span class="w">    </span><span class="p">}</span><span class="k">else</span><span class="p">{</span><span class="w"></span>
<a id="__codelineno-5-6" name="__codelineno-5-6" href="#__codelineno-5-6"></a><span class="w">        </span><span class="n">e</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">L</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="mi">-1</span><span class="p">];</span><span class="w">               </span><span class="c1">//将被删除的元素赋值给e</span>
<a id="__codelineno-5-7" name="__codelineno-5-7" href="#__codelineno-5-7"></a><span class="w">        </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">&lt;</span><span class="n">L</span><span class="p">.</span><span class="n">length</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">){</span><span class="w"></span>
<a id="__codelineno-5-8" name="__codelineno-5-8" href="#__codelineno-5-8"></a><span class="w">            </span><span class="n">L</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="n">L</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="mi">-1</span><span class="p">];</span><span class="w">     </span><span class="c1">//将第i个后面的元素前移</span>
<a id="__codelineno-5-9" name="__codelineno-5-9" href="#__codelineno-5-9"></a><span class="w">        </span><span class="p">}</span><span class="w"></span>
<a id="__codelineno-5-10" name="__codelineno-5-10" href="#__codelineno-5-10"></a><span class="w">        </span><span class="n">L</span><span class="p">.</span><span class="n">length</span><span class="o">--</span><span class="p">;</span><span class="w">                    </span><span class="c1">//长度-1</span>
<a id="__codelineno-5-11" name="__codelineno-5-11" href="#__codelineno-5-11"></a><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">ture</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-5-12" name="__codelineno-5-12" href="#__codelineno-5-12"></a><span class="w">    </span><span class="p">}</span><span class="w"></span>
<a id="__codelineno-5-13" name="__codelineno-5-13" href="#__codelineno-5-13"></a><span class="p">}</span><span class="w"></span>
</code></pre></div>
<h6 id="_17">删除的时间复杂度：<a class="headerlink" href="#_17" title="Permanent link">&para;</a></h6>
<p>最好情况：删除表尾，不需移动元素，循环0次，<code>最好时间复杂度</code>=O(1)</p>
<p>最坏情况：删除表头，移动n-1个元素，循环n次，<code>最坏时间复杂度</code>=O(n)</p>
<p>平均情况：设删除概率为p=1/n，则循环(n-1)p+(n-2)p+…+1p=(n-1)/2，<code>平均时间复杂度</code>=O(n)</p>
<h5 id="_18">查找<a class="headerlink" href="#_18" title="Permanent link">&para;</a></h5>
<h6 id="_19">按位查找<a class="headerlink" href="#_19" title="Permanent link">&para;</a></h6>
<div class="highlight"><pre><span></span><code><a id="__codelineno-6-1" name="__codelineno-6-1" href="#__codelineno-6-1"></a><span class="c1">//按位查找：返回顺序表中第i个元素的元素值</span>
<a id="__codelineno-6-2" name="__codelineno-6-2" href="#__codelineno-6-2"></a><span class="kt">int</span><span class="w"> </span><span class="nf">GetElem</span><span class="p">(</span><span class="n">Sqlist</span><span class="w"> </span><span class="n">L</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">){</span><span class="w"></span>
<a id="__codelineno-6-3" name="__codelineno-6-3" href="#__codelineno-6-3"></a><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">L</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="mi">-1</span><span class="p">];</span><span class="w"></span>
<a id="__codelineno-6-4" name="__codelineno-6-4" href="#__codelineno-6-4"></a><span class="p">}</span><span class="w"></span>
</code></pre></div>
<h6 id="_20"># 按位查找的时间复杂度<a class="headerlink" href="#_20" title="Permanent link">&para;</a></h6>
<p>时间复杂度=O(1)</p>
<h6 id="_21">按值查找<a class="headerlink" href="#_21" title="Permanent link">&para;</a></h6>
<div class="highlight"><pre><span></span><code><a id="__codelineno-7-1" name="__codelineno-7-1" href="#__codelineno-7-1"></a><span class="c1">//按值查找：返回顺序表L中第一个值为x的元素的位置</span>
<a id="__codelineno-7-2" name="__codelineno-7-2" href="#__codelineno-7-2"></a><span class="kt">int</span><span class="w"> </span><span class="nf">LocateElem</span><span class="p">(</span><span class="n">Sqlist</span><span class="w"> </span><span class="n">L</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">e</span><span class="p">){</span><span class="w"></span>
<a id="__codelineno-7-3" name="__codelineno-7-3" href="#__codelineno-7-3"></a><span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">L</span><span class="p">.</span><span class="n">length</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">){</span><span class="w"></span>
<a id="__codelineno-7-4" name="__codelineno-7-4" href="#__codelineno-7-4"></a><span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">L</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">e</span><span class="p">)</span><span class="w"></span>
<a id="__codelineno-7-5" name="__codelineno-7-5" href="#__codelineno-7-5"></a><span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span><span class="w">  </span><span class="c1">//返回元素位置</span>
<a id="__codelineno-7-6" name="__codelineno-7-6" href="#__codelineno-7-6"></a><span class="w">    </span><span class="p">}</span><span class="w"></span>
<a id="__codelineno-7-7" name="__codelineno-7-7" href="#__codelineno-7-7"></a><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span><span class="w">  </span><span class="c1">//查找失败，返回-1</span>
<a id="__codelineno-7-8" name="__codelineno-7-8" href="#__codelineno-7-8"></a><span class="p">}</span><span class="w"></span>
</code></pre></div>
<h6 id="_22"># 按值查找的时间复杂度<a class="headerlink" href="#_22" title="Permanent link">&para;</a></h6>
<p>最好情况：目标在表头，循环1次，<code>最好时间复杂度</code>=O(1)</p>
<p>最坏情况：目标在表尾，循环n次，<code>最坏时间复杂度</code>=O(n)</p>
<p>平均情况：设删除概率为p=1/n，则循环(n-1)p+(n-2)p+…+1p=(n+1)/2，<code>平均时间复杂度</code>=O(n)</p>
<h3 id="13">1.3 线性表的链式表示<a class="headerlink" href="#13" title="Permanent link">&para;</a></h3>
<h4 id="_23">单链表<a class="headerlink" href="#_23" title="Permanent link">&para;</a></h4>
<ul>
<li>结点描述：</li>
</ul>
<div class="highlight"><pre><span></span><code><a id="__codelineno-8-1" name="__codelineno-8-1" href="#__codelineno-8-1"></a><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">LNode</span><span class="p">{</span><span class="w">        </span><span class="c1">//定义单链表结点类型</span>
<a id="__codelineno-8-2" name="__codelineno-8-2" href="#__codelineno-8-2"></a><span class="w">    </span><span class="n">ElemType</span><span class="w"> </span><span class="n">data</span><span class="p">;</span><span class="w">            </span><span class="c1">//数据域</span>
<a id="__codelineno-8-3" name="__codelineno-8-3" href="#__codelineno-8-3"></a><span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">LNode</span><span class="w"> </span><span class="o">*</span><span class="n">next</span><span class="p">;</span><span class="w">        </span><span class="c1">//指针域</span>
<a id="__codelineno-8-4" name="__codelineno-8-4" href="#__codelineno-8-4"></a><span class="p">}</span><span class="n">LNode</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">LinkList</span><span class="p">;</span><span class="w">        </span><span class="c1">//LinkList为指向结构体LNODE的指针类型</span>
</code></pre></div>
<ul>
<li>通常用头指针来标示一个单链表。</li>
<li>有头结点或者没头结点之分</li>
<li>头结点的作用</li>
<li>便于首元结点的处理，对链表的第一个数据元素的操作与其他数据元素相同，无需特殊处理</li>
<li>便于空表与非空表的统一处理：头指针永远不为空</li>
</ul>
<h4 id="_24">单链表的实现<a class="headerlink" href="#_24" title="Permanent link">&para;</a></h4>
<p><img alt="" src="../../images/20210417202853466.png" />
<div class="highlight"><pre><span></span><code><a id="__codelineno-9-1" name="__codelineno-9-1" href="#__codelineno-9-1"></a><span class="n">LinkList</span><span class="w"> </span><span class="nf">List_HeadInsert</span><span class="p">(</span><span class="n">LinkList</span><span class="w"> </span><span class="o">&amp;</span><span class="n">L</span><span class="p">){</span><span class="w"></span>
<a id="__codelineno-9-2" name="__codelineno-9-2" href="#__codelineno-9-2"></a><span class="w">    </span><span class="n">LNode</span><span class="w"> </span><span class="o">*</span><span class="n">s</span><span class="p">;</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-9-3" name="__codelineno-9-3" href="#__codelineno-9-3"></a><span class="w">    </span><span class="n">L</span><span class="o">=</span><span class="p">(</span><span class="n">LinkList</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">LNode</span><span class="p">));</span><span class="c1">//创建头结点</span>
<a id="__codelineno-9-4" name="__codelineno-9-4" href="#__codelineno-9-4"></a><span class="w">    </span><span class="n">L</span><span class="o">-&gt;</span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w">                    </span><span class="c1">//初始为空链表</span>
<a id="__codelineno-9-5" name="__codelineno-9-5" href="#__codelineno-9-5"></a><span class="w">    </span><span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span><span class="o">&amp;</span><span class="n">x</span><span class="p">);</span><span class="w"></span>
<a id="__codelineno-9-6" name="__codelineno-9-6" href="#__codelineno-9-6"></a><span class="w">    </span><span class="k">while</span><span class="p">(</span><span class="n">x</span><span class="o">!=</span><span class="mi">9999</span><span class="p">){</span><span class="w"></span>
<a id="__codelineno-9-7" name="__codelineno-9-7" href="#__codelineno-9-7"></a><span class="w">        </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">LNode</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">LNode</span><span class="p">));</span><span class="w"></span>
<a id="__codelineno-9-8" name="__codelineno-9-8" href="#__codelineno-9-8"></a><span class="w">        </span><span class="n">s</span><span class="o">-&gt;</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-9-9" name="__codelineno-9-9" href="#__codelineno-9-9"></a><span class="w">        </span><span class="n">s</span><span class="o">-&gt;</span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">L</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-9-10" name="__codelineno-9-10" href="#__codelineno-9-10"></a><span class="w">        </span><span class="n">L</span><span class="o">-&gt;</span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-9-11" name="__codelineno-9-11" href="#__codelineno-9-11"></a><span class="w">        </span><span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span><span class="o">&amp;</span><span class="n">x</span><span class="p">);</span><span class="w"></span>
<a id="__codelineno-9-12" name="__codelineno-9-12" href="#__codelineno-9-12"></a><span class="w">    </span><span class="p">}</span><span class="w"></span>
<a id="__codelineno-9-13" name="__codelineno-9-13" href="#__codelineno-9-13"></a><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">L</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-9-14" name="__codelineno-9-14" href="#__codelineno-9-14"></a><span class="p">}</span><span class="w"></span>
</code></pre></div></p>
<p><img alt="" src="../../images/20210417204450775.png" />
<div class="highlight"><pre><span></span><code><a id="__codelineno-10-1" name="__codelineno-10-1" href="#__codelineno-10-1"></a><span class="n">LinkList</span><span class="w"> </span><span class="nf">List_TailInsert</span><span class="p">(</span><span class="n">LinkList</span><span class="w"> </span><span class="o">&amp;</span><span class="n">L</span><span class="p">){</span><span class="w"></span>
<a id="__codelineno-10-2" name="__codelineno-10-2" href="#__codelineno-10-2"></a><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-10-3" name="__codelineno-10-3" href="#__codelineno-10-3"></a><span class="w">    </span><span class="n">L</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">LinkList</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">LNode</span><span class="p">));</span><span class="w"></span>
<a id="__codelineno-10-4" name="__codelineno-10-4" href="#__codelineno-10-4"></a><span class="w">    </span><span class="n">LNode</span><span class="w"> </span><span class="o">*</span><span class="n">s</span><span class="p">,</span><span class="o">*</span><span class="n">r</span><span class="o">=</span><span class="n">L</span><span class="p">;</span><span class="w">            </span><span class="c1">//r为表尾指针</span>
<a id="__codelineno-10-5" name="__codelineno-10-5" href="#__codelineno-10-5"></a><span class="w">    </span><span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span><span class="o">&amp;</span><span class="n">x</span><span class="p">);</span><span class="w"></span>
<a id="__codelineno-10-6" name="__codelineno-10-6" href="#__codelineno-10-6"></a><span class="w">    </span><span class="k">while</span><span class="p">(</span><span class="n">x</span><span class="o">!=</span><span class="mi">9999</span><span class="p">){</span><span class="w"></span>
<a id="__codelineno-10-7" name="__codelineno-10-7" href="#__codelineno-10-7"></a><span class="w">        </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">LNode</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">LNode</span><span class="p">));</span><span class="w"></span>
<a id="__codelineno-10-8" name="__codelineno-10-8" href="#__codelineno-10-8"></a><span class="w">        </span><span class="n">s</span><span class="o">-&gt;</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-10-9" name="__codelineno-10-9" href="#__codelineno-10-9"></a><span class="w">        </span><span class="n">r</span><span class="o">-&gt;</span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-10-10" name="__codelineno-10-10" href="#__codelineno-10-10"></a><span class="w">        </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-10-11" name="__codelineno-10-11" href="#__codelineno-10-11"></a><span class="w">        </span><span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span><span class="o">&amp;</span><span class="n">x</span><span class="p">);</span><span class="w"></span>
<a id="__codelineno-10-12" name="__codelineno-10-12" href="#__codelineno-10-12"></a><span class="w">    </span><span class="p">}</span><span class="w"></span>
<a id="__codelineno-10-13" name="__codelineno-10-13" href="#__codelineno-10-13"></a><span class="w">    </span><span class="n">r</span><span class="o">-&gt;</span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w">                </span><span class="c1">//尾结点指针置空</span>
<a id="__codelineno-10-14" name="__codelineno-10-14" href="#__codelineno-10-14"></a><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">L</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-10-15" name="__codelineno-10-15" href="#__codelineno-10-15"></a><span class="p">}</span><span class="w"></span>
</code></pre></div></p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-11-1" name="__codelineno-11-1" href="#__codelineno-11-1"></a><span class="n">LNode</span><span class="w"> </span><span class="o">*</span><span class="nf">LocateElem</span><span class="p">(</span><span class="n">LinkList</span><span class="w"> </span><span class="n">L</span><span class="p">,</span><span class="n">ElemType</span><span class="w"> </span><span class="n">e</span><span class="p">){</span><span class="c1">//按值查找</span>
<a id="__codelineno-11-2" name="__codelineno-11-2" href="#__codelineno-11-2"></a><span class="w">    </span><span class="n">LNode</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">L</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-11-3" name="__codelineno-11-3" href="#__codelineno-11-3"></a><span class="w">    </span><span class="k">while</span><span class="p">(</span><span class="n">p</span><span class="o">!=</span><span class="nb">NULL</span><span class="o">&amp;&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">!=</span><span class="n">e</span><span class="p">)</span><span class="w"></span>
<a id="__codelineno-11-4" name="__codelineno-11-4" href="#__codelineno-11-4"></a><span class="w">        </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-11-5" name="__codelineno-11-5" href="#__codelineno-11-5"></a><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">p</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-11-6" name="__codelineno-11-6" href="#__codelineno-11-6"></a><span class="p">}</span><span class="w"></span>
</code></pre></div>
<h5 id="_25">删除<a class="headerlink" href="#_25" title="Permanent link">&para;</a></h5>
<h6 id="_26">按位序删除<a class="headerlink" href="#_26" title="Permanent link">&para;</a></h6>
<div class="highlight"><pre><span></span><code><a id="__codelineno-12-1" name="__codelineno-12-1" href="#__codelineno-12-1"></a><span class="c1">//删除操作:将单链表中的第i个结点删除</span>
<a id="__codelineno-12-2" name="__codelineno-12-2" href="#__codelineno-12-2"></a><span class="kt">bool</span><span class="w"> </span><span class="nf">Delete</span><span class="p">(</span><span class="n">LinkList</span><span class="w"> </span><span class="o">&amp;</span><span class="n">L</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">&amp;</span><span class="n">e</span><span class="p">){</span><span class="w"></span>
<a id="__codelineno-12-3" name="__codelineno-12-3" href="#__codelineno-12-3"></a><span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">1</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">i</span><span class="o">&gt;</span><span class="n">Length</span><span class="p">(</span><span class="n">L</span><span class="p">))</span><span class="w"></span>
<a id="__codelineno-12-4" name="__codelineno-12-4" href="#__codelineno-12-4"></a><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-12-5" name="__codelineno-12-5" href="#__codelineno-12-5"></a><span class="w">    </span><span class="n">LNode</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GetElem</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">i</span><span class="mi">-1</span><span class="p">);</span><span class="w">  </span><span class="c1">//查找第i个位置</span>
<a id="__codelineno-12-6" name="__codelineno-12-6" href="#__codelineno-12-6"></a><span class="w">    </span><span class="n">LNode</span><span class="w"> </span><span class="o">*</span><span class="n">q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-12-7" name="__codelineno-12-7" href="#__codelineno-12-7"></a><span class="w">    </span><span class="n">e</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">q</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-12-8" name="__codelineno-12-8" href="#__codelineno-12-8"></a><span class="w">    </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">q</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-12-9" name="__codelineno-12-9" href="#__codelineno-12-9"></a><span class="w">    </span><span class="n">free</span><span class="p">(</span><span class="n">q</span><span class="p">);</span><span class="w"></span>
<a id="__codelineno-12-10" name="__codelineno-12-10" href="#__codelineno-12-10"></a><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-12-11" name="__codelineno-12-11" href="#__codelineno-12-11"></a><span class="p">}</span><span class="w"></span>
</code></pre></div>
<h6 id="_27"># 按位序删除的时间复杂度：<a class="headerlink" href="#_27" title="Permanent link">&para;</a></h6>
<p>最好情况：删除第一个，不需查找位置，循环0次，<code>最好时间复杂度</code>=O(1)</p>
<p>最坏情况：删除最后一个，需查找第n位，循环n次，<code>最坏时间复杂度</code>=O(n)</p>
<p>平均情况：删除任意一个，<code>平均时间复杂度</code>=O(n)</p>
<h6 id="_28">指定结点的删除<a class="headerlink" href="#_28" title="Permanent link">&para;</a></h6>
<p><code>时间复杂度</code>=O(n)</p>
<p>方法：p的后一个为q，p指向q的下一个，把q的值给p，最后释放q</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-13-1" name="__codelineno-13-1" href="#__codelineno-13-1"></a><span class="c1">//删除指定结点p</span>
<a id="__codelineno-13-2" name="__codelineno-13-2" href="#__codelineno-13-2"></a><span class="kt">bool</span><span class="w"> </span><span class="nf">Delete</span><span class="p">(</span><span class="n">LNode</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">){</span><span class="w"></span>
<a id="__codelineno-13-3" name="__codelineno-13-3" href="#__codelineno-13-3"></a><span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="o">==</span><span class="nb">NULL</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-13-4" name="__codelineno-13-4" href="#__codelineno-13-4"></a><span class="w">    </span><span class="n">LNode</span><span class="w"> </span><span class="o">*</span><span class="n">q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-13-5" name="__codelineno-13-5" href="#__codelineno-13-5"></a><span class="w">    </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">q</span><span class="o">-&gt;</span><span class="n">data</span><span class="w"></span>
<a id="__codelineno-13-6" name="__codelineno-13-6" href="#__codelineno-13-6"></a><span class="w">    </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">q</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-13-7" name="__codelineno-13-7" href="#__codelineno-13-7"></a><span class="w">    </span><span class="n">free</span><span class="p">(</span><span class="n">q</span><span class="p">);</span><span class="w"></span>
<a id="__codelineno-13-8" name="__codelineno-13-8" href="#__codelineno-13-8"></a><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-13-9" name="__codelineno-13-9" href="#__codelineno-13-9"></a><span class="p">}</span><span class="w"></span>
</code></pre></div>
<h5 id="_29">查找<a class="headerlink" href="#_29" title="Permanent link">&para;</a></h5>
<h6 id="_30">按位查找<a class="headerlink" href="#_30" title="Permanent link">&para;</a></h6>
<p><code>平均时间复杂度</code>=O(n)</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-14-1" name="__codelineno-14-1" href="#__codelineno-14-1"></a><span class="c1">//按位查找：查找在单链表L中第i个位置的结点</span>
<a id="__codelineno-14-2" name="__codelineno-14-2" href="#__codelineno-14-2"></a><span class="n">LNode</span><span class="w"> </span><span class="o">*</span><span class="nf">GetElem</span><span class="p">(</span><span class="n">LinkList</span><span class="w"> </span><span class="n">L</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">){</span><span class="w"></span>
<a id="__codelineno-14-3" name="__codelineno-14-3" href="#__codelineno-14-3"></a><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-14-4" name="__codelineno-14-4" href="#__codelineno-14-4"></a><span class="w">    </span><span class="n">LNode</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">L</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-14-5" name="__codelineno-14-5" href="#__codelineno-14-5"></a><span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-14-6" name="__codelineno-14-6" href="#__codelineno-14-6"></a><span class="w">    </span><span class="k">while</span><span class="p">(</span><span class="n">p</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">j</span><span class="o">&lt;</span><span class="n">i</span><span class="p">){</span><span class="w"></span>
<a id="__codelineno-14-7" name="__codelineno-14-7" href="#__codelineno-14-7"></a><span class="w">        </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-14-8" name="__codelineno-14-8" href="#__codelineno-14-8"></a><span class="w">        </span><span class="n">j</span><span class="o">++</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-14-9" name="__codelineno-14-9" href="#__codelineno-14-9"></a><span class="w">    </span><span class="p">}</span><span class="w"></span>
<a id="__codelineno-14-10" name="__codelineno-14-10" href="#__codelineno-14-10"></a><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">p</span><span class="p">;</span><span class="w"> </span><span class="c1">//如果i大于表长，p=NULL,直接返回p即可</span>
<a id="__codelineno-14-11" name="__codelineno-14-11" href="#__codelineno-14-11"></a><span class="p">}</span><span class="w"></span>
</code></pre></div>
<h6 id="_31">按值查找<a class="headerlink" href="#_31" title="Permanent link">&para;</a></h6>
<p><code>平均时间复杂度</code>=O(n)</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-15-1" name="__codelineno-15-1" href="#__codelineno-15-1"></a><span class="c1">//按值查找：查找e在L中的位置</span>
<a id="__codelineno-15-2" name="__codelineno-15-2" href="#__codelineno-15-2"></a><span class="n">LNode</span><span class="w"> </span><span class="o">*</span><span class="nf">LocateElem</span><span class="p">(</span><span class="n">LinkList</span><span class="w"> </span><span class="n">L</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">e</span><span class="p">){</span><span class="w"></span>
<a id="__codelineno-15-3" name="__codelineno-15-3" href="#__codelineno-15-3"></a><span class="w">    </span><span class="n">LNode</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">L</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-15-4" name="__codelineno-15-4" href="#__codelineno-15-4"></a><span class="w">    </span><span class="k">while</span><span class="p">(</span><span class="n">p</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">data</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">e</span><span class="p">){</span><span class="w"></span>
<a id="__codelineno-15-5" name="__codelineno-15-5" href="#__codelineno-15-5"></a><span class="w">        </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-15-6" name="__codelineno-15-6" href="#__codelineno-15-6"></a><span class="w">    </span><span class="p">}</span><span class="w"></span>
<a id="__codelineno-15-7" name="__codelineno-15-7" href="#__codelineno-15-7"></a><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">p</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-15-8" name="__codelineno-15-8" href="#__codelineno-15-8"></a><span class="p">}</span><span class="w"></span>
</code></pre></div>
<h5 id="_32">求表长<a class="headerlink" href="#_32" title="Permanent link">&para;</a></h5>
<p><code>平均时间复杂度</code>=O(n)</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-16-1" name="__codelineno-16-1" href="#__codelineno-16-1"></a><span class="c1">//求表的长度</span>
<a id="__codelineno-16-2" name="__codelineno-16-2" href="#__codelineno-16-2"></a><span class="kt">int</span><span class="w"> </span><span class="nf">Length</span><span class="p">(</span><span class="n">LinkList</span><span class="w"> </span><span class="n">L</span><span class="p">){</span><span class="w"></span>
<a id="__codelineno-16-3" name="__codelineno-16-3" href="#__codelineno-16-3"></a><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-16-4" name="__codelineno-16-4" href="#__codelineno-16-4"></a><span class="w">    </span><span class="n">LNode</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">L</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-16-5" name="__codelineno-16-5" href="#__codelineno-16-5"></a><span class="w">    </span><span class="k">while</span><span class="p">(</span><span class="n">P</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">){</span><span class="w"></span>
<a id="__codelineno-16-6" name="__codelineno-16-6" href="#__codelineno-16-6"></a><span class="w">        </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-16-7" name="__codelineno-16-7" href="#__codelineno-16-7"></a><span class="w">        </span><span class="n">len</span><span class="o">++</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-16-8" name="__codelineno-16-8" href="#__codelineno-16-8"></a><span class="w">    </span><span class="p">}</span><span class="w"></span>
<a id="__codelineno-16-9" name="__codelineno-16-9" href="#__codelineno-16-9"></a><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">len</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-16-10" name="__codelineno-16-10" href="#__codelineno-16-10"></a><span class="p">}</span><span class="w"></span>
</code></pre></div>
<h5 id="_33">遍历<a class="headerlink" href="#_33" title="Permanent link">&para;</a></h5>
<div class="highlight"><pre><span></span><code><a id="__codelineno-17-1" name="__codelineno-17-1" href="#__codelineno-17-1"></a><span class="c1">//遍历操作</span>
<a id="__codelineno-17-2" name="__codelineno-17-2" href="#__codelineno-17-2"></a><span class="kt">void</span><span class="w"> </span><span class="nf">PrintList</span><span class="p">(</span><span class="n">LinkList</span><span class="w"> </span><span class="n">L</span><span class="p">){</span><span class="w"></span>
<a id="__codelineno-17-3" name="__codelineno-17-3" href="#__codelineno-17-3"></a><span class="w">    </span><span class="n">LNode</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">L</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-17-4" name="__codelineno-17-4" href="#__codelineno-17-4"></a><span class="w">    </span><span class="k">while</span><span class="p">(</span><span class="n">p</span><span class="p">){</span><span class="w"></span>
<a id="__codelineno-17-5" name="__codelineno-17-5" href="#__codelineno-17-5"></a><span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d &quot;</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span><span class="w"></span>
<a id="__codelineno-17-6" name="__codelineno-17-6" href="#__codelineno-17-6"></a><span class="w">        </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-17-7" name="__codelineno-17-7" href="#__codelineno-17-7"></a><span class="w">    </span><span class="p">}</span><span class="w"></span>
<a id="__codelineno-17-8" name="__codelineno-17-8" href="#__codelineno-17-8"></a><span class="p">}</span><span class="w"></span>
</code></pre></div>
<h4 id="_34">双链表<a class="headerlink" href="#_34" title="Permanent link">&para;</a></h4>
<div class="highlight"><pre><span></span><code><a id="__codelineno-18-1" name="__codelineno-18-1" href="#__codelineno-18-1"></a><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">DNode</span><span class="p">{</span><span class="w"></span>
<a id="__codelineno-18-2" name="__codelineno-18-2" href="#__codelineno-18-2"></a><span class="w">    </span><span class="n">ElemType</span><span class="w"> </span><span class="n">data</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-18-3" name="__codelineno-18-3" href="#__codelineno-18-3"></a><span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">DNode</span><span class="w"> </span><span class="o">*</span><span class="n">prior</span><span class="p">,</span><span class="o">*</span><span class="n">next</span><span class="p">;</span><span class="w">    </span><span class="c1">//前驱和后继指针</span>
<a id="__codelineno-18-4" name="__codelineno-18-4" href="#__codelineno-18-4"></a><span class="p">}</span><span class="n">DNode</span><span class="p">,</span><span class="o">*</span><span class="n">DLinkList</span><span class="p">;</span><span class="w"></span>
</code></pre></div>
<h4 id="_35">循环链表<a class="headerlink" href="#_35" title="Permanent link">&para;</a></h4>
<ul>
<li>循环单链表</li>
</ul>
<p>初始化和判空(与单链表不一样)
<code>L-&gt;next = NULL改为L-&gt;next = L</code></p>
<ul>
<li>循环双链表</li>
</ul>
<p>初始化和判空(与双链表不一样)
<div class="highlight"><pre><span></span><code><a id="__codelineno-19-1" name="__codelineno-19-1" href="#__codelineno-19-1"></a><span class="n">L</span><span class="o">-&gt;</span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">NULL改为L</span><span class="o">-&gt;</span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">L</span><span class="w"></span>
<a id="__codelineno-19-2" name="__codelineno-19-2" href="#__codelineno-19-2"></a><span class="n">L</span><span class="o">-&gt;</span><span class="n">prior</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">NULL改为L</span><span class="o">-&gt;</span><span class="n">prior</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">L</span><span class="w"></span>
</code></pre></div></p>
<h4 id="_36">静态链表<a class="headerlink" href="#_36" title="Permanent link">&para;</a></h4>
<p>借助数组来描述线性表的链式存储结构，结点也有数据域<code>data</code>和指针域<code>next</code>，这里的指针是节点的相对地址（数组下标），又称<strong>游标</strong>
<img alt="静态链表" src="../../images/20210418162136494.png" />
<div class="highlight"><pre><span></span><code><a id="__codelineno-20-1" name="__codelineno-20-1" href="#__codelineno-20-1"></a><span class="cp">#define MaxSize 50</span>
<a id="__codelineno-20-2" name="__codelineno-20-2" href="#__codelineno-20-2"></a><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="p">{</span><span class="w"></span>
<a id="__codelineno-20-3" name="__codelineno-20-3" href="#__codelineno-20-3"></a><span class="w">    </span><span class="n">ElemType</span><span class="w"> </span><span class="n">data</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-20-4" name="__codelineno-20-4" href="#__codelineno-20-4"></a><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">next</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-20-5" name="__codelineno-20-5" href="#__codelineno-20-5"></a><span class="p">}</span><span class="n">SLinkList</span><span class="p">[</span><span class="n">MaxSize</span><span class="p">];</span><span class="w"></span>
</code></pre></div></p>
<h2 id="2">2. 栈和队列<a class="headerlink" href="#2" title="Permanent link">&para;</a></h2>
<h3 id="21">2.1 栈<a class="headerlink" href="#21" title="Permanent link">&para;</a></h3>
<h4 id="211">2.1.1 栈的基本概念<a class="headerlink" href="#211" title="Permanent link">&para;</a></h4>
<h5 id="_37">栈的定义<a class="headerlink" href="#_37" title="Permanent link">&para;</a></h5>
<ul>
<li>栈是只允许在一端进行插入或删除操作的线性表。后进先出 LIFO</li>
<li>栈顶（Top）：线性表允许进行插入删除的那一端。</li>
<li>栈底（Bottom）：固定的，不允许进行插入和删除的另一端</li>
<li>空栈：不包含任何元素的空表</li>
</ul>
<p>N个不同元素进栈出栈，出栈的序列个数为：<span class="arithmatex">\(\frac {1} {n-1}C^{n}_{2n}=\frac{1}{n-1} \frac{(2n)!}{n! \times n!}\)</span></p>
<h5 id="_38">栈的基本操作<a class="headerlink" href="#_38" title="Permanent link">&para;</a></h5>
<div class="highlight"><pre><span></span><code><a id="__codelineno-21-1" name="__codelineno-21-1" href="#__codelineno-21-1"></a><span class="n">InitStack</span><span class="p">(</span><span class="o">&amp;</span><span class="n">S</span><span class="p">)</span><span class="o">:</span><span class="n">初始化一个空栈S</span><span class="w"></span>
<a id="__codelineno-21-2" name="__codelineno-21-2" href="#__codelineno-21-2"></a><span class="n">StackEmpty</span><span class="p">(</span><span class="n">S</span><span class="p">)</span><span class="o">:</span><span class="n">判断一个栈是否为空</span><span class="err">，</span><span class="n">若栈S为空则返回true</span><span class="err">，</span><span class="n">否则返回false</span><span class="w"></span>
<a id="__codelineno-21-3" name="__codelineno-21-3" href="#__codelineno-21-3"></a><span class="n">Push</span><span class="p">(</span><span class="o">&amp;</span><span class="n">S</span><span class="p">,</span><span class="n">x</span><span class="p">)</span><span class="o">:</span><span class="n">进栈</span><span class="err">，</span><span class="n">若栈S未满</span><span class="err">，</span><span class="n">则将x加入使之成为新栈顶</span><span class="w"></span>
<a id="__codelineno-21-4" name="__codelineno-21-4" href="#__codelineno-21-4"></a><span class="n">Pop</span><span class="p">(</span><span class="o">&amp;</span><span class="n">S</span><span class="p">,</span><span class="o">&amp;</span><span class="n">x</span><span class="p">)</span><span class="o">:</span><span class="n">出栈</span><span class="err">，</span><span class="n">若栈S非空</span><span class="err">，</span><span class="n">则弹出栈顶元素</span><span class="err">，</span><span class="n">并用x返回</span><span class="w"></span>
<a id="__codelineno-21-5" name="__codelineno-21-5" href="#__codelineno-21-5"></a><span class="n">GetTop</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="o">&amp;</span><span class="n">x</span><span class="p">)</span><span class="o">:</span><span class="n">读取栈顶元素</span><span class="err">，</span><span class="n">若栈S非空</span><span class="err">，</span><span class="n">则用x返回栈顶元素</span><span class="w"></span>
<a id="__codelineno-21-6" name="__codelineno-21-6" href="#__codelineno-21-6"></a><span class="n">DestroyStack</span><span class="p">(</span><span class="o">&amp;</span><span class="n">S</span><span class="p">)</span><span class="o">:</span><span class="n">销毁栈</span><span class="err">，</span><span class="n">并释放栈S占用的存储空间</span><span class="w"></span>
</code></pre></div>
<h4 id="212">2.1.2 栈的顺序存储结构<a class="headerlink" href="#212" title="Permanent link">&para;</a></h4>
<h5 id="_39">顺序栈的实现<a class="headerlink" href="#_39" title="Permanent link">&para;</a></h5>
<p>利用一组地址连续的存储单元存放自栈底到栈顶的数据元素，并附设一个指针<code>top</code>指示当前栈顶元素的位置</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-22-1" name="__codelineno-22-1" href="#__codelineno-22-1"></a><span class="cp">#define MaxSize 50            </span><span class="c1">//定义栈中元素最大个数</span>
<a id="__codelineno-22-2" name="__codelineno-22-2" href="#__codelineno-22-2"></a><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="p">{</span><span class="w"></span>
<a id="__codelineno-22-3" name="__codelineno-22-3" href="#__codelineno-22-3"></a><span class="w">    </span><span class="n">Elemtype</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="n">MaxSize</span><span class="p">];</span><span class="w">    </span><span class="c1">//存放栈中元素</span>
<a id="__codelineno-22-4" name="__codelineno-22-4" href="#__codelineno-22-4"></a><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">top</span><span class="p">;</span><span class="c1">//栈顶指针</span>
<a id="__codelineno-22-5" name="__codelineno-22-5" href="#__codelineno-22-5"></a><span class="p">}</span><span class="w"></span>
</code></pre></div>
<ul>
<li>栈顶指针：<code>S.top</code>，初始时设置<code>S.top=-1</code>；栈顶元素：<code>S.data[S.top]</code></li>
<li>进栈操作：栈不满时，栈顶指针先加 1，再送值到栈顶元素</li>
<li>出栈操作：栈非空时，先取栈顶元素值，再将栈顶指针减 1</li>
<li>栈空条件：<code>S.top==-1</code>；栈满条件：<code>S.top==MaxSize-1</code>；栈长：<code>S.top+1</code></li>
</ul>
<h5 id="_40">共享栈<a class="headerlink" href="#_40" title="Permanent link">&para;</a></h5>
<p>利用栈底位置相对不变的特性，可让两个顺序栈共享一个一维数组空间，将两个栈的栈底分别设置在共享空间的两端，两个栈顶共享空间的中间延伸。</p>
<ul>
<li>
<p>两个栈的栈顶指针都指向栈顶元素</p>
</li>
<li>
<p><code>top0=-1</code>时 0 号栈为空，<code>top1=MaxSize</code>时<code>1</code>号栈为空</p>
</li>
<li>
<p><code>top1-top0==1</code>为栈满</p>
</li>
<li>
<p>当<code>0</code>号栈进栈时<code>top0</code>先加 1 再赋值，<code>1</code>号栈进栈时<code>top1</code>先减 1 再赋值；出栈是刚好相反</p>
</li>
</ul>
<h4 id="213">2.1.3 栈的链式存储结构<a class="headerlink" href="#213" title="Permanent link">&para;</a></h4>
<p>采用链式存储的栈称为<strong>链栈</strong>，链栈的优点是便于多个栈共享存储空间和提高其效率，且不存在栈满上溢的情况。这里规定链栈没有头结点，<code>Lhead</code>指向栈顶元素</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-23-1" name="__codelineno-23-1" href="#__codelineno-23-1"></a><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">Linknode</span><span class="p">{</span><span class="w"></span>
<a id="__codelineno-23-2" name="__codelineno-23-2" href="#__codelineno-23-2"></a><span class="w">    </span><span class="n">ElemType</span><span class="w"> </span><span class="n">data</span><span class="p">;</span><span class="c1">//数据域</span>
<a id="__codelineno-23-3" name="__codelineno-23-3" href="#__codelineno-23-3"></a><span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">Linknode</span><span class="w"> </span><span class="o">*</span><span class="n">next</span><span class="p">;</span><span class="c1">//指针域</span>
<a id="__codelineno-23-4" name="__codelineno-23-4" href="#__codelineno-23-4"></a><span class="p">}</span><span class="w"> </span><span class="o">*</span><span class="n">LiStack</span><span class="p">;</span><span class="c1">//栈类型定义</span>
</code></pre></div>
<h3 id="22">2.2 队列<a class="headerlink" href="#22" title="Permanent link">&para;</a></h3>
<h4 id="221">2.2.1 队列的基本概念<a class="headerlink" href="#221" title="Permanent link">&para;</a></h4>
<h5 id="_41">队列的定义<a class="headerlink" href="#_41" title="Permanent link">&para;</a></h5>
<ul>
<li>队列简称队，也是一种操作受限的线性表，只允许在表的一端进行插入，而在表的另一端进行删除。</li>
<li>向队列中插入元素称为<strong>入队</strong>或<strong>进队</strong></li>
<li>删除元素称为<strong>出队</strong>或<strong>离队</strong></li>
<li>操作的特性是先进先出</li>
</ul>
<h5 id="_42">队列常见的基本操作<a class="headerlink" href="#_42" title="Permanent link">&para;</a></h5>
<div class="highlight"><pre><span></span><code><a id="__codelineno-24-1" name="__codelineno-24-1" href="#__codelineno-24-1"></a><span class="n">InitQueue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Q</span><span class="p">)</span><span class="o">:</span><span class="n">初始化队列</span><span class="err">，</span><span class="n">构造一个空队列Q</span><span class="w"></span>
<a id="__codelineno-24-2" name="__codelineno-24-2" href="#__codelineno-24-2"></a><span class="n">QueueEmpty</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span><span class="o">:</span><span class="n">判队列空</span><span class="w"></span>
<a id="__codelineno-24-3" name="__codelineno-24-3" href="#__codelineno-24-3"></a><span class="n">EnQueue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Q</span><span class="p">,</span><span class="n">x</span><span class="p">)</span><span class="o">:</span><span class="n">入队</span><span class="err">，</span><span class="n">若队列Q非满</span><span class="err">，</span><span class="n">将x加入</span><span class="err">，</span><span class="n">使之成为新的队尾</span><span class="w"></span>
<a id="__codelineno-24-4" name="__codelineno-24-4" href="#__codelineno-24-4"></a><span class="n">DeQueue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Q</span><span class="p">,</span><span class="o">&amp;</span><span class="n">x</span><span class="p">)</span><span class="o">:</span><span class="n">出队</span><span class="err">，</span><span class="n">若队列Q非空</span><span class="err">，</span><span class="n">删除队头元素</span><span class="err">，</span><span class="n">并用x返回</span><span class="w"></span>
<a id="__codelineno-24-5" name="__codelineno-24-5" href="#__codelineno-24-5"></a><span class="n">GetHead</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span><span class="o">&amp;</span><span class="n">x</span><span class="p">)</span><span class="o">:</span><span class="n">读队头元素</span><span class="err">，</span><span class="n">若队列Q非空</span><span class="err">，</span><span class="n">则将队头元素赋值给x</span><span class="w"></span>
</code></pre></div>
<h4 id="222">2.2.2 队列的顺序存储结构<a class="headerlink" href="#222" title="Permanent link">&para;</a></h4>
<h5 id="_43">队列的顺序存储<a class="headerlink" href="#_43" title="Permanent link">&para;</a></h5>
<p>队列的顺序实现是指分配一块连续的存储单元存放队列中的元素，并附设两个指针：队头指针<code>front</code>指向队头元素，队尾指针<code>rear</code>指向队尾元素的下一个位置</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-25-1" name="__codelineno-25-1" href="#__codelineno-25-1"></a><span class="cp">#define MaxSize 50</span><span class="c1">//定义队列中元素的最大个数</span>
<a id="__codelineno-25-2" name="__codelineno-25-2" href="#__codelineno-25-2"></a><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="p">{</span><span class="w"></span>
<a id="__codelineno-25-3" name="__codelineno-25-3" href="#__codelineno-25-3"></a><span class="w">    </span><span class="n">ElemType</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="n">MaxSize</span><span class="p">];</span><span class="c1">//存放队列元素</span>
<a id="__codelineno-25-4" name="__codelineno-25-4" href="#__codelineno-25-4"></a><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">front</span><span class="p">,</span><span class="n">rear</span><span class="p">;</span><span class="c1">//队头指针和队尾指针</span>
<a id="__codelineno-25-5" name="__codelineno-25-5" href="#__codelineno-25-5"></a><span class="p">}</span><span class="w"> </span><span class="n">SqQueue</span><span class="p">;</span><span class="w"></span>
</code></pre></div>
<ul>
<li>初始状态：<code>Q.front==Q.rear==0</code></li>
<li>进队操作：队不满时，先送值到队尾元素，再将队尾指针加 1</li>
<li>出队操作：队不空时，先取队头元素值，再将队头指针加 1</li>
</ul>
<h5 id="_44">循环队列<a class="headerlink" href="#_44" title="Permanent link">&para;</a></h5>
<p>将顺序队列臆造为一个环状的空间，即把存储队列元素的表从逻辑上视为一个环，称为循环队列。当队首指针<code>Q.front=MaxSize-1</code>后，再前进一个位置就自动到 0，这可以利用除法取余运算<code>%</code>来实现</p>
<ul>
<li>初始状态：<code>Q.front=Q.rear=0</code></li>
<li>队首指针进 1：<code>Q.front=(Q.front+1)%MaxSize</code></li>
<li>队尾指针进 1：<code>Q.rear=(Q.rear+1)%MaxSize</code></li>
<li>队列长度：<code>(Q.rear+MaxSize-Q.front)%MaxSize</code></li>
<li>出队入队时：指针都按顺时针方向进 1</li>
</ul>
<p><strong>判断循环队列队空或队满的三种方式</strong></p>
<ol>
<li>
<p>牺牲一个单元来区分队空和队满，入队时少用一个队列单元，约定以 “队头指针在队尾指针的下一位置作为队满的标志”</p>
<blockquote>
<ul>
<li>队满条件：<code>(Q.rear+1)%MaxSize==Q.front</code></li>
<li>队空条件：<code>Q.front=Q.rear</code></li>
<li>队列中元素的个数：<code>(Q.rear-Q.front+MaxSize)%MaxSize</code></li>
</ul>
</blockquote>
</li>
<li>
<p>类型中增设表示元素个数的数据成员。</p>
<blockquote>
<ul>
<li>队空条件：<code>Q.size==0</code></li>
<li>队满条件：<code>Q.size==MaxSize</code></li>
</ul>
</blockquote>
</li>
<li>
<p>类型中增设<code>tag</code>数据成员，以区分是队满还是队空。</p>
<blockquote>
<ul>
<li><code>tag=0</code>时，若因删除导致<code>Q.front==Q.rear</code>, 则为队空</li>
<li><code>tag=1</code>时，若因插入导致<code>Q.front==Q.rear</code>, 则为队满</li>
</ul>
</blockquote>
</li>
</ol>
<h4 id="223">2.2.3 队列的链式存储结构<a class="headerlink" href="#223" title="Permanent link">&para;</a></h4>
<h5 id="_45">队列的链式存储<a class="headerlink" href="#_45" title="Permanent link">&para;</a></h5>
<p>队列的链式表示称为链队列，它实际是一个同时带有队头指针和队尾指针的单链表。头指针指向队头结点，尾指针指向队尾结点。</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-26-1" name="__codelineno-26-1" href="#__codelineno-26-1"></a><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="p">{</span><span class="c1">//链式队列结点</span>
<a id="__codelineno-26-2" name="__codelineno-26-2" href="#__codelineno-26-2"></a><span class="w">    </span><span class="n">ElemType</span><span class="w"> </span><span class="n">data</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-26-3" name="__codelineno-26-3" href="#__codelineno-26-3"></a><span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">LinkNdoe</span><span class="w"> </span><span class="o">*</span><span class="n">next</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-26-4" name="__codelineno-26-4" href="#__codelineno-26-4"></a><span class="p">}</span><span class="n">LinkNode</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-26-5" name="__codelineno-26-5" href="#__codelineno-26-5"></a><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="p">{</span><span class="c1">//链式队列</span>
<a id="__codelineno-26-6" name="__codelineno-26-6" href="#__codelineno-26-6"></a><span class="w">    </span><span class="n">LinkNode</span><span class="w"> </span><span class="o">*</span><span class="n">front</span><span class="p">,</span><span class="o">*</span><span class="n">rear</span><span class="p">;</span><span class="c1">//队列的队头和队尾指针</span>
<a id="__codelineno-26-7" name="__codelineno-26-7" href="#__codelineno-26-7"></a><span class="p">}</span><span class="n">LinkQueue</span><span class="p">;</span><span class="w"></span>
</code></pre></div>
<p>通常将链式队列设计成一个带头结点对的单链表，这样插入和删除就统一了</p>
<h4 id="224">2.2.4 双端队列<a class="headerlink" href="#224" title="Permanent link">&para;</a></h4>
<p>双端队列是指允许两端都可进行入队和出队操作的队列，其元素的逻辑结构仍是线性结构。将队列的两端分别称为前端和后端。</p>
<ul>
<li>输出受限的双端队列：允许在一端进行插入和删除，另一端只允许插入的双端队列</li>
<li>输入受限的双端队列：允许在一端进行插入和删除，另一端只允许删除的双端队列</li>
</ul>
<h3 id="23">2.3 栈和队列的应用<a class="headerlink" href="#23" title="Permanent link">&para;</a></h3>
<h5 id="_46">栈在括号匹配中的应用<a class="headerlink" href="#_46" title="Permanent link">&para;</a></h5>
<ul>
<li>初始设置一个空栈，顺序读入括号</li>
<li>若是右括号，则或者置于栈顶的最急迫期待得以消解，或者是不合法的情况</li>
<li>若是左括号，则作为一个新的更急迫的期待压入栈中</li>
<li>算法结束时，栈为空，否则括号序列不匹配</li>
</ul>
<h5 id="_47">栈在表达式求值中的应用<a class="headerlink" href="#_47" title="Permanent link">&para;</a></h5>
<h6 id="_48">后续表达式计算方式<a class="headerlink" href="#_48" title="Permanent link">&para;</a></h6>
<p>顺序扫描表达式的每一项，然后根据它的类型作出如下相应操作：若该项是操作数，则将其压入栈中；若该项是操作符<code>&lt;op&gt;</code>，则连续从栈中退出两个操作数<code>Y</code>和<code>X</code>，形成运算指令<code>X&lt;op&gt;Y</code>，并将计算结果重新压入栈中。当表达式的所有项扫描并处理完毕后，栈顶存放的就是最后的结果</p>
<h6 id="_49">中缀表达式转换为前缀或后缀表达式的手工做法<a class="headerlink" href="#_49" title="Permanent link">&para;</a></h6>
<ul>
<li>按照运算符的优先级对所有的运算单位加括号</li>
<li>转换为前缀或后缀表达式。前缀把运算符移动到对应的括号前面，后缀把运算符移动到对应的括号后面</li>
<li>把括号去掉</li>
</ul>
<h6 id="_50">中缀表达式转换为后缀表达式的算法思路<a class="headerlink" href="#_50" title="Permanent link">&para;</a></h6>
<ul>
<li>从左向右开始扫描中缀表达式</li>
<li>遇到数字时，加入后缀表达式</li>
<li>遇到运算符时</li>
<li>若为<code>(</code>, 入栈</li>
<li>若为<code>)</code>，则依次把栈中的运算符加入后缀表达式，直到出现<code>(</code>, 从栈中删除<code>(</code></li>
<li>若为除括号外的其他运算符，当其优先级高于除<code>(</code>外的栈顶运算符时，直接入栈。否则从栈顶开始，依次弹出比当前处理的运算符优先级高和优先级相等的运算符，直到一个比它优先级低的或遇到一个左括号为止。</li>
</ul>
<p><img alt="" src="../../images/%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A1%88%E4%BE%8B.jpg" /></p>
<h5 id="_51">栈在递归中的应用<a class="headerlink" href="#_51" title="Permanent link">&para;</a></h5>
<p>可以将递归算法转换为非递归算法。通常需要借助栈来实现这种转换</p>
<h5 id="_52">队列在层次遍历中的应用<a class="headerlink" href="#_52" title="Permanent link">&para;</a></h5>
<ol>
<li>根节点入队</li>
<li>若队空，则结束遍历；否则重复<code>3</code>操作</li>
<li>队列中第一个结点出队，并访问之。若其没有左孩子，则将左孩子入队，若其有左孩子，则将其右孩子入队，返回<code>2</code></li>
</ol>
<h5 id="_53">队列在计算机系统中的应用<a class="headerlink" href="#_53" title="Permanent link">&para;</a></h5>
<ul>
<li>解决主机与外部设备之间速度不匹配的问题</li>
<li>解决由多用户引起的资源竞争问题</li>
</ul>
<h3 id="24">2.4 特殊矩阵的压缩存储<a class="headerlink" href="#24" title="Permanent link">&para;</a></h3>
<h5 id="_54">数组的定义<a class="headerlink" href="#_54" title="Permanent link">&para;</a></h5>
<p><strong>数组</strong>是由 n 个相同类型的数据元素构成的有限序列，每个数据元素成为一个<strong>数据元素</strong>，每个元素在 n 个线性关系中的序号称为该元素的<strong>下标</strong>，下标的取值范围称为数组的<strong>维界</strong></p>
<p>数组是线性表的推广。一维数组可视为一个线性表；二维数组可视为其元素也是定长线性表的线性表。</p>
<h4 id="241">2.4.1 数组的存储结构<a class="headerlink" href="#241" title="Permanent link">&para;</a></h4>
<p><code>一维数组</code>：<span class="arithmatex">\(a[N]\)</span>
逻辑上连续存放，物理上（内存中）也连续存放
数组元素<span class="arithmatex">\(a[i]\)</span>的<code>物理地址=LOC+i*sizeof(ElemType)</code></p>
<p><code>二维数组</code>：<span class="arithmatex">\(a[N][M]\)</span>
逻辑上是n行n列的矩阵，物理上（内存中）是<code>行优先存储</code>和<code>列优先存储</code>的连续存放
<code>行优先存储</code>：数组元素<span class="arithmatex">\(a[i][j]\)</span>的<code>物理地址=LOC+(i*N+j)*sizeof(ElemType)</code>
<code>列优先存储</code>：数组元素<span class="arithmatex">\(a[i][j]\)</span>的<code>物理地址=LOC+(J*M+i)*sizeof(ElemType)</code></p>
<p>普通矩阵的存储可用二维数组存储。</p>
<h4 id="242">2.4.2 特殊矩阵的存储<a class="headerlink" href="#242" title="Permanent link">&para;</a></h4>
<p>①对称矩阵
②三角矩阵
③三对角矩阵
④稀疏矩阵</p>
<h5 id="_55">对称矩阵的压缩存储<a class="headerlink" href="#_55" title="Permanent link">&para;</a></h5>
<p><code>对称矩阵</code>：<span class="arithmatex">\(a_{i,j}=a_{j,i}\)</span>
方法：一维数组<span class="arithmatex">\(a[N]\)</span>只存主对角线+下三角区（或主对角线+上三角区）
存储数组的大小：<span class="arithmatex">\(N=\frac{n(n+1)}{2}\)</span>
数组下标范围：<span class="arithmatex">\(0\)</span> ~ <span class="arithmatex">\(\frac{n(n+1)}{2}-1\)</span>
<code>行优先存储</code>：数组下标：<span class="arithmatex">\(k=\begin{cases} \frac{i(i-1)}{2}+j-1, \quad i \geq j(下三角区和主对角线元素)\\ \frac{j(j-1)}{2}+i-1, \quad i&lt;j(上三角区元素a_{i,j}=a_{j,i}) \end{cases}\)</span></p>
<h5 id="_56">三角矩阵的压缩存储<a class="headerlink" href="#_56" title="Permanent link">&para;</a></h5>
<p>①<code>下三角矩阵</code>：除主对角线和下三角区，其余的元素都相等
方法：一维数组<span class="arithmatex">\(a[N]\)</span>存主对角线+下三角区，在最后多加一个位置存常其余相等元素
存储数组的大小：<span class="arithmatex">\(N=\frac{n(n+1)}{2}+1\)</span>
数组下标范围：<span class="arithmatex">\(0\)</span> ~ <span class="arithmatex">\(\frac{n(n+1)}{2}\)</span>
<code>行优先存储</code>：数组下标：<span class="arithmatex">\(k=\begin{cases} \frac{i(i-1)}{2}+j-1, \quad i \geq j(下三角区和主对角线元素)\\ \frac{n(n+1)}{2}, \quad\quad\quad\quad i&lt;j(上三角区元素) \end{cases}\)</span></p>
<p>②<code>上三角矩阵</code>：除主对角线和上三角区，其余的元素都相等
方法：一维数组<span class="arithmatex">\(a[N]\)</span>存主对角线+下三角区，在最后多加一个位置存常其余相等元素
存储数组的大小：<span class="arithmatex">\(N=\frac{n(n+1)}{2}+1\)</span>
数组下标范围：<span class="arithmatex">\(0\)</span> ~ <span class="arithmatex">\(\frac{n(n+1)}{2}\)</span>
<code>行优先存储</code>：数组下标：<span class="arithmatex">\(k=\begin{cases} \frac{(i-1)(2n-i+2)}{2}+(j-i), \quad i \geq j(下三角区和主对角线元素)\\ \frac{n(n+1)}{2}, \quad\quad\quad\quad\quad\quad\quad~ i&lt;j(上三角区元素) \end{cases}\)</span></p>
<h5 id="_57">三对角矩阵的压缩存储<a class="headerlink" href="#_57" title="Permanent link">&para;</a></h5>
<p><code>三对角矩阵</code>，又称<code>带状矩阵</code>。
方法：一维数组<span class="arithmatex">\(a[N]\)</span>存带状部分
存储数组的大小：<span class="arithmatex">\(N=3n-3+1\)</span>
数组下标范围：<span class="arithmatex">\(0\)</span> ~ <span class="arithmatex">\(3n-3\)</span>
<code>行优先存储</code>：
<code>i和j计算数组下标k</code>：<span class="arithmatex">\(k=2i+j-3\)</span>
<code>数组下标k计算i和j</code>：<span class="arithmatex">\(i=\lceil (k+2)/3 \rceil\)</span>，<span class="arithmatex">\(j=k-2i+3\)</span></p>
<h5 id="_58">稀疏矩阵的压缩存储<a class="headerlink" href="#_58" title="Permanent link">&para;</a></h5>
<p><code>稀疏矩阵</code>：非零元素的个数远远少于矩阵元素的个数。</p>
<p><code>方法一：顺序存储——三元组&lt;行，列，值&gt;</code>，注：行列从1开始</p>
<table>
<thead>
<tr>
<th>i（行）</th>
<th>j（列）</th>
<th>v（值）</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>3</td>
<td>4</td>
</tr>
<tr>
<td>1</td>
<td>6</td>
<td>5</td>
</tr>
<tr>
<td>2</td>
<td>2</td>
<td>3</td>
</tr>
</tbody>
</table>
<p><code>方法二：链式存储——十字链表法</code></p>
<p><img alt="1637932175187" src="../../images/1637932175187.png" /></p>
<h3 id="25">2.5 广义表<a class="headerlink" href="#25" title="Permanent link">&para;</a></h3>
<h4 id="251">2.5.1 定义<a class="headerlink" href="#251" title="Permanent link">&para;</a></h4>
<ul>
<li><span class="arithmatex">\(A=()\)</span> ：广义表 A 是一个空表</li>
<li><span class="arithmatex">\(B=(d, e)\)</span> ：广义表 B 的元素全是原子 d 和 e</li>
<li><span class="arithmatex">\(C = (b, B, (c, d))\)</span> ：广义表 C 的元素分别是 原子 b、广义表 B、广义表 (c, d)</li>
</ul>
<h4 id="252">2.5.2 广义表的长度<a class="headerlink" href="#252" title="Permanent link">&para;</a></h4>
<ul>
<li><span class="arithmatex">\(A = ()\)</span> ：长度为 0</li>
<li><span class="arithmatex">\(B = (d, e)\)</span> ：长度为 2</li>
<li><span class="arithmatex">\(C = (b, B, (c, d))\)</span> ：长度为 3</li>
</ul>
<h4 id="253">2.5.3 广义表的深度<a class="headerlink" href="#253" title="Permanent link">&para;</a></h4>
<p>嵌套几个括号深度就是几</p>
<ul>
<li><span class="arithmatex">\(A = ()\)</span> ：深度为 1</li>
<li><span class="arithmatex">\(B = (d, e)\)</span> ：深度为 1</li>
<li><span class="arithmatex">\(C = (a, B)\)</span> ：深度为 2</li>
<li><span class="arithmatex">\(D = (a, (d, e))\)</span> ：深度为 2</li>
<li><span class="arithmatex">\(E = ((a, D), c)\)</span> ：深度为 4</li>
</ul>
<h4 id="254">2.5.4 广义表获取表头和表尾<a class="headerlink" href="#254" title="Permanent link">&para;</a></h4>
<ul>
<li>
<p><span class="arithmatex">\(A = (a, b, c)\)</span></p>
<ul>
<li>GetHead(A) = a</li>
<li>GetTail(A) = (b, c)</li>
</ul>
</li>
<li>
<p><span class="arithmatex">\(B = ()\)</span></p>
<ul>
<li>GetHead(B) = NULL</li>
<li>GetTail(B) = ()</li>
</ul>
</li>
<li>
<p><span class="arithmatex">\(C = (a, b)\)</span></p>
<ul>
<li>GetHead(C) = a</li>
<li>GetTail(C) = (b)</li>
</ul>
</li>
</ul>
<h4 id="255">2.5.5 存储结构<a class="headerlink" href="#255" title="Permanent link">&para;</a></h4>
<p><img alt="" src="../../images/v2-009abd78a500db269dc2cef760fb46d7_r.png" /></p>
<p>最后一个是一个无限深度的广义表<span class="arithmatex">\(B = (a, B)\)</span></p>
<h4 id="256">2.5.6 例题<a class="headerlink" href="#256" title="Permanent link">&para;</a></h4>
<p>已知广义表 <span class="arithmatex">\(L = (a, (b, c), (d, e))\)</span>使用取头函数 GetHead 和取尾函数 GetTail 求出原子 e</p>
<p><code>e = GetHead(GetTail(GetHead(GetTail(GetTail(L))))</code></p>
<h2 id="3">3. 串<a class="headerlink" href="#3" title="Permanent link">&para;</a></h2>
<h3 id="31">3.1 串的定义和实现<a class="headerlink" href="#31" title="Permanent link">&para;</a></h3>
<h4 id="_59">串的定义<a class="headerlink" href="#_59" title="Permanent link">&para;</a></h4>
<ul>
<li>
<p><strong>串</strong>（String）是由零个或多个字符组成的有限序列。记为 <span class="arithmatex">\(S='a_1a_2...a_n'​\)</span></p>
</li>
<li>
<p>串中任意多个连续的字符组成的子序列称为该串的<strong>子串</strong></p>
</li>
<li>
<p>包含子串的串称为<strong>主串</strong></p>
</li>
<li>
<p>由一个或多个空格组成的串称为<strong>空格串</strong></p>
</li>
</ul>
<h4 id="_60">串的存储结构<a class="headerlink" href="#_60" title="Permanent link">&para;</a></h4>
<h5 id="_61">定长顺序存储表示<a class="headerlink" href="#_61" title="Permanent link">&para;</a></h5>
<p>用一组地址连续的存储单元存储串值的字符序列</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-27-1" name="__codelineno-27-1" href="#__codelineno-27-1"></a><span class="cp">#define MAXLEN 255</span><span class="c1">//预定义最大串长为255</span>
<a id="__codelineno-27-2" name="__codelineno-27-2" href="#__codelineno-27-2"></a><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="p">{</span><span class="w"></span>
<a id="__codelineno-27-3" name="__codelineno-27-3" href="#__codelineno-27-3"></a><span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="n">ch</span><span class="p">[</span><span class="n">MAXLEN</span><span class="p">];</span><span class="c1">//每个分量存储一个字符</span>
<a id="__codelineno-27-4" name="__codelineno-27-4" href="#__codelineno-27-4"></a><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">length</span><span class="p">;</span><span class="c1">//串的实际长度</span>
<a id="__codelineno-27-5" name="__codelineno-27-5" href="#__codelineno-27-5"></a><span class="p">}</span><span class="n">SString</span><span class="p">;</span><span class="w"></span>
</code></pre></div>
<h4 id="_62">堆分配存储表示<a class="headerlink" href="#_62" title="Permanent link">&para;</a></h4>
<p>堆分配存储仍然以一组地址连续的存储单元存放串值的字符序列，但他们的存储空间是在程序执行过程中动态分配得到的</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-28-1" name="__codelineno-28-1" href="#__codelineno-28-1"></a><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="p">{</span><span class="w"></span>
<a id="__codelineno-28-2" name="__codelineno-28-2" href="#__codelineno-28-2"></a><span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">ch</span><span class="p">;</span><span class="c1">//按串分配存储区，ch指向串的基地址</span>
<a id="__codelineno-28-3" name="__codelineno-28-3" href="#__codelineno-28-3"></a><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">length</span><span class="p">;</span><span class="c1">//串的长度</span>
<a id="__codelineno-28-4" name="__codelineno-28-4" href="#__codelineno-28-4"></a><span class="p">}</span><span class="n">HString</span><span class="p">;</span><span class="w"></span>
</code></pre></div>
<p>在<code>C</code>语言中，存在一个称之为<strong>堆</strong>的自由存储区，并用<code>malloc()</code>和<code>free()</code>函数来完成动态存储管理</p>
<p>利用<code>malloc()</code>为每个新产生的串分配一块实际串长所需要的存储空间，若分配成功，则返回一个指向起始地址的指针，称为串的基地址，这个串由<code>ch</code>指针来指示; 若分配失败，则返回<code>NULL</code>。已分配的空间可用<code>free()</code>释放掉</p>
<h4 id="_63">块链存储表示<a class="headerlink" href="#_63" title="Permanent link">&para;</a></h4>
<p>类似于线性表的链式存储结构，也可采用链表方式存储串值。由于串的特殊性，在具体实现时，每个节点即可以存放一个字符，也可以存放多个字符，每个节点称为<strong>块</strong>，整个链表称为<strong>块链结构</strong></p>
<h4 id="_64">串的基本操作<a class="headerlink" href="#_64" title="Permanent link">&para;</a></h4>
<div class="highlight"><pre><span></span><code><a id="__codelineno-29-1" name="__codelineno-29-1" href="#__codelineno-29-1"></a><span class="n">StrAssign</span><span class="p">(</span><span class="o">&amp;</span><span class="n">T</span><span class="p">,</span><span class="n">chars</span><span class="p">)</span><span class="o">:</span><span class="n">赋值操作</span><span class="err">。</span><span class="n">把串T赋值为chars</span><span class="w"></span>
<a id="__codelineno-29-2" name="__codelineno-29-2" href="#__codelineno-29-2"></a><span class="n">StrCopy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">T</span><span class="p">,</span><span class="n">S</span><span class="p">)</span><span class="o">:</span><span class="n">复制操作</span><span class="err">。</span><span class="n">由串S复制得到串T</span><span class="w"></span>
<a id="__codelineno-29-3" name="__codelineno-29-3" href="#__codelineno-29-3"></a><span class="n">StrEmpty</span><span class="p">(</span><span class="n">S</span><span class="p">)</span><span class="o">:</span><span class="n">判空操作</span><span class="err">。</span><span class="n">若S为空串</span><span class="err">，</span><span class="n">则返回TRUE</span><span class="err">，</span><span class="n">否则返回FALSE</span><span class="w"></span>
<a id="__codelineno-29-4" name="__codelineno-29-4" href="#__codelineno-29-4"></a><span class="n">StrCompare</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">T</span><span class="p">)</span><span class="o">:</span><span class="n">比较操作</span><span class="err">，</span><span class="n">S</span><span class="o">&gt;</span><span class="n">T则返回值</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">;</span><span class="n">k若S</span><span class="o">=</span><span class="n">T</span><span class="err">，</span><span class="n">返回0</span><span class="err">，</span><span class="n">否则返回</span><span class="o">&lt;</span><span class="mi">0</span><span class="w"></span>
<a id="__codelineno-29-5" name="__codelineno-29-5" href="#__codelineno-29-5"></a><span class="n">StrLength</span><span class="p">(</span><span class="n">S</span><span class="p">)</span><span class="o">:</span><span class="n">求串长</span><span class="w"></span>
<a id="__codelineno-29-6" name="__codelineno-29-6" href="#__codelineno-29-6"></a><span class="n">SubString</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Sub</span><span class="p">,</span><span class="n">S</span><span class="p">,</span><span class="n">pos</span><span class="p">,</span><span class="n">len</span><span class="p">)</span><span class="o">:</span><span class="n">求子串</span><span class="err">。</span><span class="n">用Sub返回串S的第pos个字符起长度为len的子串</span><span class="w"></span>
<a id="__codelineno-29-7" name="__codelineno-29-7" href="#__codelineno-29-7"></a><span class="n">Concat</span><span class="p">(</span><span class="o">&amp;</span><span class="n">T</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">)</span><span class="o">:</span><span class="n">串联接</span><span class="err">。</span><span class="n">用T返回S1和S2的联接</span><span class="w"></span>
<a id="__codelineno-29-8" name="__codelineno-29-8" href="#__codelineno-29-8"></a><span class="n">Index</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">T</span><span class="p">)</span><span class="o">:</span><span class="n">定位操作</span><span class="w"></span>
<a id="__codelineno-29-9" name="__codelineno-29-9" href="#__codelineno-29-9"></a><span class="n">ClearString</span><span class="p">(</span><span class="o">&amp;</span><span class="n">S</span><span class="p">)</span><span class="o">:</span><span class="n">清空</span><span class="w"></span>
<a id="__codelineno-29-10" name="__codelineno-29-10" href="#__codelineno-29-10"></a><span class="n">DestroyString</span><span class="p">(</span><span class="o">&amp;</span><span class="n">S</span><span class="p">)</span><span class="o">:</span><span class="n">销毁串</span><span class="w"></span>
</code></pre></div>
<h3 id="32">3.2 串的模式匹配<a class="headerlink" href="#32" title="Permanent link">&para;</a></h3>
<h4 id="bf">简单的模式匹配算法 BF<a class="headerlink" href="#bf" title="Permanent link">&para;</a></h4>
<p>子串的定位操作通常称为串的<strong>模式匹配</strong>，它求的是子串在主串中的位置</p>
<h4 id="kmp">KMP 算法<a class="headerlink" href="#kmp" title="Permanent link">&para;</a></h4>
<h4 id="_65">基础概念<a class="headerlink" href="#_65" title="Permanent link">&para;</a></h4>
<ul>
<li>前缀：除最后一个字符以外，字符串的所有头部子串</li>
<li>后缀：除第一个字符外，字符串的所有尾部子串</li>
<li>部分匹配值<code>PM</code>：字符串的前缀和后缀的最长相等前后缀长度</li>
</ul>
<h4 id="_66">算法原理<a class="headerlink" href="#_66" title="Permanent link">&para;</a></h4>
<table>
<thead>
<tr>
<th>编号</th>
<th>描述</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>S</code></td>
<td>字符</td>
<td>a</td>
<td>b</td>
<td>c</td>
<td>a</td>
<td>c</td>
</tr>
<tr>
<td><code>PM</code></td>
<td>子串右移位数=已匹配的字符数-对应的部分匹配值：<code>Move=(j-1)-PM[j-1]</code></td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td><code>next</code>（<code>PM</code>右移一位）</td>
<td>子串右移位数：<code>Move=(j-1)-next[j]</code>，子串的比较指针回退到：<code>j=next[j]+1</code></td>
<td>-1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td><code>next=next+1</code></td>
<td>在子串的第j个字符与主串发生失配时，则跳到子串的<code>next[j]</code>位置重新与主串当前位置进行比较</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>2</td>
</tr>
</tbody>
</table>
<h4 id="next">next[] 推导方法<a class="headerlink" href="#next" title="Permanent link">&para;</a></h4>
<ul>
<li>
<div class="arithmatex">\[next[j]=\begin{cases} 0 &amp; j=1 \\ max\{k|1&lt;k&lt;j且'p_1...p_{k-1}'='p_{j-k+1}...p_{j-1}'\}&amp; 当此集合不空时(next[ ]推导公式) \\ 1&amp; 其他情况 \end{cases}\]</div>
</li>
<li>
<p>next 的推导步骤，<code>next[j]=k</code>, 求<code>next[j+1]</code></p>
</li>
</ul>
<p><code>next[j]=k</code>表明 <span class="arithmatex">\(p_1...p_{k-1}=p_{j-k+1}...p_{j-1}​\)</span></p>
<ol>
<li>若 <span class="arithmatex">\(p_k=p_j\)</span>​, 则<code>next[j+1]=next[j]+1</code></li>
<li>若 <span class="arithmatex">\(p_k \neq p_j\)</span>​。用前缀 <span class="arithmatex">\(p_1...p_k\)</span> ​去跟后缀 <span class="arithmatex">\(p_{j-k+1}...p_j\)</span>​匹配，则当 <span class="arithmatex">\(p_k \neq p_j\)</span>​是应将 <span class="arithmatex">\(p_1...p_k\)</span>​向右滑动至以第<code>next[k]</code>个字符与 <span class="arithmatex">\(p_j\)</span>​比较，如果 <span class="arithmatex">\(p_{next[k]}\)</span>​与 <span class="arithmatex">\(p_j\)</span>​还是不匹配, 那么需要寻找长度更短的相等前后缀，下一步继续用 <span class="arithmatex">\(P_{next[next[k]]}\)</span>​与 <span class="arithmatex">\(p_j\)</span>​比较, 直到找到<code>k'=next[next...[k]]</code>满足条件 <span class="arithmatex">\('p_1...p_{k'}'='p_{j-k'+1}...p_{j}'\)</span>​, 则<code>next[j+1]=k'+1</code></li>
</ol>
<h4 id="_67">说明<a class="headerlink" href="#_67" title="Permanent link">&para;</a></h4>
<ul>
<li>为什么<code>next[1]=0</code>：当模式串中的第一个字符与主串的的当前字符比较不相等时，<code>next[1]=0</code>, 表示模式串应该右移一位，主串当前指针后移一位，再和模式串的第一个字符进行比较</li>
<li>为什么要取<code>max{k}</code>：当主串的第<code>i</code>个字符与模式串的第<code>j</code>个字符失配时，主串<code>i</code>不回溯，则假定模式串的第<code>k</code>个字符与主串的第<code>i</code>个字符比较,<code>k</code>应满足条件 <span class="arithmatex">\(1&lt;k&lt;j 且'p_1...p_{k-1}'='p_{j-k+1}...p_{j-1}'\)</span>​。为了不使向右移动丢失可能的匹配，右移距离应该取最小，由于 <span class="arithmatex">\(j-k\)</span> 表示右移距离，所以取 <span class="arithmatex">\(max\{k\}\)</span>。</li>
</ul>
<div class="highlight"><pre><span></span><code><a id="__codelineno-30-1" name="__codelineno-30-1" href="#__codelineno-30-1"></a><span class="c1">//next数组的建立</span>
<a id="__codelineno-30-2" name="__codelineno-30-2" href="#__codelineno-30-2"></a><span class="kt">int</span><span class="p">[]</span><span class="w"> </span><span class="n">getNext</span><span class="p">(</span><span class="n">String</span><span class="w"> </span><span class="n">ps</span><span class="p">){</span><span class="w"></span>
<a id="__codelineno-30-3" name="__codelineno-30-3" href="#__codelineno-30-3"></a><span class="w">    </span><span class="kt">char</span><span class="p">[]</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ps</span><span class="p">.</span><span class="n">toCharArray</span><span class="p">();</span><span class="w"></span>
<a id="__codelineno-30-4" name="__codelineno-30-4" href="#__codelineno-30-4"></a><span class="w">    </span><span class="kt">int</span><span class="p">[]</span><span class="w"> </span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="kt">int</span><span class="p">[</span><span class="n">p</span><span class="p">.</span><span class="n">length</span><span class="p">];</span><span class="w"></span>
<a id="__codelineno-30-5" name="__codelineno-30-5" href="#__codelineno-30-5"></a><span class="w">    </span><span class="n">next</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-30-6" name="__codelineno-30-6" href="#__codelineno-30-6"></a><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-30-7" name="__codelineno-30-7" href="#__codelineno-30-7"></a><span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">length</span><span class="p">){</span><span class="w"></span>
<a id="__codelineno-30-8" name="__codelineno-30-8" href="#__codelineno-30-8"></a><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">k</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">p</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">p</span><span class="p">[</span><span class="n">k</span><span class="p">])</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<a id="__codelineno-30-9" name="__codelineno-30-9" href="#__codelineno-30-9"></a><span class="w">            </span><span class="n">next</span><span class="p">[</span><span class="o">++</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">++</span><span class="n">k</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-30-10" name="__codelineno-30-10" href="#__codelineno-30-10"></a><span class="w">        </span><span class="p">}</span><span class="k">else</span><span class="p">{</span><span class="w"></span>
<a id="__codelineno-30-11" name="__codelineno-30-11" href="#__codelineno-30-11"></a><span class="w">            </span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">next</span><span class="p">[</span><span class="n">k</span><span class="p">];</span><span class="w"></span>
<a id="__codelineno-30-12" name="__codelineno-30-12" href="#__codelineno-30-12"></a><span class="w">        </span><span class="p">}</span><span class="w"></span>
<a id="__codelineno-30-13" name="__codelineno-30-13" href="#__codelineno-30-13"></a><span class="w">    </span><span class="p">}</span><span class="w"></span>
<a id="__codelineno-30-14" name="__codelineno-30-14" href="#__codelineno-30-14"></a>
<a id="__codelineno-30-15" name="__codelineno-30-15" href="#__codelineno-30-15"></a><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">next</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-30-16" name="__codelineno-30-16" href="#__codelineno-30-16"></a><span class="p">}</span><span class="w"></span>
</code></pre></div>
<p><div class="highlight"><pre><span></span><code><a id="__codelineno-31-1" name="__codelineno-31-1" href="#__codelineno-31-1"></a><span class="kt">int</span><span class="w"> </span><span class="nf">Index</span><span class="p">(</span><span class="n">SString</span><span class="w"> </span><span class="n">S</span><span class="p">,</span><span class="w"> </span><span class="n">SString</span><span class="w"> </span><span class="n">T</span><span class="p">){</span><span class="w"></span>
<a id="__codelineno-31-2" name="__codelineno-31-2" href="#__codelineno-31-2"></a><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-31-3" name="__codelineno-31-3" href="#__codelineno-31-3"></a><span class="w">    </span><span class="k">while</span><span class="p">(</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">S</span><span class="p">.</span><span class="n">length</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">j</span><span class="o">&lt;=</span><span class="n">T</span><span class="p">.</span><span class="n">length</span><span class="p">){</span><span class="w">  </span><span class="c1">//跳出循环情况：j&gt;T.length,匹配成功</span>
<a id="__codelineno-31-4" name="__codelineno-31-4" href="#__codelineno-31-4"></a><span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">S</span><span class="p">.</span><span class="n">ch</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">==</span><span class="n">T</span><span class="p">.</span><span class="n">ch</span><span class="p">[</span><span class="n">i</span><span class="p">]){</span><span class="w">                        </span><span class="c1">//i&gt;S.length,匹配失败</span>
<a id="__codelineno-31-5" name="__codelineno-31-5" href="#__codelineno-31-5"></a><span class="w">            </span><span class="o">++</span><span class="n">i</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">j</span><span class="p">;</span><span class="w">          </span><span class="c1">//继续比较后面的字符</span>
<a id="__codelineno-31-6" name="__codelineno-31-6" href="#__codelineno-31-6"></a><span class="w">        </span><span class="p">}</span><span class="k">else</span><span class="p">{</span><span class="w">                 </span><span class="c1">//匹配失败，指针i不变，j后退，匹配下一个</span>
<a id="__codelineno-31-7" name="__codelineno-31-7" href="#__codelineno-31-7"></a><span class="w">            </span><span class="n">j</span><span class="o">=</span><span class="n">next</span><span class="p">[</span><span class="n">j</span><span class="p">];</span><span class="w">            </span>
<a id="__codelineno-31-8" name="__codelineno-31-8" href="#__codelineno-31-8"></a><span class="w">        </span><span class="p">}</span><span class="w"></span>
<a id="__codelineno-31-9" name="__codelineno-31-9" href="#__codelineno-31-9"></a><span class="w">    </span><span class="p">}</span><span class="w"></span>
<a id="__codelineno-31-10" name="__codelineno-31-10" href="#__codelineno-31-10"></a><span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">j</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">T</span><span class="p">.</span><span class="n">length</span><span class="p">){</span><span class="w">          </span><span class="c1">//j&gt;T.length,匹配成功</span>
<a id="__codelineno-31-11" name="__codelineno-31-11" href="#__codelineno-31-11"></a><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">i</span><span class="o">-</span><span class="n">T</span><span class="p">.</span><span class="n">length</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-31-12" name="__codelineno-31-12" href="#__codelineno-31-12"></a><span class="w">    </span><span class="p">}</span><span class="k">else</span><span class="p">{</span><span class="w"></span>
<a id="__codelineno-31-13" name="__codelineno-31-13" href="#__codelineno-31-13"></a><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-31-14" name="__codelineno-31-14" href="#__codelineno-31-14"></a><span class="w">    </span><span class="p">}</span><span class="w"></span>
<a id="__codelineno-31-15" name="__codelineno-31-15" href="#__codelineno-31-15"></a><span class="p">}</span><span class="w"></span>
</code></pre></div>
<img alt="" src="../../images/KMP%E6%A1%88%E4%BE%8B.jpg" /></p>
<h5 id="kmp_1">KMP算法的时间复杂度：<a class="headerlink" href="#kmp_1" title="Permanent link">&para;</a></h5>
<p>设主串长度为n，模式串长度为m，则</p>
<p>最好情况：每次匹配第一个字符就匹配失败，直到最后才匹配成功，循环n次，<code>最好时间复杂度</code>=O(n)</p>
<p>最坏情况：到最后也没找到，主串移动n个元素，模式串移动m个元素，<code>最坏时间复杂度</code>=O(m+n)</p>
<h4 id="kmp_2">KMP 算法的进一步优化<a class="headerlink" href="#kmp_2" title="Permanent link">&para;</a></h4>
<p><code>nextval[]</code>, 如果出现了 <span class="arithmatex">\(p_j=p_{next[j]}\)</span>​, 则将<code>next[j]</code>修正为<code>next[ next[j] ]</code>, 直到两者不相等</p>
<p><img alt="" src="../../images/KMP%E6%94%B9%E8%BF%9B%E6%A1%88%E4%BE%8B.jpg" /></p>
<h2 id="4">4. 树<a class="headerlink" href="#4" title="Permanent link">&para;</a></h2>
<h3 id="41">4.1 树<a class="headerlink" href="#41" title="Permanent link">&para;</a></h3>
<h4 id="411">4.1.1 树的定义<a class="headerlink" href="#411" title="Permanent link">&para;</a></h4>
<ul>
<li>有且仅有一个特定的称为根的结点</li>
<li>当 <span class="arithmatex">\(n&gt;1\)</span>时，其余结点可分为 <span class="arithmatex">\(m\)</span> 个互不相交的有限集 <span class="arithmatex">\(T_1,T_2,...,T_m\)</span>​, 其中每个集合本身又是一棵树，并且称为根的子树</li>
</ul>
<h4 id="412">4.1.2 基本术语<a class="headerlink" href="#412" title="Permanent link">&para;</a></h4>
<ol>
<li>祖先、子孙、双亲、孩子、兄弟</li>
<li>结点的度、树的度</li>
<li>分支结点、叶子节点</li>
<li>节点的深度、高度、层次</li>
<li>有序树和无序树</li>
<li>路径和路径长度</li>
<li>森林</li>
</ol>
<h4 id="413">4.1.3 树的性质<a class="headerlink" href="#413" title="Permanent link">&para;</a></h4>
<ul>
<li>树中的节点数等于所有结点的度数之和加 1</li>
<li>总结点数 = <span class="arithmatex">\(n_0+n_1+n_2+...+n_m\)</span>​</li>
<li>总分支数 = <span class="arithmatex">\(1n_1+2n_2+...+mn_m\)</span>​</li>
<li>总结点数 = 总分支数 + 1</li>
</ul>
<h3 id="42">4.2 二叉树<a class="headerlink" href="#42" title="Permanent link">&para;</a></h3>
<h4 id="421">4.2.1 二叉树的定义及其主要特性<a class="headerlink" href="#421" title="Permanent link">&para;</a></h4>
<h5 id="_68">定义<a class="headerlink" href="#_68" title="Permanent link">&para;</a></h5>
<p>每个节点至多只有两棵子树，并且二叉树的子树有左右之分，不能颠倒</p>
<h5 id="_69">几个特殊的二叉树<a class="headerlink" href="#_69" title="Permanent link">&para;</a></h5>
<ul>
<li>满二叉树：一棵高度为 h，且含有 2 h − 1 2^h-1 2h−1 个结点的二叉树称为满二叉树，除叶子结点外每个结点度数为 2</li>
<li>完全二叉树：每个结点都与同等高度的满二叉树有同样的编号<ul>
<li>若 <span class="arithmatex">\(i\leq \lfloor n/2 \rfloor\)</span>, 则结点<code>i</code>为分支结点，否则为叶子结点</li>
<li>当 <span class="arithmatex">\(2i\leq n\)</span> 时，结点<code>i</code>的左孩子编号为 <span class="arithmatex">\(2i\)</span>, 否则无左孩子</li>
<li>当 <span class="arithmatex">\(2i+1\leq n\)</span>时，结点<code>i</code>的右孩子编号为 <span class="arithmatex">\(2i+1\)</span>, 否则无右孩子</li>
<li>结点<code>i</code>所在的层次为 <span class="arithmatex">\(\lfloor log_2i \rfloor\)</span></li>
<li>叶子结点只可能在层次最大的两层上出现，对于最大层次中的叶子结点，都依次排列在该层最左边的位置上</li>
<li>若有度为 1 的节点，则只可能有一个，且只有左孩子没有右孩子</li>
<li>若 n 为奇数，则每个分支结点都有左孩子和右孩子；若 n 为偶数，则编号最大的分支结点只有左孩子，没有右孩子</li>
</ul>
</li>
<li>二叉排序树：左子树上所有节点的关键字小于根节点的关键字；右子树上的所有节点的关键字均大于根节点的关键字</li>
<li>平衡二叉树：树上任一节点的左子树和右子树的深度之差不超过 1</li>
</ul>
<h5 id="_70">二叉树的性质<a class="headerlink" href="#_70" title="Permanent link">&para;</a></h5>
<ul>
<li>非空二叉树上的叶子结点数等于度为 2 的结点数 + 1，即 <span class="arithmatex">\(n_0=n_2+1\)</span></li>
</ul>
<h4 id="422">4.2.2 二叉树的存储结构<a class="headerlink" href="#422" title="Permanent link">&para;</a></h4>
<h5 id="_71">顺序存储结构<a class="headerlink" href="#_71" title="Permanent link">&para;</a></h5>
<p>将完全二叉树上编号为<code>i</code>的结点元素存储在一维数组下标为<code>i-1</code>的分量中</p>
<p><strong>注意</strong>：这种存储结构建议从数组下标 1 开始存储树中的结点，若从数组下标 0 开始存储，则计算其孩子结点时与之前描述的计算公式不一致，在书写程序时需要注意。</p>
<h4 id="_72">链式存储结构<a class="headerlink" href="#_72" title="Permanent link">&para;</a></h4>
<table>
<thead>
<tr>
<th><code>lchild</code></th>
<th><code>data</code></th>
<th><code>rchild</code></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<div class="highlight"><pre><span></span><code><a id="__codelineno-32-1" name="__codelineno-32-1" href="#__codelineno-32-1"></a><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">BiTNode</span><span class="p">{</span><span class="w"></span>
<a id="__codelineno-32-2" name="__codelineno-32-2" href="#__codelineno-32-2"></a><span class="w">    </span><span class="n">ElemType</span><span class="w"> </span><span class="n">data</span><span class="p">;</span><span class="c1">//数据域</span>
<a id="__codelineno-32-3" name="__codelineno-32-3" href="#__codelineno-32-3"></a><span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">BiTNode</span><span class="w"> </span><span class="o">*</span><span class="n">lchild</span><span class="p">,</span><span class="o">*</span><span class="n">rchild</span><span class="p">;</span><span class="c1">//左、右孩子指针</span>
<a id="__codelineno-32-4" name="__codelineno-32-4" href="#__codelineno-32-4"></a><span class="p">}</span><span class="n">BiTNode</span><span class="p">,</span><span class="o">*</span><span class="n">BiTree</span><span class="p">;</span><span class="w"></span>
</code></pre></div>
<p>n 个结点的二叉链表中，含有<code>n+1</code>个空链域</p>
<h3 id="43">4.3 二叉树的遍历和线索二叉树<a class="headerlink" href="#43" title="Permanent link">&para;</a></h3>
<h4 id="431">4.3.1 二叉树的遍历<a class="headerlink" href="#431" title="Permanent link">&para;</a></h4>
<p>二叉树的遍历是按照某条搜索路径访问树中每个结点，使得每个结点均被访问一次，而且仅被访问一次。共有先序遍历（NLR）、中序（LNR）、后续（LRN）三中遍历方法</p>
<h5 id="_73">递归遍历算法<a class="headerlink" href="#_73" title="Permanent link">&para;</a></h5>
<div class="highlight"><pre><span></span><code><a id="__codelineno-33-1" name="__codelineno-33-1" href="#__codelineno-33-1"></a><span class="kt">void</span><span class="w"> </span><span class="nf">PreOrder</span><span class="p">(</span><span class="n">BiTree</span><span class="w"> </span><span class="n">T</span><span class="p">){</span><span class="c1">//PreOrder-先序、InOrder-中序、PostOrder-后序</span>
<a id="__codelineno-33-2" name="__codelineno-33-2" href="#__codelineno-33-2"></a><span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">T</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">){</span><span class="w"></span>
<a id="__codelineno-33-3" name="__codelineno-33-3" href="#__codelineno-33-3"></a><span class="w">        </span><span class="n">visit</span><span class="p">(</span><span class="n">T</span><span class="p">);</span><span class="c1">//访问根结点</span>
<a id="__codelineno-33-4" name="__codelineno-33-4" href="#__codelineno-33-4"></a><span class="w">        </span><span class="n">PreOrder</span><span class="p">(</span><span class="n">T</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="p">);</span><span class="c1">//遍历访问左子树</span>
<a id="__codelineno-33-5" name="__codelineno-33-5" href="#__codelineno-33-5"></a><span class="w">        </span><span class="n">PreOrder</span><span class="p">(</span><span class="n">T</span><span class="o">-&gt;</span><span class="n">rchlid</span><span class="p">);</span><span class="c1">//遍历访问右子树</span>
<a id="__codelineno-33-6" name="__codelineno-33-6" href="#__codelineno-33-6"></a><span class="w">    </span><span class="p">}</span><span class="w"></span>
<a id="__codelineno-33-7" name="__codelineno-33-7" href="#__codelineno-33-7"></a><span class="p">}</span><span class="w"></span>
</code></pre></div>
<h5 id="_74">非递归遍历算法<a class="headerlink" href="#_74" title="Permanent link">&para;</a></h5>
<ul>
<li>先序遍历</li>
</ul>
<div class="highlight"><pre><span></span><code><a id="__codelineno-34-1" name="__codelineno-34-1" href="#__codelineno-34-1"></a><span class="kt">void</span><span class="w"> </span><span class="nf">PreOrder2</span><span class="p">(</span><span class="n">BiTree</span><span class="w"> </span><span class="n">T</span><span class="p">){</span><span class="w"></span>
<a id="__codelineno-34-2" name="__codelineno-34-2" href="#__codelineno-34-2"></a><span class="w">    </span><span class="n">InitStack</span><span class="p">(</span><span class="n">S</span><span class="p">);</span><span class="n">BiTree</span><span class="w"> </span><span class="n">p</span><span class="o">=</span><span class="n">T</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-34-3" name="__codelineno-34-3" href="#__codelineno-34-3"></a><span class="w">    </span><span class="k">while</span><span class="p">(</span><span class="n">p</span><span class="o">||!</span><span class="n">IsEmpty</span><span class="p">(</span><span class="n">S</span><span class="p">)){</span><span class="w"></span>
<a id="__codelineno-34-4" name="__codelineno-34-4" href="#__codelineno-34-4"></a><span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="p">){</span><span class="w"></span>
<a id="__codelineno-34-5" name="__codelineno-34-5" href="#__codelineno-34-5"></a><span class="w">            </span><span class="n">visit</span><span class="p">(</span><span class="n">p</span><span class="p">);</span><span class="n">Push</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">p</span><span class="p">);</span><span class="w"></span>
<a id="__codelineno-34-6" name="__codelineno-34-6" href="#__codelineno-34-6"></a><span class="w">            </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-34-7" name="__codelineno-34-7" href="#__codelineno-34-7"></a><span class="w">        </span><span class="p">}</span><span class="w"></span>
<a id="__codelineno-34-8" name="__codelineno-34-8" href="#__codelineno-34-8"></a><span class="w">        </span><span class="k">else</span><span class="p">{</span><span class="w"></span>
<a id="__codelineno-34-9" name="__codelineno-34-9" href="#__codelineno-34-9"></a><span class="w">            </span><span class="n">Pop</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">p</span><span class="p">);</span><span class="w"></span>
<a id="__codelineno-34-10" name="__codelineno-34-10" href="#__codelineno-34-10"></a><span class="w">            </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-34-11" name="__codelineno-34-11" href="#__codelineno-34-11"></a><span class="w">        </span><span class="p">}</span><span class="w"></span>
<a id="__codelineno-34-12" name="__codelineno-34-12" href="#__codelineno-34-12"></a><span class="w">    </span><span class="p">}</span><span class="w"></span>
<a id="__codelineno-34-13" name="__codelineno-34-13" href="#__codelineno-34-13"></a><span class="p">}</span><span class="w"></span>
</code></pre></div>
<ul>
<li>中序遍历</li>
</ul>
<div class="highlight"><pre><span></span><code><a id="__codelineno-35-1" name="__codelineno-35-1" href="#__codelineno-35-1"></a><span class="kt">void</span><span class="w"> </span><span class="nf">Inorder2</span><span class="p">(</span><span class="n">BiTree</span><span class="w"> </span><span class="n">T</span><span class="p">){</span><span class="w"></span>
<a id="__codelineno-35-2" name="__codelineno-35-2" href="#__codelineno-35-2"></a><span class="w">    </span><span class="n">InitStack</span><span class="p">(</span><span class="n">S</span><span class="p">);</span><span class="n">BiTree</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T</span><span class="p">;</span><span class="c1">//初始化S，p是遍历指针</span>
<a id="__codelineno-35-3" name="__codelineno-35-3" href="#__codelineno-35-3"></a><span class="w">    </span><span class="k">while</span><span class="p">(</span><span class="n">p</span><span class="o">||!</span><span class="n">IsEmpty</span><span class="p">(</span><span class="n">S</span><span class="p">)){</span><span class="w"></span>
<a id="__codelineno-35-4" name="__codelineno-35-4" href="#__codelineno-35-4"></a><span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="p">){</span><span class="c1">//一路向左</span>
<a id="__codelineno-35-5" name="__codelineno-35-5" href="#__codelineno-35-5"></a><span class="w">            </span><span class="n">Push</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">p</span><span class="p">);</span><span class="c1">//当前结点入栈</span>
<a id="__codelineno-35-6" name="__codelineno-35-6" href="#__codelineno-35-6"></a><span class="w">            </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="p">;</span><span class="c1">//左孩子不空，一直往左走</span>
<a id="__codelineno-35-7" name="__codelineno-35-7" href="#__codelineno-35-7"></a><span class="w">        </span><span class="p">}</span><span class="w"></span>
<a id="__codelineno-35-8" name="__codelineno-35-8" href="#__codelineno-35-8"></a><span class="w">        </span><span class="k">else</span><span class="p">{</span><span class="c1">//出栈，并转向出栈结点的左子树</span>
<a id="__codelineno-35-9" name="__codelineno-35-9" href="#__codelineno-35-9"></a><span class="w">            </span><span class="n">Pop</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">p</span><span class="p">);</span><span class="n">visit</span><span class="p">(</span><span class="n">p</span><span class="p">);</span><span class="c1">//栈顶元素出栈，访问出栈结点</span>
<a id="__codelineno-35-10" name="__codelineno-35-10" href="#__codelineno-35-10"></a><span class="w">            </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="p">;</span><span class="c1">//向右子树走</span>
<a id="__codelineno-35-11" name="__codelineno-35-11" href="#__codelineno-35-11"></a><span class="w">        </span><span class="p">}</span><span class="w"></span>
<a id="__codelineno-35-12" name="__codelineno-35-12" href="#__codelineno-35-12"></a><span class="w">    </span><span class="p">}</span><span class="w"></span>
<a id="__codelineno-35-13" name="__codelineno-35-13" href="#__codelineno-35-13"></a>
<a id="__codelineno-35-14" name="__codelineno-35-14" href="#__codelineno-35-14"></a><span class="p">}</span><span class="w"></span>
</code></pre></div>
<ul>
<li>后序遍历</li>
</ul>
<div class="highlight"><pre><span></span><code><a id="__codelineno-36-1" name="__codelineno-36-1" href="#__codelineno-36-1"></a><span class="kt">void</span><span class="w"> </span><span class="nf">PostOrder</span><span class="p">(</span><span class="n">BiTree</span><span class="w"> </span><span class="n">T</span><span class="p">){</span><span class="w"></span>
<a id="__codelineno-36-2" name="__codelineno-36-2" href="#__codelineno-36-2"></a><span class="w">    </span><span class="n">InitStack</span><span class="p">(</span><span class="n">S</span><span class="p">);</span><span class="w"></span>
<a id="__codelineno-36-3" name="__codelineno-36-3" href="#__codelineno-36-3"></a><span class="w">    </span><span class="n">P</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-36-4" name="__codelineno-36-4" href="#__codelineno-36-4"></a><span class="w">    </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-36-5" name="__codelineno-36-5" href="#__codelineno-36-5"></a><span class="w">    </span><span class="k">while</span><span class="p">(</span><span class="n">p</span><span class="o">||!</span><span class="n">IsEmpty</span><span class="p">(</span><span class="n">S</span><span class="p">)){</span><span class="w"></span>
<a id="__codelineno-36-6" name="__codelineno-36-6" href="#__codelineno-36-6"></a><span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="p">){</span><span class="w">                    </span><span class="c1">//走到最左边</span>
<a id="__codelineno-36-7" name="__codelineno-36-7" href="#__codelineno-36-7"></a><span class="w">            </span><span class="n">push</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">p</span><span class="p">);</span><span class="w"></span>
<a id="__codelineno-36-8" name="__codelineno-36-8" href="#__codelineno-36-8"></a><span class="w">            </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-36-9" name="__codelineno-36-9" href="#__codelineno-36-9"></a><span class="w">        </span><span class="p">}</span><span class="w"></span>
<a id="__codelineno-36-10" name="__codelineno-36-10" href="#__codelineno-36-10"></a><span class="w">        </span><span class="k">else</span><span class="p">{</span><span class="w">                            </span><span class="c1">//向右</span>
<a id="__codelineno-36-11" name="__codelineno-36-11" href="#__codelineno-36-11"></a><span class="w">            </span><span class="n">GetTop</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">p</span><span class="p">);</span><span class="w">                </span><span class="c1">//读栈顶结点（非出栈）</span>
<a id="__codelineno-36-12" name="__codelineno-36-12" href="#__codelineno-36-12"></a><span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="o">&amp;&amp;</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="o">!=</span><span class="n">r</span><span class="p">)</span><span class="w">    </span><span class="c1">//若右子树存在，且未被访问过</span>
<a id="__codelineno-36-13" name="__codelineno-36-13" href="#__codelineno-36-13"></a><span class="w">                </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="p">;</span><span class="w">            </span><span class="c1">//转向右</span>
<a id="__codelineno-36-14" name="__codelineno-36-14" href="#__codelineno-36-14"></a><span class="w">            </span><span class="k">else</span><span class="p">{</span><span class="w">                        </span><span class="c1">//否则，弹出结点并访问</span>
<a id="__codelineno-36-15" name="__codelineno-36-15" href="#__codelineno-36-15"></a><span class="w">                </span><span class="n">pop</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">p</span><span class="p">);</span><span class="w">                </span><span class="c1">//将结点弹出</span>
<a id="__codelineno-36-16" name="__codelineno-36-16" href="#__codelineno-36-16"></a><span class="w">                </span><span class="n">visit</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span><span class="w">            </span><span class="c1">//访问该结点</span>
<a id="__codelineno-36-17" name="__codelineno-36-17" href="#__codelineno-36-17"></a><span class="w">                </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="p">;</span><span class="w">                    </span><span class="c1">//记录最近访问过的结点</span>
<a id="__codelineno-36-18" name="__codelineno-36-18" href="#__codelineno-36-18"></a><span class="w">                </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w">                </span><span class="c1">//结点访问完，重置p指针</span>
<a id="__codelineno-36-19" name="__codelineno-36-19" href="#__codelineno-36-19"></a><span class="w">            </span><span class="p">}</span><span class="w"></span>
<a id="__codelineno-36-20" name="__codelineno-36-20" href="#__codelineno-36-20"></a><span class="w">        </span><span class="p">}</span><span class="c1">//else</span>
<a id="__codelineno-36-21" name="__codelineno-36-21" href="#__codelineno-36-21"></a><span class="w">    </span><span class="p">}</span><span class="c1">//while</span>
<a id="__codelineno-36-22" name="__codelineno-36-22" href="#__codelineno-36-22"></a><span class="p">}</span><span class="w"></span>
</code></pre></div>
<ul>
<li>层次遍历</li>
</ul>
<div class="highlight"><pre><span></span><code><a id="__codelineno-37-1" name="__codelineno-37-1" href="#__codelineno-37-1"></a><span class="kt">void</span><span class="w"> </span><span class="nf">LevelOrder</span><span class="p">(</span><span class="n">BiTree</span><span class="w"> </span><span class="n">T</span><span class="p">){</span><span class="w"></span>
<a id="__codelineno-37-2" name="__codelineno-37-2" href="#__codelineno-37-2"></a><span class="w">    </span><span class="n">InitQueue</span><span class="p">(</span><span class="n">Q</span><span class="p">);</span><span class="w"></span>
<a id="__codelineno-37-3" name="__codelineno-37-3" href="#__codelineno-37-3"></a><span class="w">    </span><span class="n">BiTree</span><span class="w"> </span><span class="n">p</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-37-4" name="__codelineno-37-4" href="#__codelineno-37-4"></a><span class="w">    </span><span class="n">EnQueue</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span><span class="n">T</span><span class="p">);</span><span class="c1">//将根结点入队</span>
<a id="__codelineno-37-5" name="__codelineno-37-5" href="#__codelineno-37-5"></a><span class="w">    </span><span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">IsEmpty</span><span class="p">(</span><span class="n">Q</span><span class="p">)){</span><span class="w"></span>
<a id="__codelineno-37-6" name="__codelineno-37-6" href="#__codelineno-37-6"></a><span class="w">        </span><span class="n">DeQueue</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span><span class="n">p</span><span class="p">);</span><span class="w"></span>
<a id="__codelineno-37-7" name="__codelineno-37-7" href="#__codelineno-37-7"></a><span class="w">        </span><span class="n">visit</span><span class="p">(</span><span class="n">p</span><span class="p">);</span><span class="w"></span>
<a id="__codelineno-37-8" name="__codelineno-37-8" href="#__codelineno-37-8"></a><span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span><span class="n">EnQueue</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="p">);</span><span class="w"></span>
<a id="__codelineno-37-9" name="__codelineno-37-9" href="#__codelineno-37-9"></a><span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span><span class="n">EnQueue</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="p">);</span><span class="w"></span>
<a id="__codelineno-37-10" name="__codelineno-37-10" href="#__codelineno-37-10"></a><span class="w">    </span><span class="p">}</span><span class="w"></span>
<a id="__codelineno-37-11" name="__codelineno-37-11" href="#__codelineno-37-11"></a><span class="p">}</span><span class="w"></span>
</code></pre></div>
<h5 id="_75">由遍历序列构造二叉树<a class="headerlink" href="#_75" title="Permanent link">&para;</a></h5>
<p>由二叉树中序遍历结果和前序、后序、层次中的一个组合，就可唯一确定一棵二叉树
<img alt="" src="../../images/%E5%85%88%E5%BA%8F%E5%92%8C%E4%B8%AD%E5%BA%8F%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91%E6%A1%88%E4%BE%8B.jpg" /></p>
<h4 id="432">4.3.2 线索二叉树<a class="headerlink" href="#432" title="Permanent link">&para;</a></h4>
<h5 id="_76">线索二叉树的基本概念<a class="headerlink" href="#_76" title="Permanent link">&para;</a></h5>
<p>在含<code>n</code>个结点的二叉树中，有<code>n+1</code>个空指针。引入线索二叉树正是为了加快查找结点前驱和后继的速度。</p>
<p>规定：若无左子树，令<code>lchild</code>指向其前驱结点；若无右子树，令<code>rchild</code>指向其后继结点</p>
<table>
<thead>
<tr>
<th><code>lchild</code></th>
<th><code>ltag</code></th>
<th><code>data</code></th>
<th><code>rtag</code></th>
<th><code>rchild</code></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p><span class="arithmatex">\(ltag= \begin{cases} 0,&amp;lchild域指示结点的左孩子\\ 1，&amp;lchild域指示结点的前驱 \end{cases}\)</span></p>
<p><span class="arithmatex">\(rtag=\begin{cases} 0,&amp;rchild域指示结点的右孩子\\ 1，&amp;rchild域指示结点的后继 \end{cases}\)</span></p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-38-1" name="__codelineno-38-1" href="#__codelineno-38-1"></a><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">ThreadNode</span><span class="p">{</span><span class="w"></span>
<a id="__codelineno-38-2" name="__codelineno-38-2" href="#__codelineno-38-2"></a><span class="w">    </span><span class="n">ElemType</span><span class="w"> </span><span class="n">data</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-38-3" name="__codelineno-38-3" href="#__codelineno-38-3"></a><span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">ThreadNode</span><span class="w"> </span><span class="o">*</span><span class="n">lchild</span><span class="p">,</span><span class="o">*</span><span class="n">rchild</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-38-4" name="__codelineno-38-4" href="#__codelineno-38-4"></a><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">ltag</span><span class="p">,</span><span class="n">rtag</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-38-5" name="__codelineno-38-5" href="#__codelineno-38-5"></a><span class="p">}</span><span class="n">ThreadNode</span><span class="p">,</span><span class="o">*</span><span class="n">ThreadTree</span><span class="p">;</span><span class="w"></span>
</code></pre></div>
<h5 id="_77">中序线索二叉树的构造<a class="headerlink" href="#_77" title="Permanent link">&para;</a></h5>
<p>线索化的实质就是遍历一次二叉树</p>
<h5 id="_78">中序线索二叉树的遍历<a class="headerlink" href="#_78" title="Permanent link">&para;</a></h5>
<p>在对其进行遍历时，只要先找到序列中的第一个节点，然后依次找结点的后继，直至后继为空。在中序线索二叉树中找结点后继的规律是：若其右标志为 “1”，则右链为线索，指示其后继，否则遍历右子树中第一个访问的结点为其后继。</p>
<h5 id="_79">先序线索二叉树和后序线索二叉树<a class="headerlink" href="#_79" title="Permanent link">&para;</a></h5>
<p>后序线索二叉树上找后继时需要知道结点双亲，即需采用带标志域的三叉链表作为存储结构。</p>
<h3 id="44">4.4 树、森林<a class="headerlink" href="#44" title="Permanent link">&para;</a></h3>
<h4 id="441">4.4.1 树的存储结构<a class="headerlink" href="#441" title="Permanent link">&para;</a></h4>
<p><code>顺序存储</code>和<code>链式存储</code></p>
<p>方法：
- <code>双亲表示法</code>（顺序存储）
- <code>孩子表示法</code>（顺序+链式存储）
- <code>孩子兄弟表示法</code>（链式存储）</p>
<h5 id="4411">4.4.1.1 双亲表示法（顺序存储）<a class="headerlink" href="#4411" title="Permanent link">&para;</a></h5>
<p><img alt="" src="../../images/20200205124743184.jpg" /></p>
<p>双亲表示法：<code>顺序存储</code>结点数据，结点中保存父结点在数组中的下标
采用一组连续空间来存储每个结点，同时在每个结点中增设一个伪指针，指示其双亲结点在数组中的位置。</p>
<p>根节点的下标为 0，其伪指针域为<code>-1</code></p>
<p>该存储结构利用了每个结点只有唯一双亲对的性质，可以很快的得到每个结点的双亲结点，但求结点的孩子需要遍历整个结构。</p>
<p><code>优点</code>：找父节点方便。
<code>缺点</code>：找孩子不方便。</p>
<p><code>注</code>：双亲表示法与二叉树的顺序存储不一样，双亲表示法也可表示二叉树</p>
<h6 id="_80">类型描述<a class="headerlink" href="#_80" title="Permanent link">&para;</a></h6>
<p><code>结点</code>包括<code>数据</code>和<code>父亲下标</code>，
<code>树</code>包括<code>结点数组</code>和<code>结点个数</code></p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-39-1" name="__codelineno-39-1" href="#__codelineno-39-1"></a><span class="cp">#define MAX_TREE_SIZE 100         </span><span class="c1">//树中最多结点数</span>
<a id="__codelineno-39-2" name="__codelineno-39-2" href="#__codelineno-39-2"></a><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="p">{</span><span class="w">                   </span><span class="c1">//树的结点定义</span>
<a id="__codelineno-39-3" name="__codelineno-39-3" href="#__codelineno-39-3"></a><span class="w">    </span><span class="n">ElemType</span><span class="w"> </span><span class="n">data</span><span class="p">;</span><span class="w">                </span><span class="c1">//数据元素</span>
<a id="__codelineno-39-4" name="__codelineno-39-4" href="#__codelineno-39-4"></a><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">parent</span><span class="p">;</span><span class="w">                   </span><span class="c1">//双亲位置域</span>
<a id="__codelineno-39-5" name="__codelineno-39-5" href="#__codelineno-39-5"></a><span class="p">}</span><span class="n">PTNode</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-39-6" name="__codelineno-39-6" href="#__codelineno-39-6"></a><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="p">{</span><span class="w">                   </span><span class="c1">//树的类型定义</span>
<a id="__codelineno-39-7" name="__codelineno-39-7" href="#__codelineno-39-7"></a><span class="w">    </span><span class="n">PTNode</span><span class="w"> </span><span class="n">nodes</span><span class="p">[</span><span class="n">MAX_TREE_SIZE</span><span class="p">];</span><span class="w">  </span><span class="c1">//双亲表示</span>
<a id="__codelineno-39-8" name="__codelineno-39-8" href="#__codelineno-39-8"></a><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w">                        </span><span class="c1">//结点数</span>
<a id="__codelineno-39-9" name="__codelineno-39-9" href="#__codelineno-39-9"></a><span class="p">}</span><span class="n">PTree</span><span class="p">;</span><span class="w"></span>
</code></pre></div>
<h6 id="_81">增加一个结点<a class="headerlink" href="#_81" title="Permanent link">&para;</a></h6>
<p>新增元素，无需按逻辑次序存储，可以放到删除结点留下的存储空间里</p>
<h6 id="_82">删除一个结点<a class="headerlink" href="#_82" title="Permanent link">&para;</a></h6>
<p>方案一：数据取出，双亲指针改为-1</p>
<p>方案二：用存储空间中最后一个存的结点把要删的结点覆盖</p>
<h6 id="_83">查找一个结点<a class="headerlink" href="#_83" title="Permanent link">&para;</a></h6>
<p>找父结点方便、找孩子不方便。</p>
<p>空数据导致遍历慢。</p>
<h5 id="4412">4.4.1.2 孩子表示法（顺序+链式存储）<a class="headerlink" href="#4412" title="Permanent link">&para;</a></h5>
<p><img alt="" src="../../images/2020020513261515.png" /></p>
<p>孩子表示法：<code>顺序存储</code>结点数据，结点中保存孩子<code>链表</code>头指针（<code>链式存储</code>）</p>
<p><code>优点</code>：找孩子方便。
<code>缺点</code>：找父节点不方便。</p>
<h6 id="_84">类型描述<a class="headerlink" href="#_84" title="Permanent link">&para;</a></h6>
<p><code>孩子结点</code>包括<code>孩子下标</code>和<code>下一个孩子指针</code>，
<code>数组</code>包括<code>数据</code>和<code>孩子结点</code>，
<code>树</code>包括<code>数组</code>和<code>数组元素（结点）个数</code>及<code>根的下标</code></p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-40-1" name="__codelineno-40-1" href="#__codelineno-40-1"></a><span class="cp">#define MAX_TREE_SIZE 100         </span><span class="c1">//树中最多结点数</span>
<a id="__codelineno-40-2" name="__codelineno-40-2" href="#__codelineno-40-2"></a><span class="k">struct</span><span class="w"> </span><span class="nc">CTNode</span><span class="p">{</span><span class="w"></span>
<a id="__codelineno-40-3" name="__codelineno-40-3" href="#__codelineno-40-3"></a><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">child</span><span class="p">;</span><span class="w">                    </span><span class="c1">//孩子结点在数组中的位置</span>
<a id="__codelineno-40-4" name="__codelineno-40-4" href="#__codelineno-40-4"></a><span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">CTNode</span><span class="w"> </span><span class="o">*</span><span class="n">next</span><span class="p">;</span><span class="w">          </span><span class="c1">//下一个孩子</span>
<a id="__codelineno-40-5" name="__codelineno-40-5" href="#__codelineno-40-5"></a><span class="p">};</span><span class="w"></span>
<a id="__codelineno-40-6" name="__codelineno-40-6" href="#__codelineno-40-6"></a><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="p">{</span><span class="w"></span>
<a id="__codelineno-40-7" name="__codelineno-40-7" href="#__codelineno-40-7"></a><span class="w">    </span><span class="n">ElemType</span><span class="w"> </span><span class="n">data</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-40-8" name="__codelineno-40-8" href="#__codelineno-40-8"></a><span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">CTNode</span><span class="o">*</span><span class="w"> </span><span class="n">firstchild</span><span class="p">;</span><span class="w">    </span><span class="c1">//第一个孩子</span>
<a id="__codelineno-40-9" name="__codelineno-40-9" href="#__codelineno-40-9"></a><span class="p">}</span><span class="n">CTBox</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-40-10" name="__codelineno-40-10" href="#__codelineno-40-10"></a><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="p">{</span><span class="w"></span>
<a id="__codelineno-40-11" name="__codelineno-40-11" href="#__codelineno-40-11"></a><span class="w">    </span><span class="n">CTBox</span><span class="w"> </span><span class="n">nodes</span><span class="p">[</span><span class="n">MAX_TREE_SIZE</span><span class="p">];</span><span class="w"></span>
<a id="__codelineno-40-12" name="__codelineno-40-12" href="#__codelineno-40-12"></a><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">r</span><span class="p">;</span><span class="w">                     </span><span class="c1">//结点数和根的位置</span>
<a id="__codelineno-40-13" name="__codelineno-40-13" href="#__codelineno-40-13"></a><span class="p">}</span><span class="n">CTree</span><span class="p">;</span><span class="w"></span>
</code></pre></div>
<h6 id="_85">增加一个结点<a class="headerlink" href="#_85" title="Permanent link">&para;</a></h6>
<p>新增元素，父结点后新增一个孩子结点，数组中加一个数组元素</p>
<h6 id="_86">删除一个结点<a class="headerlink" href="#_86" title="Permanent link">&para;</a></h6>
<p>父结点后的链表中将此结点删除</p>
<p>数组中：
- ①若此结点后无链表，则直接删除
- ②若此结点后有链表，再处理子树</p>
<h6 id="_87">查找一个结点<a class="headerlink" href="#_87" title="Permanent link">&para;</a></h6>
<p>按图一行一行遍历</p>
<p>找孩子结点方便，找父结点不方便</p>
<h5 id="4413">4.4.1.3 孩子兄弟表示法（顺序+链式存储）<a class="headerlink" href="#4413" title="Permanent link">&para;</a></h5>
<p><img alt="" src="../../images/453_cc517c2353eb55fee933453aec89c3d5.png" /></p>
<p>孩子兄弟表示法：用<code>二叉链表</code>存储<code>树</code>——<code>两个指针</code>：<code>第一个孩子</code>和<code>右兄弟</code></p>
<p>用此方法存储的树，形态上和<code>二叉树</code>类似</p>
<h6 id="_88">类型描述<a class="headerlink" href="#_88" title="Permanent link">&para;</a></h6>
<p>由二叉树的链式存储（二叉链表）改变而来</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-41-1" name="__codelineno-41-1" href="#__codelineno-41-1"></a><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">CSNode</span><span class="p">{</span><span class="w"></span>
<a id="__codelineno-41-2" name="__codelineno-41-2" href="#__codelineno-41-2"></a><span class="w">    </span><span class="n">Elemtype</span><span class="w"> </span><span class="n">data</span><span class="p">;</span><span class="w">                   </span><span class="c1">//数据域</span>
<a id="__codelineno-41-3" name="__codelineno-41-3" href="#__codelineno-41-3"></a><span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">CSTNode</span><span class="w"> </span><span class="o">*</span><span class="n">firstchild</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">nextsibling</span><span class="p">;</span><span class="w"> </span><span class="c1">//第一个孩子和右兄弟指针</span>
<a id="__codelineno-41-4" name="__codelineno-41-4" href="#__codelineno-41-4"></a><span class="p">}</span><span class="n">CSTNode</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">CSTree</span><span class="p">;</span><span class="w"></span>
</code></pre></div>
<h5 id="442">4.4.2 树、森林与二叉树的转化<a class="headerlink" href="#442" title="Permanent link">&para;</a></h5>
<h6 id="_89">树转换为二叉树<a class="headerlink" href="#_89" title="Permanent link">&para;</a></h6>
<ul>
<li>
<p>规则：<strong>左孩子右兄弟</strong>。每个结点左指针指向它的第一个孩子，右指针指向它在树中的相邻右兄弟</p>
</li>
<li>
<p>画法：</p>
<ul>
<li>
<ol>
<li>在兄弟结点之间加一连线；</li>
</ol>
</li>
<li>
<ol>
<li>对每个结点，只保留它与第一个孩子的连线，而与其他孩子的连线全部抹掉；</li>
</ol>
</li>
<li>
<ol>
<li>以树为轴心，顺时针旋转 45°</li>
</ol>
</li>
</ul>
</li>
<li>
<p>特点：根无右子树</p>
</li>
<li><img alt="1637759667705" src="../../images/1637759667705.png" /></li>
</ul>
<h6 id="_90">森林转换二叉树<a class="headerlink" href="#_90" title="Permanent link">&para;</a></h6>
<ul>
<li>规则：先将森林中的每棵树转换为二叉树；把第二棵树的根作为第一课树根的右兄弟，以此类推</li>
<li>画法：<ul>
<li>
<ol>
<li>森林中的每棵树转换为相应的二叉树 </li>
</ol>
</li>
<li>
<ol>
<li>每棵树的根也可视为兄弟关系，在每棵树的根之间加一根连线；</li>
</ol>
</li>
<li>
<ol>
<li>以第一棵树的根为轴心顺时针旋转 45°</li>
</ol>
</li>
</ul>
</li>
<li>特点：森林中每棵树的根节点从第二个开始依次连接到前一棵树的根的右孩子，因此最后一棵树的根节点的右指针为空。另外，每个非终端节点，其所有孩子结点在转换后，最后一个孩子的右指针也为空。</li>
</ul>
<p><img alt="1637759667694" src="../../images/1637759667694.png" /></p>
<h6 id="_91">二叉树转换为森林<a class="headerlink" href="#_91" title="Permanent link">&para;</a></h6>
<p>若二叉树非空，则二叉树的根及其左子树为第一棵树的二叉树形式，故将根的右链断开。二叉树根的右子树又可视为由除第一棵树外的森林转换后的二叉树。
<img alt="1637759667683" src="../../images/1637759667683.jpg" /> </p>
<h4 id="443">4.4.3 树和森林的遍历<a class="headerlink" href="#443" title="Permanent link">&para;</a></h4>
<h5 id="_92">树的遍历<a class="headerlink" href="#_92" title="Permanent link">&para;</a></h5>
<ul>
<li>先根遍历</li>
<li>后根遍历</li>
</ul>
<h5 id="_93">森林的遍历<a class="headerlink" href="#_93" title="Permanent link">&para;</a></h5>
<ul>
<li>
<p>先序遍历森林</p>
<ul>
<li>访问森林中第一棵树的根节点</li>
<li>先序遍历第一棵树的根节点的子树森林</li>
<li>先序遍历除去第一棵树后剩余的树构成的森林</li>
</ul>
</li>
<li>
<p>中序遍历森林（又称后根遍历）</p>
<ul>
<li>中序遍历森林中第一课树的根节点的子树森林</li>
<li>访问第一课树的根结点</li>
<li>中序遍历除去第一棵树后剩余的树构成的森林</li>
</ul>
</li>
<li>
<p>树和森林的遍历与二叉树遍历的对应关系</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>树</th>
<th>森林</th>
<th>二叉树</th>
</tr>
</thead>
<tbody>
<tr>
<td>先根遍历</td>
<td>先序遍历</td>
<td>先序遍历</td>
</tr>
<tr>
<td>后根遍历</td>
<td>中序遍历</td>
<td>中序遍历</td>
</tr>
</tbody>
</table>
<h3 id="45">4.5 树与二叉树的应用<a class="headerlink" href="#45" title="Permanent link">&para;</a></h3>
<h4 id="451-bst">4.5.1 二叉排序树 BST<a class="headerlink" href="#451-bst" title="Permanent link">&para;</a></h4>
<h5 id="_94">二叉排序树的定义<a class="headerlink" href="#_94" title="Permanent link">&para;</a></h5>
<p>左子树上所有节点的关键字小于根节点的关键字；右子树上的所有节点的关键字均大于根节点的关键字</p>
<h5 id="_95">二叉排序树的查找、插入、构造<a class="headerlink" href="#_95" title="Permanent link">&para;</a></h5>
<h5 id="_96">二叉排序树的剔除<a class="headerlink" href="#_96" title="Permanent link">&para;</a></h5>
<ul>
<li>若被删除结点<code>z</code>是叶子结点，则直接删除</li>
<li>若结点<code>z</code>只有一棵左子树或右子树，则让<code>z</code>的子树成为<code>z</code>父节点的子树，替代<code>z</code>的位置</li>
<li>若结点<code>z</code>有左、右两棵子树，则令<code>z</code>的直接后继替代<code>z</code>，然后从二叉排序树中删去这个直接后继，这样就转换成了上面的两种情况
<img alt="" src="../../images/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E7%9A%84%E5%88%A0%E9%99%A4.jpg" /></li>
</ul>
<h5 id="_97">二叉排序树的查找效率分析<a class="headerlink" href="#_97" title="Permanent link">&para;</a></h5>
<ul>
<li><span class="arithmatex">\(O(log_2n)\)</span>（平衡二叉树）~ <span class="arithmatex">\(O(n)\)</span>(链表)</li>
<li><span class="arithmatex">\(ASL_a\)</span>​: 平均查找长度</li>
</ul>
<h4 id="452">4.5.2 平衡二叉树<a class="headerlink" href="#452" title="Permanent link">&para;</a></h4>
<h5 id="_98">定义<a class="headerlink" href="#_98" title="Permanent link">&para;</a></h5>
<p>任意结点的左右子树高度差的绝对值不超过 1 的二叉排序树</p>
<p><img alt="img" src="../../images/805461-20160127214903223-1113949071.jpg" /></p>
<h5 id="_99">二叉排序树的插入<a class="headerlink" href="#_99" title="Permanent link">&para;</a></h5>
<ul>
<li>①LL：在A的<code>左孩子的左子树</code>中插入导致A的不平衡，将A的<code>左孩子右上旋</code>。
  <img alt="" src="../../images/LL%E5%B9%B3%E8%A1%A1%E6%97%8B%E8%BD%AC.png" /></li>
<li>②RR：在A的<code>右孩子的右子树</code>中插入导致A的不平衡，将A的<code>右孩子左上旋</code>。
  <img alt="" src="../../images/RR%E5%B9%B3%E8%A1%A1%E6%97%8B%E8%BD%AC.jpg" /></li>
<li>③LR：在A的<code>左孩子的右子树</code>中插入导致A的不平衡，将A的<code>左孩子的右孩子，先左上旋再右上旋</code>。
  <img alt="" src="../../images/LR%E5%B9%B3%E8%A1%A1%E6%97%8B%E8%BD%AC.png" /></li>
<li>④RL：在A的<code>右孩子的左子树</code>中插入导致A的不平衡，将A的<code>右孩子的左孩子，先右上旋再左上旋</code>。
  <img alt="" src="../../images/RL%E5%B9%B3%E8%A1%A1%E6%97%8B%E8%BD%AC.png" /></li>
</ul>
<p><img alt="" src="../../images/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9E%84%E9%80%A0%E6%A1%88%E4%BE%8B.jpg" /></p>
<h5 id="_100">平衡二叉树的查找<a class="headerlink" href="#_100" title="Permanent link">&para;</a></h5>
<ul>
<li>含有 n 个结点的平衡二叉树的最大深度为 <span class="arithmatex">\(O(log_2n)\)</span>, 平均查找长度为 <span class="arithmatex">\(O(log_2n)\)</span></li>
<li>平衡二叉树结点数的递推关系 <span class="arithmatex">\(n_h=1+n_{h-1}+n_{h-2},n_0=0,n_1=1,n_2=2\)</span>, <span class="arithmatex">\(n_h\)</span>​为构造此高度的平衡二叉树所需的最少结点数
<img alt="" src="../../images/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E6%B7%B1%E5%BA%A6%E5%85%B3%E7%B3%BB.jpg" /></li>
</ul>
<h4 id="453">4.5.3 哈夫曼树和哈夫曼编码<a class="headerlink" href="#453" title="Permanent link">&para;</a></h4>
<h5 id="_101">定义<a class="headerlink" href="#_101" title="Permanent link">&para;</a></h5>
<ul>
<li>
<p>带权路径长度： <span class="arithmatex">\(WPL=\sum_{i=1}^nw_il_i\)</span></p>
</li>
<li>
<p>含有<code>n</code>个带权结点的二叉树中，带权路径长度<code>WPL</code>最小的二叉树称为哈夫曼树</p>
</li>
</ul>
<h5 id="_102">哈夫曼树的构造<a class="headerlink" href="#_102" title="Permanent link">&para;</a></h5>
<ol>
<li>
<p>将 n 个结点分别作为<code>n</code>棵仅含有一个结点的二叉树，构成森林<code>F</code></p>
</li>
<li>
<p>构造一个新结点，从<code>F</code>中选取两棵根结点权值最小的树作为新结点的左、右子树，并且将新结点的权值置为左、右子树上根结点的权值之和</p>
</li>
<li>
<p>从<code>F</code>中删除刚才选出的两棵树，同时将新得到的树加入<code>F</code>中</p>
</li>
<li>
<p>重复 2-3 步骤</p>
</li>
</ol>
<p><img alt="" src="../../images/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%9E%84%E9%80%A0%E8%BF%87%E7%A8%8B%E6%A1%88%E4%BE%8B.jpg" /></p>
<h5 id="_103">哈夫曼树特点<a class="headerlink" href="#_103" title="Permanent link">&para;</a></h5>
<ul>
<li>每个初始节点最终都成为叶结点</li>
<li>构造过程中新建了<code>n-1</code>个结点，哈夫曼树中结点总数为<code>2n-1</code></li>
<li>不存在度为<code>1</code>的节点</li>
</ul>
<h5 id="_104">哈夫曼编码<a class="headerlink" href="#_104" title="Permanent link">&para;</a></h5>
<ul>
<li>
<p>固定长度编码：对每个字符用相等长度的二进制位表示</p>
</li>
<li>
<p>可变长度编码：允许对不同字符用不等长的二进制位表示</p>
</li>
<li>
<p>前缀编码：没有一个编码是另一个编码的前缀</p>
</li>
<li>
<p>使用哈夫曼树得到哈夫曼编码：默认为左边为 0，右边为 1（不唯一，没明确规定）
<img alt="1637761333305" src="../../images/1637761333305.jpg" /></p>
</li>
</ul>
<h2 id="5">5. 图<a class="headerlink" href="#5" title="Permanent link">&para;</a></h2>
<h3 id="51">5.1 图的基本概念<a class="headerlink" href="#51" title="Permanent link">&para;</a></h3>
<h4 id="511">5.1.1 图的定义<a class="headerlink" href="#511" title="Permanent link">&para;</a></h4>
<p>图 <span class="arithmatex">\(G\)</span>由顶点集 <span class="arithmatex">\(V\)</span>和边集 <span class="arithmatex">\(E\)</span>组成，记为 
<span class="arithmatex">\(G=(V,E)\)</span>, 其中 <span class="arithmatex">\(V(G)\)</span>表示图 <span class="arithmatex">\(G\)</span>中顶点的有限非空集； <span class="arithmatex">\(E(G)\)</span>表示图 <span class="arithmatex">\(G\)</span>中顶点之间的关系<a href="https://so.csdn.net/so/search?q=%E9%9B%86%E5%90%88&amp;spm=1001.2101.3001.7020">集合</a>。</p>
<ul>
<li><span class="arithmatex">\(V=\{v_1,v_2,...,v_n\}\)</span>, <span class="arithmatex">\(|V|\)</span>表示顶点个数</li>
<li><span class="arithmatex">\(E=\{(u,v)|u \in V,v\in V\}\)</span>, <span class="arithmatex">\(|E|\)</span>表示图 <span class="arithmatex">\(G\)</span> 中边的条数</li>
</ul>
<h4 id="512">5.1.2 基本术语<a class="headerlink" href="#512" title="Permanent link">&para;</a></h4>
<p><img alt="" src="../../images/20210309161600771.png" /></p>
<ul>
<li>有向图</li>
<li>无向图</li>
<li>简单图、多重图</li>
<li>完全图</li>
<li>子图</li>
<li>连通、连通图和连通分量</li>
<li>强连通图、强连通分量</li>
<li>生成树、生成森林</li>
<li>顶点的度、入度和出度</li>
<li>边的权和网</li>
<li>稠密图、稀疏图</li>
<li>路径、路径长度和回路</li>
<li>简单路径、简单回路</li>
<li>距离</li>
<li>有向树</li>
</ul>
<h3 id="52">5.2 图的存储及基本操作<a class="headerlink" href="#52" title="Permanent link">&para;</a></h3>
<ul>
<li>必须完整、准确地反映顶点集合边集的信息</li>
</ul>
<h4 id="521">5.2.1 邻接矩阵法<a class="headerlink" href="#521" title="Permanent link">&para;</a></h4>
<p><img alt="" src="../../images/20210309174041355.png" /></p>
<ul>
<li>一个一维数组存储图中顶点的信息</li>
<li>一个二维数组存储图中边的信息，称为<strong>邻接矩阵</strong></li>
<li>设图 <span class="arithmatex">\(G\)</span>的邻接矩阵为 <span class="arithmatex">\(A\)</span>, <span class="arithmatex">\(A^n\)</span> 的元素等于从顶点 i 到 j 的长度为 n 的路径数目</li>
</ul>
<h4 id="522">5.2.2 邻接表法<a class="headerlink" href="#522" title="Permanent link">&para;</a></h4>
<p><img alt="" src="../../images/20210414215342883.png" /></p>
<ul>
<li>顶点表结点</li>
</ul>
<p>边表的头指针和顶点的数据信息采用顺序存储</p>
<table>
<thead>
<tr>
<th>顶点域</th>
<th>边表头指针</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>data</code></td>
<td><code>firstarc</code></td>
</tr>
</tbody>
</table>
<ul>
<li>边表结点</li>
</ul>
<p>对每个顶点 <span class="arithmatex">\(v_i\)</span>​建立一个单链表，第 <span class="arithmatex">\(i\)</span>个单链表中的结点表示依附于顶点 <span class="arithmatex">\(v_i\)</span>​的边，这个单链表为顶点 <span class="arithmatex">\(v_i\)</span>​的<strong>边表</strong></p>
<table>
<thead>
<tr>
<th>邻接点域</th>
<th>指针域</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>adjvex</code></td>
<td><code>nextarc</code></td>
</tr>
</tbody>
</table>
<ul>
<li>若存储的是无向图, 空间复杂度为 <span class="arithmatex">\(O(|V|+2|E|)\)</span>；若为有向图，空间复杂度为 <span class="arithmatex">\(O(|V|+|E|)\)</span></li>
</ul>
<h4 id="523">5.2.3 十字链表<a class="headerlink" href="#523" title="Permanent link">&para;</a></h4>
<ul>
<li>有向图的一种链式存储结构</li>
<li>对应于有向图中的每条弧有一个结点，对应于每个顶点也有一个结点</li>
</ul>
<p><img alt="" src="../../images/2-1FH010305Y06.png" />
<img alt="" src="../../images/v2-71e203ce285e52c56741ae13cbd90e78_r.jpg" /></p>
<h4 id="524">5.2.4 邻接多重表<a class="headerlink" href="#524" title="Permanent link">&para;</a></h4>
<p><img alt="" src="../../images/v2-a4db40f270e4526e2f93d215fd54ac3b_r.jpg" />
* 无向图的链式存储结构
* 与邻接表的区别是，同一条边在邻接多重表中只有一个结点</p>
<h4 id="525">5.2.5 图的基本操作<a class="headerlink" href="#525" title="Permanent link">&para;</a></h4>
<div class="highlight"><pre><span></span><code><a id="__codelineno-42-1" name="__codelineno-42-1" href="#__codelineno-42-1"></a><span class="n">Adjacent</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span><span class="o">:</span><span class="n">判断图G是否存在边</span><span class="o">&lt;</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="o">&gt;</span><span class="w"></span>
<a id="__codelineno-42-2" name="__codelineno-42-2" href="#__codelineno-42-2"></a><span class="n">Neighbors</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">x</span><span class="p">)</span><span class="o">:</span><span class="n">列出图G中与结点x邻接对的边</span><span class="w"></span>
<a id="__codelineno-42-3" name="__codelineno-42-3" href="#__codelineno-42-3"></a><span class="n">InsertVertex</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">x</span><span class="p">)</span><span class="o">:</span><span class="n">在图G中插入顶点x</span><span class="w"></span>
<a id="__codelineno-42-4" name="__codelineno-42-4" href="#__codelineno-42-4"></a><span class="n">DeleteVertex</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">x</span><span class="p">)</span><span class="o">:</span><span class="n">从图G中删除顶点x</span><span class="w"></span>
<a id="__codelineno-42-5" name="__codelineno-42-5" href="#__codelineno-42-5"></a><span class="n">AddEdge</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span><span class="o">:</span><span class="n">若边</span><span class="o">&lt;</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="o">&gt;</span><span class="n">不存在</span><span class="err">，</span><span class="n">则向图G中添加该边</span><span class="w"></span>
<a id="__codelineno-42-6" name="__codelineno-42-6" href="#__codelineno-42-6"></a><span class="n">RemoveEdge</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span><span class="o">:</span><span class="n">若边</span><span class="o">&lt;</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="o">&gt;</span><span class="n">存在</span><span class="err">，</span><span class="n">则从图G中删除该边</span><span class="w"></span>
<a id="__codelineno-42-7" name="__codelineno-42-7" href="#__codelineno-42-7"></a><span class="n">FirstNeighbor</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span><span class="o">:</span><span class="n">求图G中顶点x的第一个邻接点</span><span class="err">，</span><span class="n">若有则返回顶点号</span><span class="err">。</span><span class="n">否则返回</span><span class="mi">-1</span><span class="w"></span>
<a id="__codelineno-42-8" name="__codelineno-42-8" href="#__codelineno-42-8"></a><span class="n">NextNeighbor</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span><span class="o">:</span><span class="n">假设图G中顶点y是顶点x的一个邻接点</span><span class="err">，</span><span class="n">返回除y外顶点x的下一个邻接点的顶点号</span><span class="err">，</span><span class="n">若没有返回</span><span class="mi">-1</span><span class="w"></span>
<a id="__codelineno-42-9" name="__codelineno-42-9" href="#__codelineno-42-9"></a><span class="n">Get_edge_value</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span><span class="o">:</span><span class="n">获取图G中边</span><span class="o">&lt;</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="o">&gt;</span><span class="n">的权值</span><span class="w"></span>
<a id="__codelineno-42-10" name="__codelineno-42-10" href="#__codelineno-42-10"></a><span class="n">Set_edge_value</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">v</span><span class="p">)</span><span class="o">:</span><span class="n">设置图G中边</span><span class="o">&lt;</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="o">&gt;</span><span class="n">对应的权值为v</span><span class="w"></span>
</code></pre></div>
<h3 id="53">5.3 图的遍历<a class="headerlink" href="#53" title="Permanent link">&para;</a></h3>
<p>图的遍历是从图中某一顶点出发，按照某种搜索方法沿着图中的对边对图中所有顶点访问且只访问一次。</p>
<h4 id="531">5.3.1 广度优先算法<a class="headerlink" href="#531" title="Permanent link">&para;</a></h4>
<ul>
<li>基本思想</li>
</ul>
<p>首先访问起始顶点 <span class="arithmatex">\(v\)</span>, 接着由 <span class="arithmatex">\(v\)</span>出发，依次访问 <span class="arithmatex">\(v\)</span> 的各个未访问过的邻接顶点 <span class="arithmatex">\(w_1,w_2,...,w_i\)</span>​, 然后一次访问<span class="arithmatex">\(w_1,w_2,...,w_i\)</span> ​的所有未被访问的邻接顶点。</p>
<p>换句话说，<code>BFS</code>是以<code>v</code>为起始点，由近及远依次访问和<code>v</code>有路径相通且路径长度为 1,2,… 的顶点</p>
<p><img alt="" src="../../images/v2-9b9fe810f9437a5490378151c164b648_r.jpg" /></p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-43-1" name="__codelineno-43-1" href="#__codelineno-43-1"></a><span class="kt">bool</span><span class="w"> </span><span class="n">visited</span><span class="p">[</span><span class="n">MAX_VERTEX_NUM</span><span class="p">];</span><span class="c1">//访问标记数组</span>
<a id="__codelineno-43-2" name="__codelineno-43-2" href="#__codelineno-43-2"></a><span class="kt">void</span><span class="w"> </span><span class="nf">BFSTraverse</span><span class="p">(</span><span class="n">Graph</span><span class="w"> </span><span class="n">G</span><span class="p">){</span><span class="w">    </span><span class="c1">//对图G进行广度优先遍历</span>
<a id="__codelineno-43-3" name="__codelineno-43-3" href="#__codelineno-43-3"></a><span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">G</span><span class="p">.</span><span class="n">vexnum</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<a id="__codelineno-43-4" name="__codelineno-43-4" href="#__codelineno-43-4"></a><span class="w">        </span><span class="n">visited</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FALSE</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-43-5" name="__codelineno-43-5" href="#__codelineno-43-5"></a><span class="w">    </span><span class="n">InitQueue</span><span class="p">(</span><span class="n">Q</span><span class="p">);</span><span class="w"></span>
<a id="__codelineno-43-6" name="__codelineno-43-6" href="#__codelineno-43-6"></a><span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">G</span><span class="p">.</span><span class="n">vexnum</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"></span>
<a id="__codelineno-43-7" name="__codelineno-43-7" href="#__codelineno-43-7"></a><span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">visited</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="w">        </span><span class="c1">//对每个连通分量调用一次BFS</span>
<a id="__codelineno-43-8" name="__codelineno-43-8" href="#__codelineno-43-8"></a><span class="w">            </span><span class="n">BFS</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">i</span><span class="p">);</span><span class="w"></span>
<a id="__codelineno-43-9" name="__codelineno-43-9" href="#__codelineno-43-9"></a><span class="p">}</span><span class="w"></span>
<a id="__codelineno-43-10" name="__codelineno-43-10" href="#__codelineno-43-10"></a><span class="kt">void</span><span class="w"> </span><span class="nf">BFS</span><span class="p">(</span><span class="n">Graph</span><span class="w"> </span><span class="n">G</span><span class="p">,</span><span class="kt">int</span><span class="w"> </span><span class="n">v</span><span class="p">){</span><span class="c1">//从顶点v出发，广度优先遍历图G</span>
<a id="__codelineno-43-11" name="__codelineno-43-11" href="#__codelineno-43-11"></a><span class="w">    </span><span class="n">visit</span><span class="p">(</span><span class="n">v</span><span class="p">);</span><span class="w"></span>
<a id="__codelineno-43-12" name="__codelineno-43-12" href="#__codelineno-43-12"></a><span class="w">    </span><span class="n">visited</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TRUE</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-43-13" name="__codelineno-43-13" href="#__codelineno-43-13"></a><span class="w">    </span><span class="n">EnQueue</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span><span class="n">v</span><span class="p">);</span><span class="w"></span>
<a id="__codelineno-43-14" name="__codelineno-43-14" href="#__codelineno-43-14"></a><span class="w">    </span><span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">isEmpty</span><span class="p">(</span><span class="n">Q</span><span class="p">)){</span><span class="w"></span>
<a id="__codelineno-43-15" name="__codelineno-43-15" href="#__codelineno-43-15"></a><span class="w">        </span><span class="n">DeQueue</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span><span class="n">v</span><span class="p">);</span><span class="w"></span>
<a id="__codelineno-43-16" name="__codelineno-43-16" href="#__codelineno-43-16"></a><span class="w">        </span><span class="k">for</span><span class="p">(</span><span class="n">w</span><span class="o">=</span><span class="n">FirstNeighbor</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">v</span><span class="p">);</span><span class="n">w</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">;</span><span class="n">w</span><span class="o">=</span><span class="n">Neighbor</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">v</span><span class="p">,</span><span class="n">w</span><span class="p">))</span><span class="w"></span>
<a id="__codelineno-43-17" name="__codelineno-43-17" href="#__codelineno-43-17"></a><span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">visited</span><span class="p">[</span><span class="n">w</span><span class="p">]){</span><span class="w"></span>
<a id="__codelineno-43-18" name="__codelineno-43-18" href="#__codelineno-43-18"></a><span class="w">                </span><span class="n">visit</span><span class="p">(</span><span class="n">w</span><span class="p">);</span><span class="w"></span>
<a id="__codelineno-43-19" name="__codelineno-43-19" href="#__codelineno-43-19"></a><span class="w">                </span><span class="n">visited</span><span class="p">[</span><span class="n">w</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TRUE</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-43-20" name="__codelineno-43-20" href="#__codelineno-43-20"></a><span class="w">                </span><span class="n">EnQueue</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span><span class="n">w</span><span class="p">);</span><span class="w"></span>
<a id="__codelineno-43-21" name="__codelineno-43-21" href="#__codelineno-43-21"></a><span class="w">            </span><span class="p">}</span><span class="w"></span>
<a id="__codelineno-43-22" name="__codelineno-43-22" href="#__codelineno-43-22"></a><span class="w">    </span><span class="p">}</span><span class="w"></span>
<a id="__codelineno-43-23" name="__codelineno-43-23" href="#__codelineno-43-23"></a><span class="p">}</span><span class="w"></span>
</code></pre></div>
<h4 id="532">5.3.2 深度优先搜索<a class="headerlink" href="#532" title="Permanent link">&para;</a></h4>
<p><code>Depth-First-Search,DFS</code></p>
<ul>
<li>基本思想</li>
</ul>
<p>首先访问图中某一起始顶点 <span class="arithmatex">\(v\)</span>, 然后由 <span class="arithmatex">\(v\)</span>出发，访问与 <span class="arithmatex">\(v\)</span> 邻接且未被访问的任一顶点 <span class="arithmatex">\(w_1\)</span>​, 再访问与 <span class="arithmatex">\(w_1\)</span>​邻接且未被访问的任一顶点，重复上述过程</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-44-1" name="__codelineno-44-1" href="#__codelineno-44-1"></a><span class="kt">bool</span><span class="w"> </span><span class="n">visited</span><span class="p">[</span><span class="n">MAX_VERTEX_NUM</span><span class="p">];</span><span class="w"></span>
<a id="__codelineno-44-2" name="__codelineno-44-2" href="#__codelineno-44-2"></a><span class="kt">void</span><span class="w"> </span><span class="nf">DFSTraverse</span><span class="p">(</span><span class="n">Graph</span><span class="w"> </span><span class="n">G</span><span class="p">){</span><span class="w"></span>
<a id="__codelineno-44-3" name="__codelineno-44-3" href="#__codelineno-44-3"></a><span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="n">v</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">v</span><span class="o">&lt;</span><span class="n">G</span><span class="p">.</span><span class="n">vexnum</span><span class="p">;</span><span class="o">++</span><span class="n">v</span><span class="p">)</span><span class="w"></span>
<a id="__codelineno-44-4" name="__codelineno-44-4" href="#__codelineno-44-4"></a><span class="w">        </span><span class="n">visited</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FALSE</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-44-5" name="__codelineno-44-5" href="#__codelineno-44-5"></a><span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="n">v</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">v</span><span class="o">&lt;</span><span class="n">G</span><span class="p">.</span><span class="n">vexnum</span><span class="p">;</span><span class="o">++</span><span class="n">v</span><span class="p">)</span><span class="w"></span>
<a id="__codelineno-44-6" name="__codelineno-44-6" href="#__codelineno-44-6"></a><span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">visited</span><span class="p">[</span><span class="n">v</span><span class="p">])</span><span class="w"></span>
<a id="__codelineno-44-7" name="__codelineno-44-7" href="#__codelineno-44-7"></a><span class="w">            </span><span class="n">DFS</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">v</span><span class="p">);</span><span class="w">        </span>
<a id="__codelineno-44-8" name="__codelineno-44-8" href="#__codelineno-44-8"></a><span class="p">}</span><span class="w"></span>
<a id="__codelineno-44-9" name="__codelineno-44-9" href="#__codelineno-44-9"></a><span class="kt">void</span><span class="w"> </span><span class="nf">DFS</span><span class="p">(</span><span class="n">Graph</span><span class="w"> </span><span class="n">G</span><span class="p">,</span><span class="kt">int</span><span class="w"> </span><span class="n">v</span><span class="p">){</span><span class="w"></span>
<a id="__codelineno-44-10" name="__codelineno-44-10" href="#__codelineno-44-10"></a><span class="w">    </span><span class="n">visit</span><span class="p">(</span><span class="n">v</span><span class="p">);</span><span class="w"></span>
<a id="__codelineno-44-11" name="__codelineno-44-11" href="#__codelineno-44-11"></a><span class="w">    </span><span class="n">visited</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TRUE</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-44-12" name="__codelineno-44-12" href="#__codelineno-44-12"></a><span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="n">w</span><span class="o">=</span><span class="n">FirstNeighbor</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">v</span><span class="p">);</span><span class="n">w</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">;</span><span class="n">w</span><span class="o">=</span><span class="n">NextNeighbor</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">v</span><span class="p">,</span><span class="n">w</span><span class="p">))</span><span class="w"></span>
<a id="__codelineno-44-13" name="__codelineno-44-13" href="#__codelineno-44-13"></a><span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">visited</span><span class="p">[</span><span class="n">w</span><span class="p">]){</span><span class="w"></span>
<a id="__codelineno-44-14" name="__codelineno-44-14" href="#__codelineno-44-14"></a><span class="w">            </span><span class="n">DFS</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">w</span><span class="p">);</span><span class="w"></span>
<a id="__codelineno-44-15" name="__codelineno-44-15" href="#__codelineno-44-15"></a><span class="w">        </span><span class="p">}</span><span class="w"></span>
<a id="__codelineno-44-16" name="__codelineno-44-16" href="#__codelineno-44-16"></a><span class="p">}</span><span class="w"></span>
</code></pre></div>
<h4 id="_105">性能<a class="headerlink" href="#_105" title="Permanent link">&para;</a></h4>
<table>
<thead>
<tr>
<th>性能</th>
<th>广度优先搜索</th>
<th>深度优先搜索</th>
</tr>
</thead>
<tbody>
<tr>
<td>空间复杂度</td>
<td><span class="arithmatex">\(O(\|V\|)\)</span></td>
<td><span class="arithmatex">\(O(\|V\|)\)</span></td>
</tr>
<tr>
<td>时间复杂度-邻接矩阵</td>
<td><span class="arithmatex">\(O(\|V\|^2)\)</span></td>
<td><span class="arithmatex">\(O(\|V\|^2)\)</span></td>
</tr>
<tr>
<td>时间复杂度-邻接表</td>
<td><span class="arithmatex">\(O(\|V\| + \|E\|)\)</span></td>
<td><span class="arithmatex">\(O(\|V\| + \|E\|)\)</span></td>
</tr>
<tr>
<td>生成树</td>
<td>生成树，邻接表不唯一，邻接矩阵唯一</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="54">5.4 图的应用<a class="headerlink" href="#54" title="Permanent link">&para;</a></h3>
<h4 id="541">5.4.1 最小生成树<a class="headerlink" href="#541" title="Permanent link">&para;</a></h4>
<p>求一个带权连通图的最小生成树<code>Minimum-Spanning-Tree,MST</code></p>
<h5 id="prim">Prim 算法<a class="headerlink" href="#prim" title="Permanent link">&para;</a></h5>
<ul>
<li>基本思想
  <img alt="" src="../../images/v2-3e7e4f6a9393cd87e50691ff9674e50c_r.jpg" /></li>
<li>
<p>初始时从图中任取一顶点加入树 T, 此时树中只含有一个顶点</p>
</li>
<li>
<p>之后选择一个与当前 T 中<strong>顶点集合</strong>距离最近的顶点，且加入后不能出现环，并将该顶点和相应的边加入 T，每次操作后 T 中的顶点数和边数都增 1。</p>
</li>
<li>
<p>重复直到加满</p>
</li>
<li>
<p>时间复杂度： <span class="arithmatex">\(O(|V|^2)\)</span></p>
</li>
</ul>
<p><img alt="" src="../../images/v2-d5f88f830a01559f01c47168c7ce8326_r.jpg" /></p>
<p>最终可能的结果：
<img alt="" src="../../images/v2-dcbb7b3c956bab47af9d9898aa767366_r.jpg" /></p>
<h5 id="kruskal">Kruskal 算法<a class="headerlink" href="#kruskal" title="Permanent link">&para;</a></h5>
<p>基本思想</p>
<ul>
<li>初始时为只有 n 个顶点而无边的非连通图 T，每个顶点自成一个连通分量</li>
<li>按照边的权值由小到大，加入到非连通图 T 中，不能形成环</li>
<li>重复直到加满</li>
<li>时间复杂度： <span class="arithmatex">\(O(|E|log|E|)\)</span>，每轮判断是否属于同一个集合，需要  <span class="arithmatex">\(O(log|E|)\)</span></li>
</ul>
<p><img alt="" src="../../images/v2-d014a0bb409aa2d5d3a62608b40a7e7f_b.jpg" /></p>
<p>Prim算法时间复杂度：<span class="arithmatex">\(O(|V|^2)\)</span>  适合用于边稠密图</p>
<p>Kruskal算法时间复杂度： <span class="arithmatex">\(O(|E|log|E|)\)</span>  适合用于边稀疏图</p>
<h4 id="542">5.4.2 最短路径<a class="headerlink" href="#542" title="Permanent link">&para;</a></h4>
<h5 id="dijkstra">Dijkstra 算法求单源最短路径<a class="headerlink" href="#dijkstra" title="Permanent link">&para;</a></h5>
<h6 id="_106">辅助数组<a class="headerlink" href="#_106" title="Permanent link">&para;</a></h6>
<ul>
<li>集合<code>S</code>：记录以求得的最短路径的顶点</li>
<li><code>dist[]</code>：记录从源点 <span class="arithmatex">\(v_0\)</span>​到其他各顶点当前的最短路径长度</li>
<li><code>path[]</code>：<code>path[i]</code>表示从源点到顶点 i 之间的最短路径的前驱结点。可用于回溯找最短路径</li>
</ul>
<h6 id="_107">算法步骤<a class="headerlink" href="#_107" title="Permanent link">&para;</a></h6>
<ol>
<li>
<p>初始化：集合<code>S</code>初始化为<code>{0}</code>,<code>dist[]</code>的初始值<code>dist[i]=arcs[0][i]</code></p>
</li>
<li>
<p>从顶点集合<code>V-S</code>中选出 <span class="arithmatex">\(v_j\)</span>​, 满足 <span class="arithmatex">\(dist[j]=Min\{dist[i] \ |v_i \in V-S\}\)</span>, 令<span class="arithmatex">\(S=S\cup\{j\}\)</span></p>
</li>
<li>
<p>根据公式修改从 <span class="arithmatex">\(v_0\)</span>​出发到集合 V-S 上任一顶点 <span class="arithmatex">\(v_k\)</span> 可达的最短路径长度,若<code>dist[j]+arcs[j][k]&lt;dist[k]</code>, 则更新</p>
</li>
<li>
<p>重复步骤 2-3 操作共<code>n-1</code>次</p>
</li>
<li>
<p>时间复杂度： <span class="arithmatex">\(O(|V|^2)\)</span></p>
</li>
<li>注意:Dijkstra 算法不适用于有负权值的带权图</li>
</ol>
<h6 id="_108">案例：<a class="headerlink" href="#_108" title="Permanent link">&para;</a></h6>
<ul>
<li>
<p>初始：从<span class="arithmatex">\(V_i\)</span>开始，初始化三个数组信息如下
<img alt="" src="../../images/v2-e277db3ec26a797fd288aa8e009fdc3f_r.jpg" /></p>
</li>
<li>
<p>第 1 轮：循环遍历所有结点，找到还没确定最短路径，且 dist 最小的顶点<span class="arithmatex">\(V_i\)</span>，令 final[i] = ture
<img alt="" src="../../images/v2-459788fef793c835d40f59cd5586abee_r.jpg" />
检查所有邻接自<span class="arithmatex">\(V_i\)</span>的顶点，若其 final 值为 false，则更新 dist 和 path 信息
<img alt="" src="../../images/v2-6a351cad7f222884ebf52b8c0aba2bb6_r.jpg" /></p>
</li>
<li>
<p>第 2 轮：循环遍历所有结点，找到还没确定最短路径，且 dist 最小的顶点<span class="arithmatex">\(V_i\)</span>，令 final[i] = ture
<img alt="" src="../../images/v2-d75e12c3f19a5cc56938dd829e37f019_r.jpg" />
检查所有邻接自<span class="arithmatex">\(V_i\)</span>的顶点，若其 final 值为 false，则更新 dist 和 path 信息
<img alt="" src="../../images/v2-d62624155e4e838820efc56f1bdcf104_b.jpg" /></p>
</li>
<li>
<p>第 3 轮：循环遍历所有结点，找到还没确定最短路径，且 dist 最小的顶点<span class="arithmatex">\(V_i\)</span>，令 final[i] = ture
<img alt="" src="../../images/v2-9c9c3a89a28247c89f34d18f55b66f3c_r.jpg" />
检查所有邻接自<span class="arithmatex">\(V_i\)</span>的顶点，若其 final 值为 false，则更新 dist 和 path 信息
<img alt="" src="../../images/v2-2194e70cbd083f29a0d17d32f6b1cfcd_b.jpg" /></p>
</li>
<li>
<p>第 4 轮：循环遍历所有结点，找到还没确定最短路径，且 dist 最小的顶点<span class="arithmatex">\(V_i\)</span> ，令 final[i] = ture
<img alt="" src="../../images/v2-d5fca76865716e5a65f61337c25633d5_r.jpg" />
因为找不到其他顶点了，也不用更新了，算法结束</p>
</li>
<li>
<p>结果: </p>
<ul>
<li><span class="arithmatex">\(V_0\)</span>到<span class="arithmatex">\(v_2\)</span>的最短（带权）路径长度为：dist[2] = 9</li>
<li>通过 path[] 可知，<span class="arithmatex">\(V_0\)</span>到 <span class="arithmatex">\(V_2\)</span>的最短（带权）路径： <span class="arithmatex">\(V_2\)</span> &lt;- <span class="arithmatex">\(V_4\)</span> &lt;- <span class="arithmatex">\(V_1\)</span>  &lt;- <span class="arithmatex">\(V_0\)</span></li>
</ul>
</li>
</ul>
<h5 id="floyd">Floyd 算法求个定点之间最短路径<a class="headerlink" href="#floyd" title="Permanent link">&para;</a></h5>
<p>算法描述</p>
<ul>
<li>
<p>定义一个 n 阶方阵 <span class="arithmatex">\(A^{(-1)}，A^{(0)}，...,A^{(n-1)}\)</span>, 其中 <span class="arithmatex">\(A^{(-1)}[i][j]=arcs[i][j],\)</span></p>
</li>
<li>
<p>根据递推公式重复<code>n</code>次，计算出 <span class="arithmatex">\(A^{(0)}，...,A^{(n-1)}\)</span></p>
</li>
<li>
<p><span class="arithmatex">\(A^{(k)}[i][j]=Min\{A^{(k-1)}[i][j],A^{(k-1)}[i][k]+A^{(k-1)}[k][j]\},k=0,1,..,n-1\)</span>
    其中，</p>
<ul>
<li><span class="arithmatex">\(A^{(0)}[i][j]\)</span>是从顶点 <span class="arithmatex">\(v_i\)</span> 到 <span class="arithmatex">\(v_j\)</span>​、中间路径是 <span class="arithmatex">\(v_0\)</span>​的最短路径的长度</li>
<li><span class="arithmatex">\(A^{(k)}[i][j]\)</span> 是从顶点 <span class="arithmatex">\(v_i\)</span>​到 <span class="arithmatex">\(v_j\)</span>​、中间顶点的序号不大于 k 的最短路径的长度</li>
</ul>
</li>
<li>
<p>时间复杂度 <span class="arithmatex">\(O(|V|^3)\)</span></p>
</li>
</ul>
<p>案例：</p>
<ul>
<li>
<p>初始：不允许在其他顶点中转，最短路径如下，path = -1 表示没有中转点
<img alt="" src="../../images/v2-a398b44588f84a64861dd7b0d7ba9361_b.jpg" /></p>
</li>
<li>
<p>第一步：允许在<span class="arithmatex">\(V_0\)</span>中转，最短路径是<span class="arithmatex">\(A^{(0)}\)</span>，在<span class="arithmatex">\(path^{(0)}\)</span>中记录中转的点<span class="arithmatex">\(V_2\)</span>到<span class="arithmatex">\(V_1\)</span>之间没有直接通路，但是能经过<span class="arithmatex">\(V_0\)</span>中转的话， <span class="arithmatex">\(V_2\)</span>到<span class="arithmatex">\(V_1\)</span>之间的距离从 ∞ 变为 11,公式化是，
<img alt="" src="../../images/v2-abba795f1e12d043de4aa595e146f0b4_r.jpg" />
其中上述<span class="arithmatex">\(V_0\)</span>在中转后从无穷大变为 11 的路径被找到了： 
<span class="arithmatex">\(A^{(-1)}[2][1] \gt A^{(-1)}[2][0] +  A^{(-1)}[0][1]=11\)</span>,修改矩阵的值为 <span class="arithmatex">\(A^{(0)}[2][1]=11,path^{(0)}[2][1]=0\)</span>：<br />
<img alt="" src="../../images/v2-d7e1c254942ef052e4112a3ca6944e62_r.jpg" /></p>
</li>
<li>
<p>第二步：允许在  <span class="arithmatex">\(V_0\)</span>、<span class="arithmatex">\(V_1\)</span> 中转，求<span class="arithmatex">\(A^{(1)}\)</span>和 <span class="arithmatex">\(path^{(1)}\)</span>, 继续根据公式
<img alt="" src="../../images/v2-c2c1488397b0b0291cce560ad53a43d1_b.jpg" />
找到了：
<img alt="" src="../../images/v2-08e8995bf7d7bf85fcd2a266a6f6d6b7_b.png" />
<img alt="" src="../../images/v2-c0e6ecd9075f3668d2084ae987f9d5cf_b.jpg" /></p>
</li>
<li>
<p>第三步：允许在  <span class="arithmatex">\(V_0\)</span>、<span class="arithmatex">\(V_1\)</span> 、<span class="arithmatex">\(V_2\)</span>  中转，求<span class="arithmatex">\(A^{(2)}\)</span>和 <span class="arithmatex">\(path^{(2)}\)</span> ,找到了
<img alt="" src="../../images/v2-55f33681af4d597a43abcf0bb1851d5e_r.png" />
<img alt="" src="../../images/v2-189fdc7c3740b0bde3cab19e4a52a339_b.jpg" /></p>
</li>
<li>
<p>根据  可知，<span class="arithmatex">\(V_1\)</span> 到 <span class="arithmatex">\(V_2\)</span> 最短路径长度为 4，根据  可知，完整路径信息为 <span class="arithmatex">\(V_1-V_2\)</span></p>
</li>
<li>
<p>根据  可知，<span class="arithmatex">\(V_0\)</span> 到 <span class="arithmatex">\(V_2\)</span> 最短路径长度为 10，根据  可知，完整路径信息为 <span class="arithmatex">\(V_0-V_1-V_2\)</span></p>
</li>
<li>
<p>根据  可知，<span class="arithmatex">\(V_1\)</span> 到 <span class="arithmatex">\(V_0\)</span> 最短路径长度为 9，根据  可知，完整路径信息为 <span class="arithmatex">\(V_1-V_2-V_0\)</span></p>
</li>
</ul>
<h4 id="543">5.4.3 有向无环图描述表达式<a class="headerlink" href="#543" title="Permanent link">&para;</a></h4>
<p>有向无环图<code>DAG</code></p>
<p>有向无环图是描述含有公共子式的表达式的有效工具，可实现对相同子式的共享，从而节省存储空间</p>
<h4 id="544">5.4.4 拓扑排序<a class="headerlink" href="#544" title="Permanent link">&para;</a></h4>
<ul>
<li><code>AOV网</code></li>
</ul>
<p>若用<code>AVG</code>表示一个工程，其顶点表示活动，用有向边 <span class="arithmatex">\(&lt;V_i,V_j&gt;\)</span> 表示活动 <span class="arithmatex">\(V_i\)</span> ​必须先于活动 <span class="arithmatex">\(V_j\)</span> ​进行的这样一种关系，则将这种有向图称为<strong>顶点表示活动的网络</strong></p>
<ul>
<li>
<p>拓扑排序：在图论中，由一个有向无环图的顶点组成的序列，当且仅当满足下列条件时，称为该图的一个拓扑排序</p>
<ul>
<li>每个顶点出现且只出现一次</li>
<li>若顶点<code>A</code>在序列中排在顶点 B 的前面，则在图中不存在从顶点 B 到顶点 A 的路径</li>
</ul>
</li>
<li>
<p>拓扑排序算法</p>
<ol>
<li>从<code>AOV</code>网中选择一个没有前驱的顶点并输出</li>
<li>从网中删除该顶点和所有以它为起点的有向边</li>
<li>重复 1-2，直到当前<code>AOV</code>网为空</li>
</ol>
</li>
<li>
<p>时间复杂度 <span class="arithmatex">\(O(|V|+|E|)\)</span>,采用邻接矩阵时间复杂度 <span class="arithmatex">\(O(|V|^2)\)</span></p>
</li>
<li>
<p>逆拓扑排序</p>
<ol>
<li>从<code>AOV</code>网中选择一个没有后继的顶点并输出</li>
<li>从网中删除该顶点和所有以它为重点的有向边</li>
<li>重复 1-2 直到<code>AOV</code>为空</li>
</ol>
</li>
<li>
<p>案例：
<img alt="" src="../../images/v2-72625858f7a6c5b09c05e136665cb838_r.jpg" />
<img alt="" src="../../images/v2-c8cb97c38afd30d70eeff5e7f0805da9_r.jpg" />
<img alt="" src="../../images/v2-478f7d47e7ecf4a2f2c42b705e25f835_r.jpg" /></p>
</li>
</ul>
<h4 id="545">5.4.5 关键路径<a class="headerlink" href="#545" title="Permanent link">&para;</a></h4>
<p>在带权有向图中，以顶点表示事件，以有向边表示活动，以边上的权值表示完成该活动的开销，称之为<strong>用边表示活动的网络</strong>，简称<code>AOE网</code></p>
<p><img alt="" src="../../images/v2-21a577c594a72044dca81ae088cb12ff_r.jpg" /></p>
<ul>
<li>
<p><code>AOE网</code>中仅有一个入度为 0 的顶点，称为开始顶点（源点）；只存在一个出度为 0 的顶点，称之为结束顶点（汇点）</p>
</li>
<li>
<p>具有最大路径长度的路径称为<strong>关键路径</strong>，而把关键路径上的活动称为<strong>关键活动</strong></p>
</li>
<li>
<p>关键路径并不唯一，只提高其中一条关键路径上的关键活动速度不能缩短整个工程的工期。</p>
</li>
</ul>
<p>重要概念：</p>
<ul>
<li><strong>事件<span class="arithmatex">\(v_i\)</span>的最迟发生时间 <span class="arithmatex">\(v(k)\)</span></strong>:它是指在不推迟整个工程完成的前提下，该事件最迟必须发生的时间（紫色标注）</li>
<li><strong>活动 <span class="arithmatex">\(a_i\)</span> 的最迟开始时间 <span class="arithmatex">\(l(i)\)</span></strong>：它是指该活动弧的终点所表示事件的最迟发生时间与该活动所需时间之差（绿色标注）</li>
</ul>
<p><img alt="" src="../../images/v2-f43bff7a99a3af2806d5b526e6b3d27c_b.jpg" /></p>
<ul>
<li><strong>活动 <span class="arithmatex">\(a_i\)</span> 的最早开始时间 <span class="arithmatex">\(e(i)\)</span></strong>：指该活动弧的起点所表示的事件的最早发生时间（红色标注）</li>
<li><strong>活动 ai 的时间余量 <span class="arithmatex">\(d(i) = l(i) - e(i)\)</span></strong>，表示在不增加完成整个工程所需总时间的情况下，活动 ai 可以拖延的时间</li>
<li>若<span class="arithmatex">\(d(i) = 0\)</span> 即 <span class="arithmatex">\(l(i) = e(i)\)</span> 的活动 <strong><span class="arithmatex">\(a_i\)</span> 是关键活动</strong></li>
<li>由关键活动组成的路径就是<strong>关键路径</strong></li>
</ul>
<p><img alt="" src="../../images/v2-e4554b9c09dc9ca62fc6f000e11d6101_r.jpg" /></p>
<h5 id="_109">计算步骤<a class="headerlink" href="#_109" title="Permanent link">&para;</a></h5>
<ol>
<li>
<p><strong>事件 <span class="arithmatex">\(v_k\)</span>​的最早发生时间 <span class="arithmatex">\(ve(k)\)</span></strong></p>
<ul>
<li><span class="arithmatex">\(ve(源点)=0\)</span></li>
<li><span class="arithmatex">\(ve(k)=Max\{ve(j)+Weight(v_j,v_k\}\)</span></li>
</ul>
</li>
<li>
<p><strong>事件 <span class="arithmatex">\(v_k\)</span> ​的最迟发生时间 <span class="arithmatex">\(vl(k)\)</span></strong></p>
<ul>
<li><span class="arithmatex">\(vl(汇点)=ve(汇点)\)</span></li>
<li><span class="arithmatex">\(vl(k)=Min\{vl(j)-Weight(v_k,v_j\}\)</span></li>
</ul>
</li>
<li>
<p><strong>活动 <span class="arithmatex">\(a_i\)</span> ​的最早开始时间 <span class="arithmatex">\(e(i)\)</span></strong></p>
<ul>
<li>它是指该活动弧的起点所表示的事件最早发生时间。</li>
<li>若边 <span class="arithmatex">\(&lt;v_k,v_j&gt;\)</span>表示活动 <span class="arithmatex">\(a_i\)</span>​, 则有 <span class="arithmatex">\(e(i)=ve(k)\)</span></li>
</ul>
</li>
<li>
<p><strong>活动 <span class="arithmatex">\(a_i\)</span>​的最迟开始时间 <span class="arithmatex">\(l(i)\)</span></strong></p>
<ul>
<li>它是指该活动弧的终点所表示事件的最迟发生时间与该活动所需时间之差</li>
<li>若边 <span class="arithmatex">\(&lt;v_k,v_j&gt;\)</span> 表示活动 <span class="arithmatex">\(a_i\)</span> ​, 则有<span class="arithmatex">\(l(i)=vl(j)-Weight(v_k,v_j)\)</span></li>
</ul>
</li>
<li>
<p><strong>求所有活动的时间余量 <span class="arithmatex">\(d(i)=l(i)-e(i)\)</span></strong>, <span class="arithmatex">\(d(i)=0\)</span>的活动 <span class="arithmatex">\(a_i\)</span>​是关键活动</p>
</li>
</ol>
<p>案例：</p>
<ol>
<li>
<p>求所有事件的最早发生时间 <span class="arithmatex">\(ve\)</span></p>
<ul>
<li>(1) 计算拓扑排序序列:
    <img alt="" src="../../images/v2-9b359a8ba713ef6724fbe7bd1ae9831b_b.jpg" />
     <span class="arithmatex">\(V_1、V_3、V_2、V_5、V_4、V_6\)</span></li>
<li>(2) 按照序列计算最早发生时间<ul>
<li><span class="arithmatex">\(ve(1) = 0\)</span></li>
<li><span class="arithmatex">\(ve(3) = 2\)</span></li>
<li><span class="arithmatex">\(ve(2) = 3\)</span></li>
<li><span class="arithmatex">\(ve(5) = 6\)</span></li>
<li><span class="arithmatex">\(ve(4) = Max\{ve(2) + 2, ve(3) + 4\}= 6\)</span></li>
<li><span class="arithmatex">\(ve(6) = Max\{ve(5) + 1, ve(4) + 2, v(3) + 3\} = 8\)</span></li>
</ul>
</li>
</ul>
</li>
<li>
<p>求所有事件的最迟发生时间 <span class="arithmatex">\(vl\)</span></p>
<ul>
<li>(1) 计算逆拓扑排序序列：<span class="arithmatex">\(V_6、V_5、V_4、V_2、V_3、V_1\)</span></li>
<li>(2) 按照序列计算最迟发生时间<ul>
<li><span class="arithmatex">\(vl(6) = ve(6) = 8\)</span></li>
<li><span class="arithmatex">\(vl(5) = vl(6) - 1 = 7\)</span></li>
<li><span class="arithmatex">\(vl(4) = vl(6) - 2 = 6\)</span></li>
<li><span class="arithmatex">\(vl(2) = Min\{vl(5) - 1, vl(4) - 2\} = 4\)</span></li>
<li><span class="arithmatex">\(vl(3) = Min\{vl(4) - 4, vl(6) - 3\} = 2\)</span></li>
<li><span class="arithmatex">\(vl(1) = Min\{vl(2) - 3, vl(3) - 2\} = 0\)</span></li>
</ul>
</li>
</ul>
</li>
<li>
<p>求所有活动的最早发生时间 <span class="arithmatex">\(e\)</span>
<img alt="" src="../../images/v2-c54cf7ff92b9f11d7ec2e51a71dbec8d_r.jpg" />
<img alt="" src="../../images/v2-322ac25afe334e110eb308ddf1e06474_b.jpg" />
所有活动的最早发生时间, 若边 <span class="arithmatex">\(&lt;v_k,v_j&gt;\)</span>表示活动 <span class="arithmatex">\(a_i\)</span>​, 则有 <span class="arithmatex">\(e(i)=ve(k)\)</span>
<img alt="" src="../../images/v2-3f86f48fe1ab2418f59aad6243a8b730_r.jpg" /></p>
</li>
<li>
<p>求所有活动的最迟发生时间 <span class="arithmatex">\(l\)</span></p>
<ul>
<li>边 <span class="arithmatex">\(&lt;v_k,v_j&gt;\)</span> 表示活动 <span class="arithmatex">\(a_i\)</span> ​, 则有<span class="arithmatex">\(l(i)=vl(j)-Weight(v_k,v_j)\)</span></li>
<li>得到以下结果：
<img alt="" src="../../images/v2-34a4aea2c8200d80348406206ae42185_b.jpg" /></li>
</ul>
</li>
<li>
<p>求所有活动的时间余量:<span class="arithmatex">\(d(i) = l(i) - e(i)\)</span>, 得到：
  <img alt="" src="../../images/v2-3d54ec435830e61271ea6256ce6e3a05_b.jpg" /></p>
<ul>
<li>关键活动：<span class="arithmatex">\(a_2、a_5、a_7\)</span></li>
<li>关键路径：<span class="arithmatex">\(V_1 -&gt; V_3 -&gt; V_4 -&gt; V_6\)</span></li>
</ul>
</li>
</ol>
<h2 id="6">6. 查找<a class="headerlink" href="#6" title="Permanent link">&para;</a></h2>
<h3 id="61">6.1 查找的概念<a class="headerlink" href="#61" title="Permanent link">&para;</a></h3>
<ul>
<li><strong>查找</strong>：在数据集合中寻找满足某种条件的数据元素的过程称为查找。查找的结果分为<strong>成功</strong>和<strong>失败</strong></li>
<li><strong>查找表</strong>：用于查找的数据集合称为查找表。对查找表进行的操作一般有四种<ul>
<li>查询</li>
<li>查询关键字的其他信息</li>
<li>插入</li>
<li>删除</li>
</ul>
</li>
<li>静态查找表：不涉及插入和删除的查找表</li>
<li>关键字：数据元素中唯一标识该元素的某个数据项的值</li>
<li>平均查找长度： <span class="arithmatex">\(ASL=\sum_{i=1}^nP_iC_i\)</span>​, <span class="arithmatex">\(P_i\)</span>​是概率， <span class="arithmatex">\(C_i\)</span>​是比较次数</li>
</ul>
<h3 id="62">6.2 顺序查找和折半查找<a class="headerlink" href="#62" title="Permanent link">&para;</a></h3>
<h4 id="621">6.2.1 顺序查找<a class="headerlink" href="#621" title="Permanent link">&para;</a></h4>
<h5 id="_110">一般线性表的顺序查找<a class="headerlink" href="#_110" title="Permanent link">&para;</a></h5>
<div class="highlight"><pre><span></span><code><a id="__codelineno-45-1" name="__codelineno-45-1" href="#__codelineno-45-1"></a><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="p">{</span><span class="w"></span>
<a id="__codelineno-45-2" name="__codelineno-45-2" href="#__codelineno-45-2"></a><span class="w">    </span><span class="n">ElemType</span><span class="w"> </span><span class="o">*</span><span class="n">elem</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-45-3" name="__codelineno-45-3" href="#__codelineno-45-3"></a><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">TableLen</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-45-4" name="__codelineno-45-4" href="#__codelineno-45-4"></a><span class="p">}</span><span class="n">SSTable</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-45-5" name="__codelineno-45-5" href="#__codelineno-45-5"></a><span class="kt">int</span><span class="w"> </span><span class="nf">Search_Seq</span><span class="p">(</span><span class="n">SSTable</span><span class="w"> </span><span class="n">ST</span><span class="p">,</span><span class="n">ElemType</span><span class="w"> </span><span class="n">key</span><span class="p">){</span><span class="w"></span>
<a id="__codelineno-45-6" name="__codelineno-45-6" href="#__codelineno-45-6"></a><span class="w">    </span><span class="n">ST</span><span class="p">.</span><span class="n">elem</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">key</span><span class="p">;</span><span class="w">    </span><span class="c1">//哨兵</span>
<a id="__codelineno-45-7" name="__codelineno-45-7" href="#__codelineno-45-7"></a><span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="n">ST</span><span class="o">&gt;</span><span class="n">TableLen</span><span class="p">;</span><span class="n">ST</span><span class="p">.</span><span class="n">elem</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">!=</span><span class="n">key</span><span class="p">;</span><span class="o">--</span><span class="n">i</span><span class="p">);</span><span class="w">    </span><span class="c1">//从后往前找</span>
<a id="__codelineno-45-8" name="__codelineno-45-8" href="#__codelineno-45-8"></a><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="c1">//若表中不存在关键字为key的元素，将查找到i为0时退出循环</span>
<a id="__codelineno-45-9" name="__codelineno-45-9" href="#__codelineno-45-9"></a><span class="p">}</span><span class="w"></span>
</code></pre></div>
<ul>
<li>哨兵：引入它的目的是可以不必判断数组是否会越界。引入哨兵可以避免很多不必要的判断语句，从而提高程序效率</li>
</ul>
<h5 id="_111">有序表的顺序查找<a class="headerlink" href="#_111" title="Permanent link">&para;</a></h5>
<ul>
<li>由于表的关键字是有序的，查找失败时可以不用比较到表的另一端就能返回失败信息</li>
</ul>
<h4 id="622">6.2.2 折半查找<a class="headerlink" href="#622" title="Permanent link">&para;</a></h4>
<ul>
<li>基本思想</li>
</ul>
<p>首先将给定的<code>key</code>与表的中间位置的关键字比较，成功后返回；否则根据<code>key</code>与关键字的大小判断查找左边还是右边</p>
<p>折半查找整个算法中，关于 mid 的取值向上 / 向下需要统一</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-46-1" name="__codelineno-46-1" href="#__codelineno-46-1"></a><span class="kt">int</span><span class="w"> </span><span class="nf">Binary_Search</span><span class="p">(</span><span class="n">SeqList</span><span class="w"> </span><span class="n">L</span><span class="p">,</span><span class="n">ElemType</span><span class="w"> </span><span class="n">key</span><span class="p">){</span><span class="w"></span>
<a id="__codelineno-46-2" name="__codelineno-46-2" href="#__codelineno-46-2"></a><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">low</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">high</span><span class="o">=</span><span class="n">L</span><span class="p">.</span><span class="n">TableLen</span><span class="mi">-1</span><span class="p">,</span><span class="n">mid</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-46-3" name="__codelineno-46-3" href="#__codelineno-46-3"></a><span class="w">    </span><span class="k">while</span><span class="p">(</span><span class="n">low</span><span class="o">&lt;=</span><span class="n">high</span><span class="p">){</span><span class="w"></span>
<a id="__codelineno-46-4" name="__codelineno-46-4" href="#__codelineno-46-4"></a><span class="w">        </span><span class="n">mid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">low</span><span class="o">+</span><span class="n">high</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span><span class="w">        </span><span class="c1">//取中间位置</span>
<a id="__codelineno-46-5" name="__codelineno-46-5" href="#__codelineno-46-5"></a><span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">L</span><span class="p">.</span><span class="n">elem</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span><span class="o">==</span><span class="n">key</span><span class="p">)</span><span class="w"></span>
<a id="__codelineno-46-6" name="__codelineno-46-6" href="#__codelineno-46-6"></a><span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">mid</span><span class="p">;</span><span class="w">    </span>
<a id="__codelineno-46-7" name="__codelineno-46-7" href="#__codelineno-46-7"></a><span class="w">        </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="n">L</span><span class="p">.</span><span class="n">elem</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span><span class="o">&gt;</span><span class="n">key</span><span class="p">)</span><span class="w"></span>
<a id="__codelineno-46-8" name="__codelineno-46-8" href="#__codelineno-46-8"></a><span class="w">            </span><span class="n">high</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mid</span><span class="mi">-1</span><span class="p">;</span><span class="c1">//从前半部分继续查找</span>
<a id="__codelineno-46-9" name="__codelineno-46-9" href="#__codelineno-46-9"></a><span class="w">        </span><span class="k">else</span><span class="w"></span>
<a id="__codelineno-46-10" name="__codelineno-46-10" href="#__codelineno-46-10"></a><span class="w">            </span><span class="n">low</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span><span class="c1">//从后半部分继续查找</span>
<a id="__codelineno-46-11" name="__codelineno-46-11" href="#__codelineno-46-11"></a><span class="w">    </span><span class="p">}</span><span class="w"></span>
<a id="__codelineno-46-12" name="__codelineno-46-12" href="#__codelineno-46-12"></a><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span><span class="w">        </span><span class="c1">//查找失败，返回-1</span>
<a id="__codelineno-46-13" name="__codelineno-46-13" href="#__codelineno-46-13"></a><span class="p">}</span><span class="w"></span>
</code></pre></div>
<ul>
<li>折半查找又称二分查找，仅适用于有序的顺序表</li>
<li>
<p>仅适用于顺序存储结构，不适用于链式存储结构</p>
</li>
<li>
<p>生成<strong>判定树</strong>
<img alt="uTools_1638256209356" src="../../images/uTools_1638256209356.png" />
<img alt="uTools_1638256305668" src="../../images/uTools_1638256305668.png" />
<img alt="uTools_1638256324365" src="../../images/uTools_1638256324365.png" /></p>
</li>
</ul>
<p>判定树特性：
<img alt="uTools_1638256115837" src="../../images/uTools_1638256115837.png" /></p>
<ul>
<li>是平衡二叉树</li>
<li>有 <span class="arithmatex">\(n\)</span> 个圆形结点代表原数据或成功结点，<span class="arithmatex">\(n+1\)</span> 个方框结点代表不成功结点</li>
<li>每个圆形结点都不是叶子结点，一定有方框子结点</li>
<li>元素个数为<span class="arithmatex">\(n\)</span>时，树高度为 <span class="arithmatex">\(h=\lceil \log_2{(n+1)} \rceil\)</span></li>
</ul>
<p>与<code>折半查找判定树</code>的高度h有关。高度越小，查找效率越高
- 最好情况，平均查找长度=<span class="arithmatex">\(O(1)\)</span>
- 最坏情况，平均查找长度=<span class="arithmatex">\(O(log_2n)\)</span>
- 则<code>时间复杂度</code>=<span class="arithmatex">\(O(log_2n)\)</span></p>
<h4 id="623">6.2.3 分块查找<a class="headerlink" href="#623" title="Permanent link">&para;</a></h4>
<p><code>分块查找</code>，又叫<code>索引顺序查找</code>。</p>
<p><code>算法思想</code>：用一个<code>索引表</code>给数据归类。</p>
<p>算法过程：
- ①在<code>索引表</code>中确定待查记录所属的分块（<code>可顺序、可折半</code>）
- ②在<code>块内顺序查找</code></p>
<p><img alt="uTools_1638257539381" src="../../images/uTools_1638257539381.png" /></p>
<h5 id="_112">用折半查找索引表：<a class="headerlink" href="#_112" title="Permanent link">&para;</a></h5>
<p>若索引表中不包含目标关键字，则折半查找索引表<code>最终停在low&gt;high</code>，要<code>在low所指分块中查找</code></p>
<h5 id="_113">查找效率分析<a class="headerlink" href="#_113" title="Permanent link">&para;</a></h5>
<p><img alt="uTools_1638258212238" src="../../images/uTools_1638258212238.png" /></p>
<p><img alt="uTools_1638258279430" src="../../images/uTools_1638258279430.png" /></p>
<h5 id="_114">分块查找的优化<a class="headerlink" href="#_114" title="Permanent link">&para;</a></h5>
<p>上面的分块查找对插入删除不友好。</p>
<p>改进：索引表为顺序表，查找表为链表。</p>
<p><img alt="1638258852038" src="../../images/1638258852038.jpg" /></p>
<h4 id="624">6.2.4 时间复杂度评价<a class="headerlink" href="#624" title="Permanent link">&para;</a></h4>
<table>
<thead>
<tr>
<th>查找算法</th>
<th><span class="arithmatex">\(ASL_{成功}\)</span></th>
<th><span class="arithmatex">\(ASL_{失败}\)</span></th>
</tr>
</thead>
<tbody>
<tr>
<td>顺序查找-无序表</td>
<td><span class="arithmatex">\(\frac{n+1}{2}\)</span></td>
<td><span class="arithmatex">\(n+1\)</span></td>
</tr>
<tr>
<td>顺序查找-有序表</td>
<td><span class="arithmatex">\(\frac{n+1}{2}\)</span></td>
<td><span class="arithmatex">\(\frac{n} {2} +\frac{n}{n+1}\)</span></td>
</tr>
<tr>
<td>折半查找</td>
<td><span class="arithmatex">\(sum(圆形结点*对应层数)/n\)</span></td>
<td><span class="arithmatex">\(sum(方结点∗对应层数−1)/(n+1)\)</span></td>
</tr>
<tr>
<td>分块查找</td>
<td><span class="arithmatex">\(ASL=L_I+L_S\)</span></td>
<td>-</td>
</tr>
</tbody>
</table>
<h3 id="63-b-b">6.3 B 树和 B + 树<a class="headerlink" href="#63-b-b" title="Permanent link">&para;</a></h3>
<h4 id="631-b">6.3.1 B 树及其基本操作<a class="headerlink" href="#631-b" title="Permanent link">&para;</a></h4>
<p>B 树又称<strong>多路平衡查找树</strong>，B 树中所有结点的孩子个数的最大值称为 B 树的阶，通常用<code>m</code>表示。</p>
<p>B 树是所有结点的平衡因子都等于 0 的多路平衡查找树</p>
<h5 id="_115">定义<a class="headerlink" href="#_115" title="Permanent link">&para;</a></h5>
<p><img alt="f" src="../../images/v2-ed4c157ae0382c3c3451a6d2f48e337b_b.jpg" />
* 树中每个结点至多有 m 棵子树，即至多含有 m-1 个关键字
* 若根结点不是终端节点，则至少有两棵子树
* 除根结点外的所有非叶结点至少有 <span class="arithmatex">\(\lceil m/2 \rceil\)</span>棵子树，即至少含有 <span class="arithmatex">\(\lceil m/2 \rceil-1\)</span> 个关键字
* 所有非叶子结点的结构如下:
<span class="arithmatex">\(n\)</span> | <span class="arithmatex">\(P_0\)</span> | <span class="arithmatex">\(K_1\)</span> | <span class="arithmatex">\(P_1\)</span> |<span class="arithmatex">\(K_2\)</span> | <span class="arithmatex">\(P_2\)</span> |<span class="arithmatex">\(...\)</span> | <span class="arithmatex">\(K_n\)</span> | <span class="arithmatex">\(P_n\)</span>
 其中， <span class="arithmatex">\(K_i\)</span>为结点的关键字， <span class="arithmatex">\(P_i\)</span>​为指向子树根结点的指针，且:
    - 指针 <span class="arithmatex">\(P_{i-1}\)</span> ​所指子树中所有结点的关键字均小于 <span class="arithmatex">\(K_i\)</span>
    - 指针<span class="arithmatex">\(P_i\)</span>​所指子树中所有结点的关键字均大于 <span class="arithmatex">\(K_i\)</span>​
    - 结点的孩子个数等于该节点中关键字个数加 1</p>
<ul>
<li>所有的叶节点都出现在同一层次上，并且不带信息，称为外部结点</li>
</ul>
<h5 id="b">B 树的高度<a class="headerlink" href="#b" title="Permanent link">&para;</a></h5>
<p>B 树的高度不包括最后的外部结点那一层</p>
<p><span class="arithmatex">\(\log_m(n+1) \leq h \leq \log_{\lceil m/2\rceil}((n+1)/2)+1\)</span></p>
<h5 id="b_1">B 树的查找<a class="headerlink" href="#b_1" title="Permanent link">&para;</a></h5>
<ul>
<li>在 B 树中找结点，在磁盘中进行</li>
<li>在结点在找关键字，在内存中进行</li>
</ul>
<h5 id="b_2">B 树的插入<a class="headerlink" href="#b_2" title="Permanent link">&para;</a></h5>
<ol>
<li>定位：利用 B 树的查找算法，找出插入该关键字的最低层中的某个非叶结点</li>
<li>插入：在 B 树中，每个失败结点的关键字个数都在区间 <span class="arithmatex">\([\ \lceil m/\rceil-1.m-1]\)</span> 内。插入后的结点关键字个数小于 m，可以直接插入。如果插入后关键字个数大于<code>m-1</code>, 必须进行分裂</li>
<li>分裂方法是<ul>
<li>取一个新结点，在插入 key 后的原结点，从中间位置将其中的关键字分为两部分</li>
<li>左部分包含的关键字放在原结点中，右部分包含的关键字放到新结点中</li>
<li>中间位置 1 的节点插入原节点的父节点。</li>
<li>若此时导致父节点也超过了上限，则对父节点继续分裂
<img alt="" src="../../images/v2-20c52fd3a6f984111eb8b9fb8d052bfd_r.jpg" />
<img alt="" src="../../images/v2-b108319de2a49504f01c1073999f7319_r.jpg" /></li>
</ul>
</li>
</ol>
<h5 id="b_3">B 树的删除<a class="headerlink" href="#b_3" title="Permanent link">&para;</a></h5>
<ul>
<li>
<p>当被删关键字<code>k</code><strong>不在终端结点</strong>时，可以用 k 的前驱或后继<code>k'</code>替代<code>k</code>, 然后在相应的结点中删除<code>k'</code>。关键字<code>k'</code>必定落在某个终端节点中，则转换成了被删关键字在终端结点中的情形
<img alt="" src="../../images/v2-38e3307125dbdda94e581440a099145b_r.jpg" /></p>
</li>
<li>
<p>当被删关键字<code>k</code><strong>在终端结点</strong>中时</p>
<ul>
<li>
<p><strong>直接删除关键字</strong>：若被删除关键字所在结点的关键字个数 &gt; <span class="arithmatex">\(\lceil m/2 \rceil\)</span>, 表明删除该关键字后仍满足 B 树的定义，则直接是删除该关键字</p>
</li>
<li>
<p><strong>兄弟够借</strong>：若被删除关键字所在结点的关键字个数 = <span class="arithmatex">\(\lceil m/2 \rceil-1\)</span>, 且与此节点相邻的右（左）兄弟节点的关键字个数 <span class="arithmatex">\(\geq \lceil m/2 \rceil\)</span>, 则需要调整该节点、右（左）兄弟结点及其双亲结点（父子换位法），以达到新的平衡
<img alt="" src="../../images/v2-1375aefdf486f8a76801fd460c843a7a_b.jpg" /></p>
</li>
<li><strong>兄弟不够借</strong>：若被删除关键字所在结点的关键字个数 = <span class="arithmatex">\(\lceil m/2 \rceil-1\)</span>, 且与此节点相邻的右（左）兄弟节点的关键字个数均 <span class="arithmatex">\(\lceil m/2 \rceil-1\)</span>, 则将关键字删除后与左（或右）兄弟结点及双亲结点中的关键字进行合并。
<img alt="" src="../../images/v2-7cb4ba6217df024401e8c39e457fe4f7_r.jpg" />
<img alt="" src="../../images/v2-a57a6f7ba9a6d9ac9163b014a0b756a3_b.jpg" />
在合并过程中，双亲结点中的关键字个数会减 1。若其双亲结点是根结点且关键字个数减少至 0，则直接将根结点删除，合并后的新结点成为根；若其双亲结点不是根结点，且关键字减少超过下限，在继续合并操作。
<img alt="" src="../../images/v2-faed443f4f805d1eda4be4da6ea4bcd3_r.jpg" />
<img alt="" src="../../images/v2-7048b1c5a0236267367d0edfc70b900c_r.jpg" />
<img alt="" src="../../images/v2-d3fae5bf722b762154ba2719aabe50c7_r.jpg" /></li>
</ul>
</li>
</ul>
<p>B树的构造及操作案例
<img alt="" src="../../images/B%E6%A0%91%E7%9A%84%E6%9E%84%E5%BB%BA%E6%A1%88%E4%BE%8B-1.jpg" />
<img alt="" src="../../images/B%E6%A0%91%E7%9A%84%E6%9E%84%E5%BB%BA%E6%A1%88%E4%BE%8B-2.jpg" /></p>
<h4 id="632-b">6.3.2 B + 树的基本概念<a class="headerlink" href="#632-b" title="Permanent link">&para;</a></h4>
<p><img alt="" src="../../images/v2-3cd45a5fd8b705768ca89d44e6c69edf_r.jpg" />
* 每个分支结点最多有 m 棵子树
* 非叶根结点至少有两棵子树，其他每个分支结点至少有 <span class="arithmatex">\(\lceil m/2 \rceil\)</span>棵子树
* 结点的子树个数与关键字个数相等
* 所有叶结点包含全部关键字及指向相应记录的指针，叶节点中将关键字按大小顺序排列，并且相邻叶节点按大小顺序相互链接起来
* 所有分支结点中仅包含它的各个子节点中关键字的最大值及指向其子结点的指针</p>
<p>在 B + 树中查找时，非叶结点上的关键字值等于查找值时并不停止，而是继续往下找，直到叶结点上的该关键字为止。无论成功与否，每次查找都是一条从根结点到叶结点的路径</p>
<p>注意B+树存储的记录在叶子节点，路径是索引，不包含记录，相关的插入和删除与B树类似</p>
<h4 id="633-b-vsb">6.3.3 B 树 VSB + 树<a class="headerlink" href="#633-b-vsb" title="Permanent link">&para;</a></h4>
<table>
<thead>
<tr>
<th>说明</th>
<th>B树</th>
<th>B+树</th>
</tr>
</thead>
<tbody>
<tr>
<td>关键字个数为n的结点的子树个数</td>
<td>n-1</td>
<td>n</td>
</tr>
<tr>
<td>结点关键字个数n范围</td>
<td><span class="arithmatex">\(\lceil m/2 \rceil \leq n \leq m\)</span></td>
<td><span class="arithmatex">\(\lceil m/2 \rceil -1\leq n \leq m -1\)</span></td>
</tr>
<tr>
<td>-</td>
<td>-</td>
<td>叶结点包含信息，所有非叶结点仅起索引作用，非叶结点中的每个索引项只含有对应子树的最大关键字和指向该子树的指针，不含有该关键字对应记录的存储地址</td>
</tr>
<tr>
<td>-</td>
<td>叶结点包含的关键字和其他结点包含的关键字是不重复的</td>
<td>叶节点包含了全部关键字，即在非叶结点中出现的关键字也会出现在叶结点中</td>
</tr>
</tbody>
</table>
<h3 id="64">6.4 散列表<a class="headerlink" href="#64" title="Permanent link">&para;</a></h3>
<h4 id="641">6.4.1 散列表的基本概念<a class="headerlink" href="#641" title="Permanent link">&para;</a></h4>
<ul>
<li>散列函数：一个把查找表中关键字映射成该关键字对应的地址的函数，记为<code>Hash(key)=Addr</code></li>
<li>冲突：散列函数把两个或两个以上的不同关键字映射到同一地址的现象</li>
<li>同义词：引起冲突的关键字</li>
<li>散列表：根据关键字而直接进行访问的数据结构。散列表建立了关键字和存储地址之间的一种直接映射关系</li>
</ul>
<h4 id="642">6.4.2 散列函数的构造方法<a class="headerlink" href="#642" title="Permanent link">&para;</a></h4>
<h5 id="_116">散列函数的要求<a class="headerlink" href="#_116" title="Permanent link">&para;</a></h5>
<ul>
<li>定义域包含全部关键字，值域依赖于散列表的大小或地址范围</li>
<li>散列函数计算出的地址应该能等概率、均匀的分布在整个地址空间中，减少冲突发生</li>
<li>尽可能简单，能够快速计算出散列地址</li>
</ul>
<table>
<thead>
<tr>
<th>常见构造函数</th>
<th>公式</th>
<th>评价</th>
</tr>
</thead>
<tbody>
<tr>
<td>直接定地法</td>
<td><span class="arithmatex">\(H(key)=key\)</span> 或H <span class="arithmatex">\(H(key)=a \times key+b\)</span></td>
<td>最简单，不会产生冲突。适合关键字的分布基本连续的情况</td>
</tr>
<tr>
<td>除留余数法</td>
<td><span class="arithmatex">\(H(key)=key\%p\)</span>，<span class="arithmatex">\(p\)</span> 为不大于散列表表长<span class="arithmatex">\(m\)</span>但最接近或等于<span class="arithmatex">\(m\)</span>的质数</td>
<td></td>
</tr>
<tr>
<td>数字分析法</td>
<td>设关键字是r进制数，选取数码分布比较均匀的若干位作为散列地址</td>
<td>适合于一致的关键字集合，若更换了关键字，则需要重新构造新的散列函数</td>
</tr>
<tr>
<td>平方取中法</td>
<td>取关键字对的平方值的中间几位作为散列值</td>
<td>适用于关键字的每位取值都不均匀或均小于散列地址所需的位数</td>
</tr>
</tbody>
</table>
<h4 id="643">6.4.3 处理冲突的方法<a class="headerlink" href="#643" title="Permanent link">&para;</a></h4>
<ul>
<li>开放定址法， <span class="arithmatex">\(H_i=(H(key)+d_i)\%m\)</span>, <span class="arithmatex">\(m\)</span> 表示散列表表长，<span class="arithmatex">\(d_i\)</span>​为增量序列</li>
</ul>
<table>
<thead>
<tr>
<th>开放定址法</th>
<th><span class="arithmatex">\(d_i\)</span></th>
<th>补充说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>线性探测法</td>
<td><span class="arithmatex">\(0,1,2,...,m-1\)</span></td>
<td>可能出现大量元素在相邻地址上聚集，降低查找效率</td>
</tr>
<tr>
<td>平方探测法</td>
<td><span class="arithmatex">\(0^2,1^2,-1^2,2^2,-2^2,...,k^2,-k^2\)</span></td>
<td>散列表长度m必须是一个可以表示成4k+3的素数</td>
</tr>
<tr>
<td>再散列法</td>
<td><span class="arithmatex">\(i*Hash_2(key)\)</span></td>
<td>i是冲突的次数</td>
</tr>
<tr>
<td>伪随机序列法</td>
<td><span class="arithmatex">\(d_i==随机序列\)</span></td>
<td></td>
</tr>
</tbody>
</table>
<ul>
<li>拉链法</li>
</ul>
<p>把所有的同义词存储在一个线性链表中，这个线性链表由其散列地址唯一标识</p>
<h4 id="644">6.4.4 散列查找及性能分析<a class="headerlink" href="#644" title="Permanent link">&para;</a></h4>
<h5 id="_117">查找过程<a class="headerlink" href="#_117" title="Permanent link">&para;</a></h5>
<ol>
<li>初始化<code>Addr=Hash(key)</code></li>
<li>检测查找表中地址为<code>Addr</code>的位置上是否有记录，若无记录，返回查找失败；若有记录。比较它与 key 的值，若相等，则返回查找成功的标志，否则执行步骤 3</li>
<li>用给定的处理冲突方法计算 “下一个散列地址”，并将<code>Addr</code>置为此地址，转入步骤 2</li>
</ol>
<p><strong>散列表的查找效率取决于散列函数、处理冲突的方法和装填因子</strong></p>
<ul>
<li>
<p>装填因子<span class="arithmatex">\(\alpha\)</span>定义为一个表的装满程度<br />
<span class="arithmatex">\(\alpha = \frac{表中记录数 n}{散列表长度 m}\)</span></p>
</li>
<li>
<p>线性探测
<img alt="1638281466946" src="../../images/1638281466946.jpg" />
<img alt="uTools_1638352055034" src="../../images/uTools_1638352055034.png" /></p>
</li>
</ul>
<p><img alt="uTools_1638352323225" src="../../images/uTools_1638352323225.png" /></p>
<p><img alt="uTools_1638352359885" src="../../images/uTools_1638352359885.png" /></p>
<ul>
<li>链地址法
<img alt="1638350479082" src="../../images/1638350479082.jpg" /></li>
</ul>
<h2 id="7">7. 排序<a class="headerlink" href="#7" title="Permanent link">&para;</a></h2>
<h3 id="71">7.1 排序的基本概念<a class="headerlink" href="#71" title="Permanent link">&para;</a></h3>
<ul>
<li>排序：就是重新排列表中的元素，使表中的元素满足按关键字有序的过程</li>
<li>算法的稳定性：在排序之前关键字相同的元素，在排序后相对位置不变的排序算法是稳定的</li>
<li>内部排序：排序期间元素全部存放在内存中的排序</li>
<li>外部排序：排序期间元素无法全部同时同放在内存中，必须在排序的过程中根据要求不断的在内、外存之间移动的排序</li>
<li>可将排序算法分为：插入排序、交换排序、选择排序、归并排序和基数排序五大类</li>
</ul>
<h3 id="72">7.2 插入排序<a class="headerlink" href="#72" title="Permanent link">&para;</a></h3>
<p>基本思想：每次讲一个待排序的记录按其关键字大小插入前面已排好序的子序列，直到全部记录插入完成</p>
<h4 id="721">7.2.1 直接插入排序<a class="headerlink" href="#721" title="Permanent link">&para;</a></h4>
<p>要将<code>L(i)</code>插入已有序的子序列<code>L[1...i-1]</code>，需要执行以下操作</p>
<ul>
<li>
<p>查找出<code>L(i)</code>在<code>L[1...i-1]</code>中的插入位置<code>k</code></p>
</li>
<li>
<p>将<code>L[k...i-1]</code>中的所有元素依次后移一个位置</p>
</li>
<li>
<p>将<code>L(i)</code>复制到<code>L(k)</code>
<img alt="" src="../../images/%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E6%A1%88%E4%BE%8B.jpg" /></p>
</li>
</ul>
<div class="highlight"><pre><span></span><code><a id="__codelineno-47-1" name="__codelineno-47-1" href="#__codelineno-47-1"></a><span class="kt">void</span><span class="w"> </span><span class="nf">InsertSort</span><span class="p">(</span><span class="n">ElemType</span><span class="w"> </span><span class="n">A</span><span class="p">[],</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">){</span><span class="w"></span>
<a id="__codelineno-47-2" name="__codelineno-47-2" href="#__codelineno-47-2"></a><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-47-3" name="__codelineno-47-3" href="#__codelineno-47-3"></a><span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">2</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w">    </span><span class="c1">//依次将A[2]...A[n]插入到前面已排序的序列</span>
<a id="__codelineno-47-4" name="__codelineno-47-4" href="#__codelineno-47-4"></a><span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="mi">-1</span><span class="p">]){</span><span class="w">    </span><span class="c1">//若A[i]小于前驱，则将其插入前面的有序表</span>
<a id="__codelineno-47-5" name="__codelineno-47-5" href="#__codelineno-47-5"></a><span class="w">            </span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w">    </span><span class="c1">//哨兵</span>
<a id="__codelineno-47-6" name="__codelineno-47-6" href="#__codelineno-47-6"></a><span class="w">            </span><span class="k">for</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="mi">-1</span><span class="p">;</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&lt;</span><span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">];</span><span class="o">--</span><span class="n">j</span><span class="p">)</span><span class="w">    </span><span class="c1">//从i-1开始比较，比较一次，向后移动一次</span>
<a id="__codelineno-47-7" name="__codelineno-47-7" href="#__codelineno-47-7"></a><span class="w">                </span><span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">];</span><span class="w">    </span>
<a id="__codelineno-47-8" name="__codelineno-47-8" href="#__codelineno-47-8"></a><span class="w">            </span><span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w">        </span><span class="c1">//找到插入位置，赋值</span>
<a id="__codelineno-47-9" name="__codelineno-47-9" href="#__codelineno-47-9"></a><span class="w">        </span><span class="p">}</span><span class="w"></span>
<a id="__codelineno-47-10" name="__codelineno-47-10" href="#__codelineno-47-10"></a><span class="p">}</span><span class="w"></span>
</code></pre></div>
<h4 id="722">7.2.2 折半插入排序<a class="headerlink" href="#722" title="Permanent link">&para;</a></h4>
<ul>
<li>查找有序子表时用折半查找来实现</li>
<li>确定待插入位置后，同意以地向后移动元素</li>
</ul>
<div class="highlight"><pre><span></span><code><a id="__codelineno-48-1" name="__codelineno-48-1" href="#__codelineno-48-1"></a><span class="kt">void</span><span class="w"> </span><span class="nf">InsertSort</span><span class="p">(</span><span class="n">ElemType</span><span class="w"> </span><span class="n">A</span><span class="p">[],</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">){</span><span class="w"></span>
<a id="__codelineno-48-2" name="__codelineno-48-2" href="#__codelineno-48-2"></a><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">low</span><span class="p">,</span><span class="n">high</span><span class="p">,</span><span class="n">mid</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-48-3" name="__codelineno-48-3" href="#__codelineno-48-3"></a><span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">2</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span><span class="w">        </span><span class="c1">//依次将A[2]...A[n]插入到前面已排序的序列</span>
<a id="__codelineno-48-4" name="__codelineno-48-4" href="#__codelineno-48-4"></a><span class="w">        </span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w">        </span><span class="c1">//暂存单元，不是哨兵</span>
<a id="__codelineno-48-5" name="__codelineno-48-5" href="#__codelineno-48-5"></a><span class="w">        </span><span class="n">low</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="n">high</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="mi">-1</span><span class="p">;</span><span class="w">    </span>
<a id="__codelineno-48-6" name="__codelineno-48-6" href="#__codelineno-48-6"></a><span class="w">        </span><span class="k">while</span><span class="p">(</span><span class="n">low</span><span class="o">&lt;=</span><span class="n">high</span><span class="p">){</span><span class="w">        </span><span class="c1">//折半查找</span>
<a id="__codelineno-48-7" name="__codelineno-48-7" href="#__codelineno-48-7"></a><span class="w">            </span><span class="n">mid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">low</span><span class="o">+</span><span class="n">high</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-48-8" name="__codelineno-48-8" href="#__codelineno-48-8"></a><span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">min</span><span class="p">]</span><span class="o">&gt;</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="w"> </span><span class="n">high</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mid</span><span class="mi">-1</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-48-9" name="__codelineno-48-9" href="#__codelineno-48-9"></a><span class="w">            </span><span class="k">else</span><span class="w"> </span><span class="n">low</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-48-10" name="__codelineno-48-10" href="#__codelineno-48-10"></a><span class="w">        </span><span class="p">}</span><span class="w"></span>
<a id="__codelineno-48-11" name="__codelineno-48-11" href="#__codelineno-48-11"></a><span class="w">        </span><span class="k">for</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="mi">-1</span><span class="p">;</span><span class="n">j</span><span class="o">&gt;=</span><span class="n">high</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span><span class="o">--</span><span class="n">j</span><span class="p">)</span><span class="w">    </span><span class="c1">//统一后移元素</span>
<a id="__codelineno-48-12" name="__codelineno-48-12" href="#__codelineno-48-12"></a><span class="w">            </span><span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">];</span><span class="w"></span>
<a id="__codelineno-48-13" name="__codelineno-48-13" href="#__codelineno-48-13"></a><span class="w">        </span><span class="n">A</span><span class="p">[</span><span class="n">high</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w">            </span><span class="c1">//赋值</span>
<a id="__codelineno-48-14" name="__codelineno-48-14" href="#__codelineno-48-14"></a><span class="w">    </span><span class="p">}</span><span class="w"></span>
<a id="__codelineno-48-15" name="__codelineno-48-15" href="#__codelineno-48-15"></a><span class="p">}</span><span class="w"></span>
</code></pre></div>
<h4 id="723">7.2.3 希尔排序<a class="headerlink" href="#723" title="Permanent link">&para;</a></h4>
<p>基本思想：先将待排序表分割成若干形如<code>L[i,i+d,i+2d,...,i+kd]</code>的特殊子表，即把相隔某个 “增量” 的记录组成一个子表，对每个子表分别进行直接插入排序，当整个表中的元素已呈 “毕本有序” 时，再对全体记录进行一次直接插入排序</p>
<p><strong>过程</strong></p>
<ul>
<li>先取一个小于 n 的步长 <span class="arithmatex">\(d_1\)</span>​, 把表中的全部记录分成 <span class="arithmatex">\(d_1\)</span>​组，所有距离为 <span class="arithmatex">\(d_1\)</span>​的倍数的记录放在同一组，在各组内进行直接插入排序</li>
<li>然后取第二个步长 <span class="arithmatex">\(d_2&lt;d_1\)</span>​.</li>
<li>重复上述过程，直到所取到的 <span class="arithmatex">\(d_t=1\)</span>，即所有记录已放在同一组，再进行直接插入排序</li>
</ul>
<p><strong>增量序列：</strong> <span class="arithmatex">\(d_1=n/2,d_{i+1}=\lfloor d_i/2 \rfloor\)</span>, 最后一个增量等于 1</p>
<p><img alt="" src="../../images/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%E6%A1%88%E4%BE%8B.jpg" /></p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-49-1" name="__codelineno-49-1" href="#__codelineno-49-1"></a><span class="kt">void</span><span class="w"> </span><span class="nf">ShellSort</span><span class="p">(</span><span class="n">ElemType</span><span class="w"> </span><span class="n">A</span><span class="p">[],</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">){</span><span class="w"></span>
<a id="__codelineno-49-2" name="__codelineno-49-2" href="#__codelineno-49-2"></a><span class="w">    </span><span class="c1">//A[0]只是暂存单元，不是哨兵</span>
<a id="__codelineno-49-3" name="__codelineno-49-3" href="#__codelineno-49-3"></a><span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="n">dk</span><span class="o">=</span><span class="n">n</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span><span class="n">dk</span><span class="o">&gt;=</span><span class="mi">1</span><span class="p">;</span><span class="n">dk</span><span class="o">=</span><span class="n">dk</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="w">        </span><span class="c1">//步长变换</span>
<a id="__codelineno-49-4" name="__codelineno-49-4" href="#__codelineno-49-4"></a><span class="w">        </span><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="n">dk</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w">        </span><span class="c1">//对d_i个组进行直接插入排序</span>
<a id="__codelineno-49-5" name="__codelineno-49-5" href="#__codelineno-49-5"></a><span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="n">dk</span><span class="p">]){</span><span class="w">        </span><span class="c1">//需要将A[i]插入所在的有序子表中</span>
<a id="__codelineno-49-6" name="__codelineno-49-6" href="#__codelineno-49-6"></a><span class="w">                </span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w">        </span><span class="c1">//暂存A[i]</span>
<a id="__codelineno-49-7" name="__codelineno-49-7" href="#__codelineno-49-7"></a><span class="w">                </span><span class="k">for</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="o">-</span><span class="n">dk</span><span class="p">;</span><span class="n">j</span><span class="o">&gt;</span><span class="mi">0</span><span class="o">&amp;&amp;</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&lt;</span><span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">];</span><span class="n">j</span><span class="o">-=</span><span class="n">dk</span><span class="p">)</span><span class="c1">//寻找插入位置</span>
<a id="__codelineno-49-8" name="__codelineno-49-8" href="#__codelineno-49-8"></a><span class="w">                    </span><span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="n">dk</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">];</span><span class="w">        </span><span class="c1">//记录后移</span>
<a id="__codelineno-49-9" name="__codelineno-49-9" href="#__codelineno-49-9"></a><span class="w">                </span><span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="n">dk</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w">            </span><span class="c1">//插入</span>
<a id="__codelineno-49-10" name="__codelineno-49-10" href="#__codelineno-49-10"></a><span class="w">            </span><span class="p">}</span><span class="w"></span>
<a id="__codelineno-49-11" name="__codelineno-49-11" href="#__codelineno-49-11"></a><span class="p">}</span><span class="w"></span>
</code></pre></div>
<h3 id="73">7.3 交换排序<a class="headerlink" href="#73" title="Permanent link">&para;</a></h3>
<h4 id="731">7.3.1 冒泡排序<a class="headerlink" href="#731" title="Permanent link">&para;</a></h4>
<p>基本思想：从后往前（或从前往后）两两比较相邻元素的值，若为逆序则交换，指导序列比较完。</p>
<p><img alt="" src="../../images/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E6%A1%88%E4%BE%8B.jpg" /></p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-50-1" name="__codelineno-50-1" href="#__codelineno-50-1"></a><span class="kt">void</span><span class="w"> </span><span class="nf">BubbleSort</span><span class="p">(</span><span class="n">ElemType</span><span class="w"> </span><span class="n">A</span><span class="p">[],</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">){</span><span class="w"></span>
<a id="__codelineno-50-2" name="__codelineno-50-2" href="#__codelineno-50-2"></a><span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="mi">-1</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span><span class="w"></span>
<a id="__codelineno-50-3" name="__codelineno-50-3" href="#__codelineno-50-3"></a><span class="w">        </span><span class="n">flag</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w">                </span><span class="c1">//表示本趟冒泡是否发生交换的标志</span>
<a id="__codelineno-50-4" name="__codelineno-50-4" href="#__codelineno-50-4"></a><span class="w">        </span><span class="k">for</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="n">n</span><span class="mi">-1</span><span class="p">;</span><span class="n">j</span><span class="o">&gt;</span><span class="n">i</span><span class="p">;</span><span class="n">j</span><span class="o">--</span><span class="p">)</span><span class="w">            </span><span class="c1">//一趟冒泡过程</span>
<a id="__codelineno-50-5" name="__codelineno-50-5" href="#__codelineno-50-5"></a><span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="mi">-1</span><span class="p">]</span><span class="o">&gt;</span><span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">]){</span><span class="w">        </span><span class="c1">//若为逆序</span>
<a id="__codelineno-50-6" name="__codelineno-50-6" href="#__codelineno-50-6"></a><span class="w">                </span><span class="n">swap</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="mi">-1</span><span class="p">],</span><span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span><span class="w">    </span><span class="c1">//交换</span>
<a id="__codelineno-50-7" name="__codelineno-50-7" href="#__codelineno-50-7"></a><span class="w">                </span><span class="n">flag</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-50-8" name="__codelineno-50-8" href="#__codelineno-50-8"></a><span class="w">            </span><span class="p">}</span><span class="w"></span>
<a id="__codelineno-50-9" name="__codelineno-50-9" href="#__codelineno-50-9"></a><span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">flag</span><span class="o">==</span><span class="nb">false</span><span class="p">)</span><span class="w"></span>
<a id="__codelineno-50-10" name="__codelineno-50-10" href="#__codelineno-50-10"></a><span class="w">            </span><span class="k">return</span><span class="p">;</span><span class="w">            </span><span class="c1">//本趟遍历后没有发生交换，说明表已经有序</span>
<a id="__codelineno-50-11" name="__codelineno-50-11" href="#__codelineno-50-11"></a><span class="w">    </span><span class="p">}</span><span class="w"></span>
<a id="__codelineno-50-12" name="__codelineno-50-12" href="#__codelineno-50-12"></a><span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>注意：冒泡排序所产生的有序子序列是全局有序的。每一趟排序都会将一个元素放置到其最终的位置上</p>
<h4 id="732">7.3.2 快速排序<a class="headerlink" href="#732" title="Permanent link">&para;</a></h4>
<p>基本思想：在待排序表<code>L[1...n]</code>中任取一个元素<code>pivot</code>作为<strong>枢轴</strong>, 通过一趟排序将待排序表划分为独立的两个部分<code>L[1...k-1]</code>和<code>L[k+1...n]</code>, 使得<code>L[1...k-1]</code>中的所有元素小于<code>pivot</code>,<code>L[k+1...n]</code>中的所有元素大于等于<code>pivot</code>, 则<code>pivot</code>放在了其最终位置<code>L(k)</code>上，这个过程称为一趟快速排序。然后分别对左右两部分重复上述过程，直到每个部分只有一个元素。</p>
<p><img alt="" src="../../images/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E6%A1%88%E4%BE%8B.jpg" /></p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-51-1" name="__codelineno-51-1" href="#__codelineno-51-1"></a><span class="kt">void</span><span class="w"> </span><span class="nf">QuickSort</span><span class="p">(</span><span class="n">ElemType</span><span class="w"> </span><span class="n">A</span><span class="p">[],</span><span class="kt">int</span><span class="w"> </span><span class="n">low</span><span class="p">,</span><span class="kt">int</span><span class="w"> </span><span class="n">high</span><span class="p">){</span><span class="w"></span>
<a id="__codelineno-51-2" name="__codelineno-51-2" href="#__codelineno-51-2"></a><span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">low</span><span class="o">&lt;</span><span class="n">high</span><span class="p">){</span><span class="w"></span>
<a id="__codelineno-51-3" name="__codelineno-51-3" href="#__codelineno-51-3"></a><span class="w">        </span><span class="c1">//Partition()就是划分操作，将表划分成满足条件的两个子表</span>
<a id="__codelineno-51-4" name="__codelineno-51-4" href="#__codelineno-51-4"></a><span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">pivotpos</span><span class="o">=</span><span class="n">Partition</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">low</span><span class="p">,</span><span class="n">high</span><span class="p">);</span><span class="w">    </span><span class="c1">//划分</span>
<a id="__codelineno-51-5" name="__codelineno-51-5" href="#__codelineno-51-5"></a><span class="w">        </span><span class="n">QuickSort</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">low</span><span class="p">,</span><span class="n">pivotpos</span><span class="mi">-1</span><span class="p">);</span><span class="w"></span>
<a id="__codelineno-51-6" name="__codelineno-51-6" href="#__codelineno-51-6"></a><span class="w">        </span><span class="n">QuickSort</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">pivots</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">high</span><span class="p">);</span><span class="w"></span>
<a id="__codelineno-51-7" name="__codelineno-51-7" href="#__codelineno-51-7"></a><span class="w">    </span><span class="p">}</span><span class="w"></span>
<a id="__codelineno-51-8" name="__codelineno-51-8" href="#__codelineno-51-8"></a><span class="p">}</span><span class="w"></span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><a id="__codelineno-52-1" name="__codelineno-52-1" href="#__codelineno-52-1"></a><span class="kt">int</span><span class="w"> </span><span class="nf">Partition</span><span class="p">(</span><span class="n">ElemType</span><span class="w"> </span><span class="n">A</span><span class="p">[],</span><span class="kt">int</span><span class="w"> </span><span class="n">low</span><span class="p">,</span><span class="kt">int</span><span class="w"> </span><span class="n">high</span><span class="p">){</span><span class="w">    </span><span class="c1">//一趟划分</span>
<a id="__codelineno-52-2" name="__codelineno-52-2" href="#__codelineno-52-2"></a><span class="w">    </span><span class="n">ElemType</span><span class="w"> </span><span class="n">pivot</span><span class="o">=</span><span class="n">A</span><span class="p">[</span><span class="n">low</span><span class="p">];</span><span class="w"></span>
<a id="__codelineno-52-3" name="__codelineno-52-3" href="#__codelineno-52-3"></a><span class="w">    </span><span class="k">while</span><span class="p">(</span><span class="n">low</span><span class="o">&lt;</span><span class="n">high</span><span class="p">){</span><span class="w"></span>
<a id="__codelineno-52-4" name="__codelineno-52-4" href="#__codelineno-52-4"></a><span class="w">        </span><span class="k">while</span><span class="p">(</span><span class="n">low</span><span class="o">&lt;</span><span class="n">high</span><span class="o">&amp;&amp;</span><span class="n">A</span><span class="p">[</span><span class="n">high</span><span class="p">]</span><span class="o">&gt;=</span><span class="n">pivot</span><span class="p">)</span><span class="w"> </span><span class="o">--</span><span class="n">high</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-52-5" name="__codelineno-52-5" href="#__codelineno-52-5"></a><span class="w">        </span><span class="n">A</span><span class="p">[</span><span class="n">low</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="n">high</span><span class="p">];</span><span class="w">        </span><span class="c1">//将比枢轴小的元素移动到左边</span>
<a id="__codelineno-52-6" name="__codelineno-52-6" href="#__codelineno-52-6"></a><span class="w">        </span><span class="k">while</span><span class="p">(</span><span class="n">low</span><span class="o">&lt;</span><span class="n">high</span><span class="o">&amp;&amp;</span><span class="n">A</span><span class="p">[</span><span class="n">low</span><span class="p">]</span><span class="o">&lt;=</span><span class="n">pivot</span><span class="p">)</span><span class="w"> </span><span class="o">++</span><span class="n">low</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-52-7" name="__codelineno-52-7" href="#__codelineno-52-7"></a><span class="w">        </span><span class="n">A</span><span class="p">[</span><span class="n">high</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="n">low</span><span class="p">];</span><span class="w">        </span><span class="c1">//将比枢轴大的元素移动到右边</span>
<a id="__codelineno-52-8" name="__codelineno-52-8" href="#__codelineno-52-8"></a><span class="w">    </span><span class="p">}</span><span class="w"></span>
<a id="__codelineno-52-9" name="__codelineno-52-9" href="#__codelineno-52-9"></a><span class="w">    </span><span class="n">A</span><span class="p">[</span><span class="n">low</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pivot</span><span class="p">;</span><span class="w">            </span><span class="c1">//枢轴放到最终位置</span>
<a id="__codelineno-52-10" name="__codelineno-52-10" href="#__codelineno-52-10"></a><span class="w">    </span><span class="n">reutrn</span><span class="w"> </span><span class="n">low</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-52-11" name="__codelineno-52-11" href="#__codelineno-52-11"></a><span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>快速排序是所有内部排序算法中平均性能最优的排序算法</p>
<h4 id="74">7.4 选择排序<a class="headerlink" href="#74" title="Permanent link">&para;</a></h4>
<h4 id="741">7.4.1 简单选择排序<a class="headerlink" href="#741" title="Permanent link">&para;</a></h4>
<p>基本思想：假设排序表为<code>L[1...n]</code>, 第<code>i</code>趟排序即从<code>L[i...n]</code>中选择关键字最小的元素与<code>L(i)</code>交换，每一趟排序可以确定一个元素的最终位置，经过 n-1 趟排序可以使整个排序表有序</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-53-1" name="__codelineno-53-1" href="#__codelineno-53-1"></a><span class="kt">void</span><span class="w"> </span><span class="nf">SelectSort</span><span class="p">(</span><span class="n">ElemType</span><span class="w"> </span><span class="n">A</span><span class="p">[],</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">){</span><span class="w"></span>
<a id="__codelineno-53-2" name="__codelineno-53-2" href="#__codelineno-53-2"></a><span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="mi">-1</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span><span class="w">                </span><span class="c1">//一共进行n-1趟</span>
<a id="__codelineno-53-3" name="__codelineno-53-3" href="#__codelineno-53-3"></a><span class="w">        </span><span class="n">min</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w">                    </span><span class="c1">//记录最小元素位置</span>
<a id="__codelineno-53-4" name="__codelineno-53-4" href="#__codelineno-53-4"></a><span class="w">        </span><span class="k">for</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">)</span><span class="w">            </span><span class="c1">//在A[1...n-1]中选择最小的元素</span>
<a id="__codelineno-53-5" name="__codelineno-53-5" href="#__codelineno-53-5"></a><span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">&lt;</span><span class="n">A</span><span class="p">[</span><span class="n">min</span><span class="p">])</span><span class="w"> </span><span class="n">min</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">j</span><span class="p">;</span><span class="w">    </span><span class="c1">//更新最小的元素</span>
<a id="__codelineno-53-6" name="__codelineno-53-6" href="#__codelineno-53-6"></a><span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">min</span><span class="o">!=</span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="n">swap</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">A</span><span class="p">[</span><span class="n">min</span><span class="p">]);</span><span class="w">    </span><span class="c1">//封装的swap()函数共移动3次</span>
<a id="__codelineno-53-7" name="__codelineno-53-7" href="#__codelineno-53-7"></a><span class="w">    </span><span class="p">}</span><span class="w"></span>
<a id="__codelineno-53-8" name="__codelineno-53-8" href="#__codelineno-53-8"></a><span class="p">}</span><span class="w"></span>
</code></pre></div>
<h4 id="742">7.4.2 堆排序<a class="headerlink" href="#742" title="Permanent link">&para;</a></h4>
<ul>
<li>
<p>大根堆：<code>L(i)&gt;=L(2i) &amp; L(i)&gt;=L(2i+1)</code>, 最大元素在根结点</p>
</li>
<li>
<p>小根堆：<code>L(i)&lt;=L(2i) &amp; L(i)&lt;=L(2i+1)</code>, 最小元素在根结点</p>
</li>
<li>
<p>堆的插入：把新结点放到堆的末端，后进行向上调整</p>
</li>
<li>
<p>构造初始堆：</p>
<ul>
<li>n 个结点的完全二叉树，最后一个结点是第 <span class="arithmatex">\(\lfloor n/2 \rfloor\)</span>个结点的孩子。对第<span class="arithmatex">\(\lfloor n/2 \rfloor\)</span>个结点为根的子树筛选（对于的大根堆，若根结点的关键字小于左右孩子中关键字较大者，则交换），使该子树成为堆。</li>
<li>之后向前依次对各节点<span class="arithmatex">\(\lfloor n/2 \rfloor-1 \sim 1\)</span> 为根的子树进行筛选，看该结点值是否大于其左右子节点的值，不大于的话进行交换</li>
<li>交换后可能会破坏下一级的堆，使用上述办法继续构造下一级的堆，直到以根结点形成堆为止</li>
</ul>
</li>
<li>
<p>输出堆顶元素，重新构建堆，重复这一过程</p>
</li>
</ul>
<p><img alt="" src="../../images/%E5%A4%A7%E9%A1%B6%E5%A0%86%E7%9A%84%E5%BB%BA%E7%AB%8B%E5%8F%8A%E8%B0%83%E6%95%B4.jpg" /></p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-54-1" name="__codelineno-54-1" href="#__codelineno-54-1"></a><span class="kt">void</span><span class="w"> </span><span class="nf">BuildMaxHead</span><span class="p">(</span><span class="n">ElemType</span><span class="w"> </span><span class="n">A</span><span class="p">[],</span><span class="kt">int</span><span class="w"> </span><span class="n">len</span><span class="p">){</span><span class="w"></span>
<a id="__codelineno-54-2" name="__codelineno-54-2" href="#__codelineno-54-2"></a><span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="n">len</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span><span class="n">i</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">--</span><span class="p">)</span><span class="w">    </span><span class="c1">//从i=n/2开始，反复调整堆</span>
<a id="__codelineno-54-3" name="__codelineno-54-3" href="#__codelineno-54-3"></a><span class="w">        </span><span class="n">HeadAdjust</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">len</span><span class="p">);</span><span class="w">    </span>
<a id="__codelineno-54-4" name="__codelineno-54-4" href="#__codelineno-54-4"></a><span class="p">}</span><span class="w"></span>
<a id="__codelineno-54-5" name="__codelineno-54-5" href="#__codelineno-54-5"></a><span class="kt">void</span><span class="w"> </span><span class="nf">HeadAdjust</span><span class="p">(</span><span class="n">ElemType</span><span class="w"> </span><span class="n">A</span><span class="p">[],</span><span class="kt">int</span><span class="w"> </span><span class="n">k</span><span class="p">,</span><span class="kt">int</span><span class="w"> </span><span class="n">len</span><span class="p">){</span><span class="w"></span>
<a id="__codelineno-54-6" name="__codelineno-54-6" href="#__codelineno-54-6"></a><span class="w">    </span><span class="c1">//将元素k为根的子树进行调整</span>
<a id="__codelineno-54-7" name="__codelineno-54-7" href="#__codelineno-54-7"></a><span class="w">    </span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="n">k</span><span class="p">];</span><span class="w">    </span><span class="c1">//A[0]暂存子树的根节点</span>
<a id="__codelineno-54-8" name="__codelineno-54-8" href="#__codelineno-54-8"></a><span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">2</span><span class="o">*</span><span class="n">k</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">len</span><span class="p">;</span><span class="n">i</span><span class="o">*</span><span class="mi">2</span><span class="p">){</span><span class="w">        </span><span class="c1">//沿key较大的子节点向下筛选</span>
<a id="__codelineno-54-9" name="__codelineno-54-9" href="#__codelineno-54-9"></a><span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="o">&lt;</span><span class="n">len</span><span class="o">&amp;&amp;</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span><span class="n">i</span><span class="o">++</span><span class="p">;</span><span class="w">    </span><span class="c1">//取i为较大子结点</span>
<a id="__codelineno-54-10" name="__codelineno-54-10" href="#__codelineno-54-10"></a><span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&gt;=</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="k">break</span><span class="p">;</span><span class="w">    </span><span class="c1">//筛选结束</span>
<a id="__codelineno-54-11" name="__codelineno-54-11" href="#__codelineno-54-11"></a><span class="w">        </span><span class="k">else</span><span class="p">{</span><span class="w"></span>
<a id="__codelineno-54-12" name="__codelineno-54-12" href="#__codelineno-54-12"></a><span class="w">            </span><span class="n">A</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">=</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w">            </span><span class="c1">//将A[i]调整到双亲结点上</span>
<a id="__codelineno-54-13" name="__codelineno-54-13" href="#__codelineno-54-13"></a><span class="w">            </span><span class="n">k</span><span class="o">=</span><span class="n">i</span><span class="p">;</span><span class="w">        </span><span class="c1">//修改k值，继续向下筛选</span>
<a id="__codelineno-54-14" name="__codelineno-54-14" href="#__codelineno-54-14"></a><span class="w">        </span><span class="p">}</span><span class="w"></span>
<a id="__codelineno-54-15" name="__codelineno-54-15" href="#__codelineno-54-15"></a><span class="w">    </span><span class="p">}</span><span class="w"></span>
<a id="__codelineno-54-16" name="__codelineno-54-16" href="#__codelineno-54-16"></a><span class="w">    </span><span class="n">A</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w">        </span><span class="c1">//被筛选结点的值放入最终位置</span>
<a id="__codelineno-54-17" name="__codelineno-54-17" href="#__codelineno-54-17"></a><span class="p">}</span><span class="w"></span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><a id="__codelineno-55-1" name="__codelineno-55-1" href="#__codelineno-55-1"></a><span class="kt">void</span><span class="w"> </span><span class="nf">HeapSort</span><span class="p">(</span><span class="n">ElemType</span><span class="w"> </span><span class="n">A</span><span class="p">[],</span><span class="kt">int</span><span class="w"> </span><span class="n">len</span><span class="p">){</span><span class="w"></span>
<a id="__codelineno-55-2" name="__codelineno-55-2" href="#__codelineno-55-2"></a><span class="w">    </span><span class="n">BuildMAxHeap</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">len</span><span class="p">);</span><span class="w"></span>
<a id="__codelineno-55-3" name="__codelineno-55-3" href="#__codelineno-55-3"></a><span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="n">len</span><span class="p">;</span><span class="n">i</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">--</span><span class="p">){</span><span class="w">        </span><span class="c1">//n-1趟的交换和建堆过程</span>
<a id="__codelineno-55-4" name="__codelineno-55-4" href="#__codelineno-55-4"></a><span class="w">        </span><span class="n">Swap</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span><span class="w">    </span><span class="c1">//输出堆顶元素，和堆底元素交换</span>
<a id="__codelineno-55-5" name="__codelineno-55-5" href="#__codelineno-55-5"></a><span class="w">        </span><span class="n">HeadAdjust</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="mi">-1</span><span class="p">);</span><span class="c1">//调整，把剩余的i-1个元素整理成堆</span>
<a id="__codelineno-55-6" name="__codelineno-55-6" href="#__codelineno-55-6"></a><span class="w">    </span><span class="p">}</span><span class="w"></span>
<a id="__codelineno-55-7" name="__codelineno-55-7" href="#__codelineno-55-7"></a><span class="p">}</span><span class="w"></span>
</code></pre></div>
<h3 id="75">7.5 归并排序和基数排序<a class="headerlink" href="#75" title="Permanent link">&para;</a></h3>
<h4 id="751">7.5.1 归并排序<a class="headerlink" href="#751" title="Permanent link">&para;</a></h4>
<p>假定待排序表含有 n 个记录，则可将其视为 n 个有序的子表，每个子表的长度为 1，然后两两合并，得到 <span class="arithmatex">\(\lceil n/2 \rceil\)</span>个长度为 2 或 1 的有序表，继续两两合并。这种排序方法称为 2 路归并排序。</p>
<p>一趟归并排序的操作是，调用 <span class="arithmatex">\(\lceil n/2h \rceil\)</span> 次算法<code>merge()</code>, 将<code>L[1...n]</code>中前后相邻且长度为 h 的有序段进行两两归并，得到前后相邻、长度为 2h 的有序段进行两两归并，得到前后相邻、长度为 2h 的有序段，整个归并排序需要进行 <span class="arithmatex">\(\lceil log_2n\rceil\)</span>趟</p>
<p><img alt="" src="../../images/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E6%A1%88%E4%BE%8B.jpg" /></p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-56-1" name="__codelineno-56-1" href="#__codelineno-56-1"></a><span class="n">ELemType</span><span class="w"> </span><span class="o">*</span><span class="n">B</span><span class="o">=</span><span class="p">(</span><span class="n">ElemType</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">((</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="n">ElemType</span><span class="p">));</span><span class="w">    </span><span class="c1">//辅助数组B</span>
<a id="__codelineno-56-2" name="__codelineno-56-2" href="#__codelineno-56-2"></a><span class="kt">void</span><span class="w"> </span><span class="nf">Merge</span><span class="p">(</span><span class="n">ElemType</span><span class="w"> </span><span class="n">A</span><span class="p">[],</span><span class="kt">int</span><span class="w"> </span><span class="n">low</span><span class="p">,</span><span class="kt">int</span><span class="w"> </span><span class="n">mid</span><span class="p">,</span><span class="kt">int</span><span class="w"> </span><span class="n">high</span><span class="p">){</span><span class="w"></span>
<a id="__codelineno-56-3" name="__codelineno-56-3" href="#__codelineno-56-3"></a><span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">k</span><span class="o">=</span><span class="n">low</span><span class="p">;</span><span class="n">k</span><span class="o">&lt;=</span><span class="n">high</span><span class="p">;</span><span class="n">k</span><span class="o">++</span><span class="p">)</span><span class="n">B</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="n">k</span><span class="p">];</span><span class="w">    </span><span class="c1">//将A中元素放到B中</span>
<a id="__codelineno-56-4" name="__codelineno-56-4" href="#__codelineno-56-4"></a><span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="n">low</span><span class="p">,</span><span class="n">j</span><span class="o">=</span><span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">k</span><span class="o">=</span><span class="n">i</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">mid</span><span class="o">&amp;&amp;</span><span class="n">j</span><span class="o">&lt;=</span><span class="n">high</span><span class="p">;</span><span class="n">k</span><span class="o">++</span><span class="p">){</span><span class="w"></span>
<a id="__codelineno-56-5" name="__codelineno-56-5" href="#__codelineno-56-5"></a><span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;=</span><span class="n">B</span><span class="p">[</span><span class="n">j</span><span class="p">])</span><span class="n">A</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">];</span><span class="w">    </span><span class="c1">//将较小值赋值到A中</span>
<a id="__codelineno-56-6" name="__codelineno-56-6" href="#__codelineno-56-6"></a><span class="w">        </span><span class="k">else</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">B</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">];</span><span class="w"></span>
<a id="__codelineno-56-7" name="__codelineno-56-7" href="#__codelineno-56-7"></a><span class="w">    </span><span class="p">}</span><span class="w"></span>
<a id="__codelineno-56-8" name="__codelineno-56-8" href="#__codelineno-56-8"></a><span class="w">    </span><span class="k">while</span><span class="p">(</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">mid</span><span class="p">)</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="n">k</span><span class="o">++</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">];</span><span class="w">    </span><span class="c1">//若一个表未检测完，赋值</span>
<a id="__codelineno-56-9" name="__codelineno-56-9" href="#__codelineno-56-9"></a><span class="w">    </span><span class="k">while</span><span class="p">(</span><span class="n">j</span><span class="o">&lt;=</span><span class="n">high</span><span class="p">)</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="n">k</span><span class="o">++</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">B</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">];</span><span class="w">    </span><span class="c1">//若第二个表未检测完，赋值</span>
<a id="__codelineno-56-10" name="__codelineno-56-10" href="#__codelineno-56-10"></a><span class="p">}</span><span class="w"></span>
<a id="__codelineno-56-11" name="__codelineno-56-11" href="#__codelineno-56-11"></a><span class="kt">void</span><span class="w"> </span><span class="nf">MergeSort</span><span class="p">(</span><span class="n">ElemType</span><span class="w"> </span><span class="n">A</span><span class="p">[],</span><span class="kt">int</span><span class="w"> </span><span class="n">low</span><span class="p">,</span><span class="kt">int</span><span class="w"> </span><span class="n">high</span><span class="p">){</span><span class="w"></span>
<a id="__codelineno-56-12" name="__codelineno-56-12" href="#__codelineno-56-12"></a><span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">low</span><span class="o">&lt;</span><span class="n">high</span><span class="p">){</span><span class="w"></span>
<a id="__codelineno-56-13" name="__codelineno-56-13" href="#__codelineno-56-13"></a><span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">mid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">low</span><span class="o">+</span><span class="n">high</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-56-14" name="__codelineno-56-14" href="#__codelineno-56-14"></a><span class="w">        </span><span class="n">MergeSort</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">low</span><span class="p">,</span><span class="n">mid</span><span class="p">);</span><span class="w"></span>
<a id="__codelineno-56-15" name="__codelineno-56-15" href="#__codelineno-56-15"></a><span class="w">        </span><span class="n">MergeSort</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">high</span><span class="p">);</span><span class="w"></span>
<a id="__codelineno-56-16" name="__codelineno-56-16" href="#__codelineno-56-16"></a><span class="w">        </span><span class="n">Merge</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">low</span><span class="p">,</span><span class="n">mid</span><span class="p">,</span><span class="n">high</span><span class="p">);</span><span class="w">    </span><span class="c1">//归并</span>
<a id="__codelineno-56-17" name="__codelineno-56-17" href="#__codelineno-56-17"></a><span class="w">    </span><span class="p">}</span><span class="w"></span>
<a id="__codelineno-56-18" name="__codelineno-56-18" href="#__codelineno-56-18"></a><span class="p">}</span><span class="w"></span>
</code></pre></div>
<h4 id="752">7.5.2 基数排序<a class="headerlink" href="#752" title="Permanent link">&para;</a></h4>
<ul>
<li>最高位优先法<code>MSD</code>: 将关键字位权重递减一次逐层划分成若干更小的子序列，最后将所有子序列依次连接成一个有序序列</li>
<li>最低位优先法<code>LSD</code>：将关键字权重递增一次进行排序，最后形成一个有序序列</li>
</ul>
<p>排序过程：</p>
<ul>
<li>
<p>在排序中，使用 r 个队列 <span class="arithmatex">\(Q_0,Q_1,...,Q_{r-1}\)</span>​</p>
</li>
<li>
<p>对 <span class="arithmatex">\(i=0,1,...,d-1\)</span>，依次做一次<strong>分配</strong>和<strong>收集</strong>，每个关键字结点 <span class="arithmatex">\(a_j\)</span>​由 d 元组组成</p>
</li>
<li>
<p>分配：开始时，把 <span class="arithmatex">\(Q_0,Q_1,...,Q_{r-1}\)</span>​各个队列置成空队列，然后依次考察线性表中的每个结点 <span class="arithmatex">\(a_j\)</span>​, 若 <span class="arithmatex">\(a_j\)</span> ​的关键字 <span class="arithmatex">\(k_j^i=k\)</span>，就把 <span class="arithmatex">\(a_j\)</span> ​放进 <span class="arithmatex">\(Q_k\)</span> ​队列中</p>
</li>
<li>
<p>收集：把 <span class="arithmatex">\(Q_0,Q_1,...,Q_{r-1}\)</span>​各个队列中的结点依次首尾相连，得到新的结点序列，从而组成新的线性表</p>
</li>
</ul>
<p><img alt="" src="../../images/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F%E6%A1%88%E4%BE%8B.jpg" /></p>
<h3 id="76">7.6 各种内部排序算法比较及应用<a class="headerlink" href="#76" title="Permanent link">&para;</a></h3>
<h4 id="761">7.6.1 内部排序算法的比较<a class="headerlink" href="#761" title="Permanent link">&para;</a></h4>
<table>
<thead>
<tr>
<th>算法种类</th>
<th>时间复杂度-最好</th>
<th>时间复杂度-平均</th>
<th>时间复杂度-最坏</th>
<th>空间复杂度</th>
<th>是否稳定</th>
</tr>
</thead>
<tbody>
<tr>
<td>直接插入排序</td>
<td><span class="arithmatex">\(O(n)\)</span></td>
<td><span class="arithmatex">\(O(n^2)\)</span></td>
<td><span class="arithmatex">\(O(n^2)\)</span></td>
<td><span class="arithmatex">\(O(1)\)</span></td>
<td>是</td>
</tr>
<tr>
<td>冒泡排序</td>
<td><span class="arithmatex">\(O(n)\)</span></td>
<td><span class="arithmatex">\(O(n^2)\)</span></td>
<td><span class="arithmatex">\(O(n^2)\)</span></td>
<td><span class="arithmatex">\(O(1)\)</span></td>
<td>是</td>
</tr>
<tr>
<td>简单选择排序</td>
<td><span class="arithmatex">\(O(n^2)\)</span></td>
<td><span class="arithmatex">\(O(n^2)\)</span></td>
<td><span class="arithmatex">\(O(n^2)\)</span></td>
<td><span class="arithmatex">\(O(1)\)</span></td>
<td>否</td>
</tr>
<tr>
<td>希尔排序</td>
<td></td>
<td></td>
<td></td>
<td><span class="arithmatex">\(O(1)\)</span></td>
<td>否</td>
</tr>
<tr>
<td>快速排序</td>
<td><span class="arithmatex">\(O(n\log_2n)\)</span></td>
<td><span class="arithmatex">\(O(n\log_2n)\)</span></td>
<td><span class="arithmatex">\(O(n^2)\)</span></td>
<td><span class="arithmatex">\(O(\log_2n)\)</span></td>
<td>否</td>
</tr>
<tr>
<td>堆排序</td>
<td><span class="arithmatex">\(O(n\log_2n)\)</span></td>
<td><span class="arithmatex">\(O(n\log_2n)\)</span></td>
<td><span class="arithmatex">\(O(n\log_2n)\)</span></td>
<td><span class="arithmatex">\(O(1)\)</span></td>
<td>否</td>
</tr>
<tr>
<td>2路归并排序</td>
<td><span class="arithmatex">\(O(n\log_2n)\)</span></td>
<td><span class="arithmatex">\(O(n\log_2n)\)</span></td>
<td><span class="arithmatex">\(O(n\log_2n)\)</span></td>
<td><span class="arithmatex">\(O(n)\)</span></td>
<td>是</td>
</tr>
<tr>
<td>基数排序</td>
<td><span class="arithmatex">\(O(d(n+r))\)</span></td>
<td><span class="arithmatex">\(O(d(n+r))\)</span></td>
<td><span class="arithmatex">\(O(d(n+r))\)</span></td>
<td><span class="arithmatex">\(O(r)\)</span></td>
<td>是</td>
</tr>
</tbody>
</table>
<h5 id="_118">选取排序方法需要考虑的因素<a class="headerlink" href="#_118" title="Permanent link">&para;</a></h5>
<ul>
<li>待排序的元素数目 n：较小考虑直接插入和简单选择排序，较大考虑快排】堆排序、归并排序</li>
<li>元素本身信息量的大小：是否选取移动量较少的排序方法</li>
<li>关键字的结构及其分布情况：如已经有序，则选取直接插入或冒泡排序</li>
<li>稳定性的要求</li>
<li>语言工具的要求，存储结构及辅助空间的大小等</li>
</ul>
<h3 id="77">7.7 外部排序<a class="headerlink" href="#77" title="Permanent link">&para;</a></h3>
<ul>
<li>外部排序指待排序文件较大，内存一次放不下，需存放在外存的文件的排序</li>
<li>为减少平衡归并中外存读写次数所采取的方法：增大归并路数和减少归并段个数</li>
<li>利用败者树增大归并路数</li>
<li>利用置换 - 选择排序增大归并段长度来减少归并段的个数</li>
</ul>
<h4 id="771">7.7.1 外部排序的基本概念<a class="headerlink" href="#771" title="Permanent link">&para;</a></h4>
<p>在许多应用中，经常需要对大文件进行排序，因为文件中的记录很多、信息量庞大，无法将整个文件复制进内存中进行排序。因此，需要将待排序的记录存储在外存之上，排序时再把数据一部分一部分地调进内存进行排序，在排序过程中需要多次进行内存和外存之间的交换。这种排序方法就称为<strong>外部排序</strong></p>
<h4 id="772">7.7.2 外部排序的方法<a class="headerlink" href="#772" title="Permanent link">&para;</a></h4>
<ul>
<li>根据内存缓冲区的大小，将外存上的文件分成若干长度为 <span class="arithmatex">\(l\)</span> 的子文件，依次读入内存并利用内部排序方法对它们进行排序，并将排序后得到的有序子文件重新写回外存，称这些有序子文件称为归并段或顺串</li>
<li>对这些归并段进行逐趟归并，使归并段逐渐由小到大，直至得到整个有序文件为止</li>
<li><code>外部排序的总时间=内部排序所需时间+外存信息读写的时间+内部归并所需的时间</code></li>
<li>在进行归并的时候，需要使用输入缓冲区和输出缓冲区，在内存和外存中传输数据</li>
<li>对<code>r</code>个初始段归并，做<code>k</code>路平衡归并，归并树可用严格 k 叉树来表示，树的高度 = <span class="arithmatex">\(\lceil \log_kr\rceil\)</span> = 归并趟数 S</li>
</ul>
<h4 id="773">7.7.3 多路平衡归并与败者树<a class="headerlink" href="#773" title="Permanent link">&para;</a></h4>
<ul>
<li>
<p>做内部归并时，在 k 个元素中选择关键字最小的记录需要比较 k-1 次，S 趟归并总需的比较次数是 <span class="arithmatex">\(S(n-1)(k-1)=\lceil \log_kr\rceil(n-1)(k-1)=\lceil \log_2r \rceil (n-1)(k-1)\lceil \log_2k \rceil\)</span></p>
</li>
<li>
<p>引入败者树后，在 k 个元素中选择关键字最小的记录需要比较 <span class="arithmatex">\(\lceil \log_2k \rceil\)</span> 次，内部归并的比较次数与 k 无关。因此只要内存允许，增大归并路数 k 将有效减少归并树的高度，提高外部排序的速度</p>
</li>
<li>
<p>败者树</p>
<ul>
<li>k 个叶结点分别存放 k 个归并段在归并过程中当前参加比较的记录</li>
<li>内存结点用来记忆左右子树中的失败者，而让胜者往上继续比较，一直到根结点</li>
<li>根结点记录胜者</li>
<li>叶结点进行编号 <span class="arithmatex">\(b0 \sim bk\)</span>, 内存结点编号 <span class="arithmatex">\(ls[0] \sim ls[k]\)</span>, <span class="arithmatex">\(ls[0]\)</span> 为根结点
<img alt="" src="../../images/5%E8%B7%AF%E5%BD%92%E5%B9%B6%E8%B4%A5%E8%80%85%E6%A0%91.jpg" /></li>
</ul>
</li>
</ul>
<h4 id="774-">7.7.4 置换 - 选择排序（生成初始归并段）<a class="headerlink" href="#774-" title="Permanent link">&para;</a></h4>
<p>初始待排文件<code>FI</code>, 初始归并段输出文件为<code>FO</code>, 内存工作区为<code>WA</code>,<code>FO</code>与<code>WA</code>的初始状态为空，<code>WA</code>可容纳 w w w 个记录</p>
<ol>
<li>从<code>FI</code>输入 w 个记录到工作区<code>WA</code></li>
<li>从<code>WA</code>中选出其中关键字取最小值的记录，记为<code>MINIMAX</code></li>
<li>将<code>MINIMAX</code>就输出到<code>FO</code>中去</li>
<li>若<code>FI</code>不为空，则从 FI 输入下一个记录到<code>WA</code>中</li>
<li>从<code>WA</code>中所有关键字比<code>MINIMAX</code>记录的关键字大的记录中选出最小关键字记录，作为新的<code>MINIMAX</code></li>
<li>重复<code>3-5</code>，直至在<code>WA</code>中选不出新的<code>MINIMAX</code>记录为止，由此得到一个初始归并段，输出一个归并段的结束标志至<code>FO</code>中去</li>
<li>重复<code>2-6</code>，直至<code>WA</code>为空，由此得到全部初始归并段</li>
</ol>
<p><img alt="" src="../../images/%E7%BD%AE%E6%8D%A2%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E6%A1%88%E4%BE%8B.jpg" /></p>
<h4 id="775">7.7.5 最佳归并树<a class="headerlink" href="#775" title="Permanent link">&para;</a></h4>
<p>把归并段的长度作为权值，进行严格 k 叉树的哈夫曼树思想，构造最佳归并树</p>
<ul>
<li><span class="arithmatex">\((n_0-1)\%(k-1)=0\)</span>, 不需要添加</li>
<li><span class="arithmatex">\((n_0-1)\%(k-1)=u\neq0\)</span>, 需要添加 <span class="arithmatex">\(k-1-u\)</span> 个长度为 0 的虚段</li>
</ul>
<p><img alt="" src="../../images/%E6%9C%80%E4%BD%B3%E5%BD%92%E5%B9%B6%E6%A0%91%E6%A1%88%E4%BE%8B.jpg" /></p>

              
            </article>
            
          </div>
        </div>
        
          <a href="#" class="md-top md-icon" data-md-component="top" hidden>
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12Z"/></svg>
            回到页面顶部
          </a>
        
      </main>
      
        <footer class="md-footer">
  
    
    <nav class="md-footer__inner md-grid" aria-label="页脚" >
      
        
        <a href="../../07-%E6%8E%92%E5%BA%8F/7.9%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F%EF%BC%88%E7%A8%B3%E5%AE%9A%EF%BC%89/" class="md-footer__link md-footer__link--prev" aria-label="上一页: 7.9基数排序（稳定）" rel="prev">
          <div class="md-footer__button md-icon">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
          </div>
          <div class="md-footer__title">
            <div class="md-ellipsis">
              <span class="md-footer__direction">
                上一页
              </span>
              7.9基数排序（稳定）
            </div>
          </div>
        </a>
      
      
        
        <a href="../question/" class="md-footer__link md-footer__link--next" aria-label="下一页: 核心考点" rel="next">
          <div class="md-footer__title">
            <div class="md-ellipsis">
              <span class="md-footer__direction">
                下一页
              </span>
              核心考点
            </div>
          </div>
          <div class="md-footer__button md-icon">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M4 11v2h12l-5.5 5.5 1.42 1.42L19.84 12l-7.92-7.92L10.5 5.5 16 11H4Z"/></svg>
          </div>
        </a>
      
    </nav>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    <script id="__config" type="application/json">{"base": "../..", "features": ["navigation.tabs", "navigation.indexes", "navigation.top", "header.shadow", "content.code.annotate"], "search": "../../assets/javascripts/workers/search.b97dbffb.min.js", "translations": {"clipboard.copied": "\u5df2\u590d\u5236", "clipboard.copy": "\u590d\u5236", "search.config.lang": "ja", "search.config.pipeline": "trimmer, stemmer", "search.config.separator": "[\\s\\-\uff0c\u3002]+", "search.placeholder": "\u641c\u7d22", "search.result.more.one": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.other": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 # \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.term.missing": "\u7f3a\u5c11", "select.version.title": "\u9009\u62e9\u5f53\u524d\u7248\u672c"}}</script>
    
    
      <script src="../../assets/javascripts/bundle.6c7ad80a.min.js"></script>
      
        <script src="../../javascripts/mathjax.js"></script>
      
        <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
      
        <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
      
    
  </body>
</html>