
<!doctype html>
<html lang="zh" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      <link rel="icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.3.0, mkdocs-material-8.3.9">
    
    
      
        <title>核心考点 - 数据结构总结</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.1d29e8d0.min.css">
      
        
        <link rel="stylesheet" href="../../assets/stylesheets/palette.cbb835fc.min.css">
        
          
          
          <meta name="theme-color" content="#2094f3">
        
      
      
    
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../../stylesheets/extra.css">
    
    <script>__md_scope=new URL("../..",location),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="" data-md-color-primary="blue" data-md-color-accent="">
  
    
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#_1" class="md-skip">
          跳转至
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="页眉">
    <a href="../.." title="数据结构总结" class="md-header__button md-logo" aria-label="数据结构总结" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            数据结构总结
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              核心考点
            
          </span>
        </div>
      </div>
    </div>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="搜索" placeholder="搜索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="查找">
        
        <button type="reset" class="md-search__icon md-icon" aria-label="清空当前内容" tabindex="-1">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            正在初始化搜索引擎
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
            
<nav class="md-tabs" aria-label="标签" data-md-component="tabs">
  <div class="md-tabs__inner md-grid">
    <ul class="md-tabs__list">
      
        
  
  


  
  
  
    <li class="md-tabs__item">
      <a href="../../00-%E7%BB%AA%E8%AE%BA/0.%E7%BB%AA%E8%AE%BA/" class="md-tabs__link">
        知识精要
      </a>
    </li>
  

      
        
  
  


  <li class="md-tabs__item">
    <a href="../summary/" class="md-tabs__link">
      核心知识点
    </a>
  </li>

      
        
  
  
    
  


  <li class="md-tabs__item">
    <a href="./" class="md-tabs__link md-tabs__link--active">
      核心考点
    </a>
  </li>

      
    </ul>
  </div>
</nav>
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

  


<nav class="md-nav md-nav--primary md-nav--lifted" aria-label="导航栏" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="数据结构总结" class="md-nav__button md-logo" aria-label="数据结构总结" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    数据结构总结
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_1" type="checkbox" id="__nav_1" >
      
      
      
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
      
      
        <label class="md-nav__link" for="__nav_1">
          知识精要
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="知识精要" data-md-level="1">
        <label class="md-nav__title" for="__nav_1">
          <span class="md-nav__icon md-icon"></span>
          知识精要
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../00-%E7%BB%AA%E8%AE%BA/0.%E7%BB%AA%E8%AE%BA/" class="md-nav__link">
        0.绪论
      </a>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_1_2" type="checkbox" id="__nav_1_2" >
      
      
      
        
          
        
          
        
          
        
          
        
          
        
          
        
      
      
        <label class="md-nav__link" for="__nav_1_2">
          1.线性表
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="1.线性表" data-md-level="2">
        <label class="md-nav__title" for="__nav_1_2">
          <span class="md-nav__icon md-icon"></span>
          1.线性表
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../01-%E7%BA%BF%E6%80%A7%E8%A1%A8/1.1%E7%BA%BF%E6%80%A7%E8%A1%A8/" class="md-nav__link">
        1.1线性表
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../01-%E7%BA%BF%E6%80%A7%E8%A1%A8/1.2%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%A4%BA/" class="md-nav__link">
        1.2线性表的顺序存储
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../01-%E7%BA%BF%E6%80%A7%E8%A1%A8/1.3%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8/" class="md-nav__link">
        1.3线性表的链式存储
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../01-%E7%BA%BF%E6%80%A7%E8%A1%A8/1.4%E5%8F%8C%E9%93%BE%E8%A1%A8/" class="md-nav__link">
        1.4双链表
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../01-%E7%BA%BF%E6%80%A7%E8%A1%A8/1.5%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/" class="md-nav__link">
        1.5循环链表
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../01-%E7%BA%BF%E6%80%A7%E8%A1%A8/1.6%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8/" class="md-nav__link">
        1.6静态链表
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_1_3" type="checkbox" id="__nav_1_3" >
      
      
      
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
      
      
        <label class="md-nav__link" for="__nav_1_3">
          2.栈和队列
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="2.栈和队列" data-md-level="2">
        <label class="md-nav__title" for="__nav_1_3">
          <span class="md-nav__icon md-icon"></span>
          2.栈和队列
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../02-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/2.1%E6%A0%88/" class="md-nav__link">
        2.1栈
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../02-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/2.2%E6%A0%88%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8/" class="md-nav__link">
        2.2栈的顺序存储
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../02-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/2.3%E6%A0%88%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8/" class="md-nav__link">
        2.3栈的链式存储
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../02-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/2.4%E9%98%9F%E5%88%97/" class="md-nav__link">
        2.4队列
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../02-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/2.5%E9%98%9F%E5%88%97%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8/" class="md-nav__link">
        2.5队列的顺序存储
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../02-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/2.6%E9%98%9F%E5%88%97%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8/" class="md-nav__link">
        2.6队列的链式存储
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../02-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/2.7%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97/" class="md-nav__link">
        2.7双端队列
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../02-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/2.8%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8/" class="md-nav__link">
        2.8栈和队列的应用
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../02-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/2.9%E7%89%B9%E6%AE%8A%E7%9F%A9%E9%98%B5%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%AD%98%E5%82%A8/" class="md-nav__link">
        2.9特殊矩阵的压缩存储
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_1_4" type="checkbox" id="__nav_1_4" >
      
      
      
        
          
        
          
        
          
        
      
      
        <label class="md-nav__link" for="__nav_1_4">
          3.串
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="3.串" data-md-level="2">
        <label class="md-nav__title" for="__nav_1_4">
          <span class="md-nav__icon md-icon"></span>
          3.串
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../03-%E4%B8%B2/3.1%E4%B8%B2/" class="md-nav__link">
        3.1串
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../03-%E4%B8%B2/3.2%E4%B8%B2%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/" class="md-nav__link">
        3.2串的存储结构
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../03-%E4%B8%B2/3.3%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/" class="md-nav__link">
        3.3字符串模式匹配
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_1_5" type="checkbox" id="__nav_1_5" >
      
      
      
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
      
      
        <label class="md-nav__link" for="__nav_1_5">
          4.树
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="4.树" data-md-level="2">
        <label class="md-nav__title" for="__nav_1_5">
          <span class="md-nav__icon md-icon"></span>
          4.树
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../04-%E6%A0%91/4.1%E6%A0%91/" class="md-nav__link">
        4.1树
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../04-%E6%A0%91/4.2%E4%BA%8C%E5%8F%89%E6%A0%91/" class="md-nav__link">
        4.2二叉树
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../04-%E6%A0%91/4.3%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/" class="md-nav__link">
        4.3线索二叉树
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../04-%E6%A0%91/4.4%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/" class="md-nav__link">
        4.4树的存储结构
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../04-%E6%A0%91/4.5%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/" class="md-nav__link">
        4.5二叉排序树
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../04-%E6%A0%91/4.6%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/" class="md-nav__link">
        4.6平衡二叉树
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../04-%E6%A0%91/4.7%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/" class="md-nav__link">
        4.7哈夫曼树
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_1_6" type="checkbox" id="__nav_1_6" >
      
      
      
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
      
      
        <label class="md-nav__link" for="__nav_1_6">
          5.图
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="5.图" data-md-level="2">
        <label class="md-nav__title" for="__nav_1_6">
          <span class="md-nav__icon md-icon"></span>
          5.图
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../05-%E5%9B%BE/5.1%E5%9B%BE/" class="md-nav__link">
        5.1图
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../05-%E5%9B%BE/5.2%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/" class="md-nav__link">
        5.2图的存储结构
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../05-%E5%9B%BE/5.3%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/" class="md-nav__link">
        5.3图的基本操作
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../05-%E5%9B%BE/5.4%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86%28BFS%E3%80%81DFS%29/" class="md-nav__link">
        5.4图的遍历(BFS、DFS)
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../05-%E5%9B%BE/5.5%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/" class="md-nav__link">
        5.5最小生成树
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../05-%E5%9B%BE/5.6%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/" class="md-nav__link">
        5.6最短路径
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../05-%E5%9B%BE/5.7%E6%9C%89%E5%90%91%E6%97%A0%E7%8E%AF%E5%9B%BE/" class="md-nav__link">
        5.7有向无环图
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../05-%E5%9B%BE/5.8%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/" class="md-nav__link">
        5.8拓扑排序
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../05-%E5%9B%BE/5.9%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/" class="md-nav__link">
        5.9关键路径
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_1_7" type="checkbox" id="__nav_1_7" >
      
      
      
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
      
      
        <label class="md-nav__link" for="__nav_1_7">
          6.查找
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="6.查找" data-md-level="2">
        <label class="md-nav__title" for="__nav_1_7">
          <span class="md-nav__icon md-icon"></span>
          6.查找
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../06-%E6%9F%A5%E6%89%BE/6.1%E6%9F%A5%E6%89%BE/" class="md-nav__link">
        6.1查找
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../06-%E6%9F%A5%E6%89%BE/6.2%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE/" class="md-nav__link">
        6.2顺序查找
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../06-%E6%9F%A5%E6%89%BE/6.3%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE/" class="md-nav__link">
        6.3折半查找
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../06-%E6%9F%A5%E6%89%BE/6.4%E5%88%86%E5%9D%97%E6%9F%A5%E6%89%BE/" class="md-nav__link">
        6.4分块查找
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../06-%E6%9F%A5%E6%89%BE/6.5B%E6%A0%91/" class="md-nav__link">
        6.5B树
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../06-%E6%9F%A5%E6%89%BE/6.6B%2B%E6%A0%91/" class="md-nav__link">
        6.6B+树
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../06-%E6%9F%A5%E6%89%BE/6.7%E6%95%A3%E5%88%97%E6%9F%A5%E6%89%BE%28%E5%93%88%E5%B8%8C%E6%9F%A5%E6%89%BE%29/" class="md-nav__link">
        6.7散列查找(哈希查找)
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_1_8" type="checkbox" id="__nav_1_8" >
      
      
      
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
      
      
        <label class="md-nav__link" for="__nav_1_8">
          7.排序
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="7.排序" data-md-level="2">
        <label class="md-nav__title" for="__nav_1_8">
          <span class="md-nav__icon md-icon"></span>
          7.排序
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../07-%E6%8E%92%E5%BA%8F/7.1%E6%8E%92%E5%BA%8F/" class="md-nav__link">
        7.1排序
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../07-%E6%8E%92%E5%BA%8F/7.2%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%EF%BC%88%E7%A8%B3%E5%AE%9A%EF%BC%89/" class="md-nav__link">
        7.2插入排序（稳定）
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../07-%E6%8E%92%E5%BA%8F/7.3%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%EF%BC%88%E4%B8%8D%E7%A8%B3%E5%AE%9A%EF%BC%89/" class="md-nav__link">
        7.3希尔排序（不稳定）
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../07-%E6%8E%92%E5%BA%8F/7.4%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%EF%BC%88%E7%A8%B3%E5%AE%9A%EF%BC%89/" class="md-nav__link">
        7.4冒泡排序（稳定）
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../07-%E6%8E%92%E5%BA%8F/7.5%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%EF%BC%88%E4%B8%8D%E7%A8%B3%E5%AE%9A%EF%BC%89/" class="md-nav__link">
        7.5快速排序（不稳定）
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../07-%E6%8E%92%E5%BA%8F/7.6%E7%AE%80%E5%8D%95%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%EF%BC%88%E4%B8%8D%E7%A8%B3%E5%AE%9A%EF%BC%89/" class="md-nav__link">
        7.6简单选择排序（不稳定）
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../07-%E6%8E%92%E5%BA%8F/7.7%E5%A0%86%E6%8E%92%E5%BA%8F%EF%BC%88%E4%B8%8D%E7%A8%B3%E5%AE%9A%EF%BC%89/" class="md-nav__link">
        7.7堆排序（不稳定）
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../07-%E6%8E%92%E5%BA%8F/7.8%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%EF%BC%88%E7%A8%B3%E5%AE%9A%EF%BC%89/" class="md-nav__link">
        7.8归并排序（稳定）
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../07-%E6%8E%92%E5%BA%8F/7.9%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F%EF%BC%88%E7%A8%B3%E5%AE%9A%EF%BC%89/" class="md-nav__link">
        7.9基数排序（稳定）
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../summary/" class="md-nav__link">
        核心知识点
      </a>
    </li>
  

    
      
      
      

  
  
    
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" data-md-toggle="toc" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          核心考点
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        核心考点
      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#1" class="md-nav__link">
    1. 常见的逻辑结构
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#2" class="md-nav__link">
    2.常见的存储结构
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#3" class="md-nav__link">
    3. 算法复杂度分析步
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#4" class="md-nav__link">
    4. 线性表的顺序实现要点
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#5" class="md-nav__link">
    5. 线性表的单链表形式
  </a>
  
    <nav class="md-nav" aria-label="5. 线性表的单链表形式">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    单链表的头插法及尾插法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    按位序删除
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_4" class="md-nav__link">
    指定结点的删除
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#6" class="md-nav__link">
    6. 双链表的结构，其操作类似单链表，注意别漏掉相关的指针设置
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#7" class="md-nav__link">
    7. 循环链表初始条件及判空条件的变化
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#8" class="md-nav__link">
    8. 静态链表
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#9-nfrac-1-n-1cn_2nfrac1n-1-frac2nn-times-n" class="md-nav__link">
    9. N个不同元素进栈出栈，出栈的序列个数为：\(\frac {1} {n-1}C^{n}_{2n}=\frac{1}{n-1} \frac{(2n)!}{n! \times n!}\)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#10" class="md-nav__link">
    10 顺序栈的实现，关键标识的设置
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#11" class="md-nav__link">
    11. 共享栈的改进
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#12" class="md-nav__link">
    12. 栈的链式存储结构， 一般为了方便，没有头节点
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#13" class="md-nav__link">
    13. 队列的顺序存储及问题
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#14" class="md-nav__link">
    14. 队列的顺序存储的改进，循环队列的相关操作步骤及指针的设置
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#15" class="md-nav__link">
    15. 队列的链式存储结构，通常带有头结点
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#16" class="md-nav__link">
    16. 双端队列
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#17" class="md-nav__link">
    17. 栈在括号匹配中的应用
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#18" class="md-nav__link">
    18. 后续表达式计算方式
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#19" class="md-nav__link">
    19. 中缀表达式转换为后缀表达式
  </a>
  
    <nav class="md-nav" aria-label="19. 中缀表达式转换为后缀表达式">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_5" class="md-nav__link">
    手工做法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_6" class="md-nav__link">
    算法思路
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#20" class="md-nav__link">
    20. 队列在层次遍历中的应用
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#21" class="md-nav__link">
    21. 广义的存储结构及获取表头表尾操作的组合
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#22-kmp" class="md-nav__link">
    22. KMP 模式匹配
  </a>
  
    <nav class="md-nav" aria-label="22. KMP 模式匹配">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_7" class="md-nav__link">
    基础概念
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_8" class="md-nav__link">
    算法原理
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#kmp" class="md-nav__link">
    KMP 算法的进一步优化
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#23" class="md-nav__link">
    23. 树的常用性质
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#24" class="md-nav__link">
    24. 二叉树的主要特性
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#25" class="md-nav__link">
    25. 二叉树的遍历
  </a>
  
    <nav class="md-nav" aria-label="25. 二叉树的遍历">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_9" class="md-nav__link">
    递归遍历算法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_10" class="md-nav__link">
    非递归遍历算法
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#26" class="md-nav__link">
    26. 由遍历序列构造二叉树
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#27" class="md-nav__link">
    27. 线索二叉树的基本结构及线索化
  </a>
  
    <nav class="md-nav" aria-label="27. 线索二叉树的基本结构及线索化">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_11" class="md-nav__link">
    中序线索二叉树的构造
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_12" class="md-nav__link">
    中序线索二叉树的遍历
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_13" class="md-nav__link">
    先序线索二叉树和后序线索二叉树
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#28" class="md-nav__link">
    28 树的存储结构
  </a>
  
    <nav class="md-nav" aria-label="28 树的存储结构">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_14" class="md-nav__link">
    双亲表示法（顺序存储）
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_15" class="md-nav__link">
    孩子表示法（顺序+链式存储）
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_16" class="md-nav__link">
    孩子兄弟表示法（顺序+链式存储）
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#29" class="md-nav__link">
    29. 树转换为二叉树
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#28_1" class="md-nav__link">
    28. 森林转换二叉树
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#29_1" class="md-nav__link">
    29. 二叉树转换为森林
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#30" class="md-nav__link">
    30. 树和森林的遍历
  </a>
  
    <nav class="md-nav" aria-label="30. 树和森林的遍历">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_17" class="md-nav__link">
    树的遍历
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_18" class="md-nav__link">
    森林的遍历
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#31" class="md-nav__link">
    31. 二叉排序树的查找、插入、构造及删除
  </a>
  
    <nav class="md-nav" aria-label="31. 二叉排序树的查找、插入、构造及删除">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_19" class="md-nav__link">
    二叉排序树的剔除
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_20" class="md-nav__link">
    二叉排序树的查找效率分析
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#32" class="md-nav__link">
    32. 平衡二叉树的插入、构建及查找
  </a>
  
    <nav class="md-nav" aria-label="32. 平衡二叉树的插入、构建及查找">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_21" class="md-nav__link">
    平衡二叉树的插入
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_22" class="md-nav__link">
    平衡二叉树的查找
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#33" class="md-nav__link">
    33. 哈夫曼树和哈夫曼编码
  </a>
  
    <nav class="md-nav" aria-label="33. 哈夫曼树和哈夫曼编码">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_23" class="md-nav__link">
    哈夫曼树的构造
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_24" class="md-nav__link">
    特点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_25" class="md-nav__link">
    哈夫曼编码
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#34" class="md-nav__link">
    34. 图的存储及存储方式间的相互转换
  </a>
  
    <nav class="md-nav" aria-label="34. 图的存储及存储方式间的相互转换">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_26" class="md-nav__link">
    邻接矩阵法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_27" class="md-nav__link">
    邻接表法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_28" class="md-nav__link">
    十字链表
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_29" class="md-nav__link">
    邻接多重表
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#35" class="md-nav__link">
    35. 图的广度优先算法及深度优先搜索
  </a>
  
    <nav class="md-nav" aria-label="35. 图的广度优先算法及深度优先搜索">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_30" class="md-nav__link">
    广度优先搜索
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_31" class="md-nav__link">
    深度优先搜索
  </a>
  
    <nav class="md-nav" aria-label="深度优先搜索">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_32" class="md-nav__link">
    性能
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#36" class="md-nav__link">
    36. 最小生成树
  </a>
  
    <nav class="md-nav" aria-label="36. 最小生成树">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#prim" class="md-nav__link">
    Prim 算法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#kruskal" class="md-nav__link">
    Kruskal 算法
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#37" class="md-nav__link">
    37. 最短路径
  </a>
  
    <nav class="md-nav" aria-label="37. 最短路径">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#dijkstra" class="md-nav__link">
    Dijkstra 算法求单源最短路径
  </a>
  
    <nav class="md-nav" aria-label="Dijkstra 算法求单源最短路径">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_33" class="md-nav__link">
    辅助数组
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_34" class="md-nav__link">
    算法步骤
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_35" class="md-nav__link">
    案例：
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#floyd" class="md-nav__link">
    Floyd 算法求个定点之间最短路径
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#38" class="md-nav__link">
    38. 拓扑排序
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#39" class="md-nav__link">
    39. 关键路径
  </a>
  
    <nav class="md-nav" aria-label="39. 关键路径">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_36" class="md-nav__link">
    计算步骤
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#39_1" class="md-nav__link">
    39. 折半查找
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#40" class="md-nav__link">
    40. 分块查找
  </a>
  
    <nav class="md-nav" aria-label="40. 分块查找">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_37" class="md-nav__link">
    用折半查找索引表：
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_38" class="md-nav__link">
    查找效率分析
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_39" class="md-nav__link">
    时间复杂度评价
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#41-b" class="md-nav__link">
    41. B 树及其基本操作
  </a>
  
    <nav class="md-nav" aria-label="41. B 树及其基本操作">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_40" class="md-nav__link">
    定义
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#b" class="md-nav__link">
    B 树的高度
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#b_1" class="md-nav__link">
    B 树的查找
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#b_2" class="md-nav__link">
    B 树的插入
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#b_3" class="md-nav__link">
    B 树的删除
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#42" class="md-nav__link">
    42. 散列表
  </a>
  
    <nav class="md-nav" aria-label="42. 散列表">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_41" class="md-nav__link">
    基本概念
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_42" class="md-nav__link">
    散列函数的构造方法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_43" class="md-nav__link">
    散列函数的要求
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_44" class="md-nav__link">
    处理冲突的方法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_45" class="md-nav__link">
    散列查找及性能分析
  </a>
  
    <nav class="md-nav" aria-label="散列查找及性能分析">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_46" class="md-nav__link">
    查找过程
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#43" class="md-nav__link">
    43. 直接插入排序
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#44" class="md-nav__link">
    44. 折半插入排序
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#45" class="md-nav__link">
    45. 希尔排序
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#46" class="md-nav__link">
    46. 交换排序
  </a>
  
    <nav class="md-nav" aria-label="46. 交换排序">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#731" class="md-nav__link">
    7.3.1 冒泡排序
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#46_1" class="md-nav__link">
    46. 快速排序
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#47" class="md-nav__link">
    47. 简单选择排序
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#48" class="md-nav__link">
    48. 堆排序
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#49" class="md-nav__link">
    49. 归并排序
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#50" class="md-nav__link">
    50. 基数排序
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#51" class="md-nav__link">
    51. 各种内部排序算法比较及应用
  </a>
  
    <nav class="md-nav" aria-label="51. 各种内部排序算法比较及应用">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_47" class="md-nav__link">
    内部排序算法的比较
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_48" class="md-nav__link">
    选取排序方法需要考虑的因素
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#52" class="md-nav__link">
    52. 外部排序的方法
  </a>
  
    <nav class="md-nav" aria-label="52. 外部排序的方法">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_49" class="md-nav__link">
    多路平衡归并与败者树
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#-" class="md-nav__link">
    置换 - 选择排序（生成初始归并段）
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_50" class="md-nav__link">
    最佳归并树
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#1" class="md-nav__link">
    1. 常见的逻辑结构
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#2" class="md-nav__link">
    2.常见的存储结构
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#3" class="md-nav__link">
    3. 算法复杂度分析步
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#4" class="md-nav__link">
    4. 线性表的顺序实现要点
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#5" class="md-nav__link">
    5. 线性表的单链表形式
  </a>
  
    <nav class="md-nav" aria-label="5. 线性表的单链表形式">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    单链表的头插法及尾插法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    按位序删除
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_4" class="md-nav__link">
    指定结点的删除
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#6" class="md-nav__link">
    6. 双链表的结构，其操作类似单链表，注意别漏掉相关的指针设置
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#7" class="md-nav__link">
    7. 循环链表初始条件及判空条件的变化
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#8" class="md-nav__link">
    8. 静态链表
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#9-nfrac-1-n-1cn_2nfrac1n-1-frac2nn-times-n" class="md-nav__link">
    9. N个不同元素进栈出栈，出栈的序列个数为：\(\frac {1} {n-1}C^{n}_{2n}=\frac{1}{n-1} \frac{(2n)!}{n! \times n!}\)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#10" class="md-nav__link">
    10 顺序栈的实现，关键标识的设置
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#11" class="md-nav__link">
    11. 共享栈的改进
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#12" class="md-nav__link">
    12. 栈的链式存储结构， 一般为了方便，没有头节点
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#13" class="md-nav__link">
    13. 队列的顺序存储及问题
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#14" class="md-nav__link">
    14. 队列的顺序存储的改进，循环队列的相关操作步骤及指针的设置
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#15" class="md-nav__link">
    15. 队列的链式存储结构，通常带有头结点
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#16" class="md-nav__link">
    16. 双端队列
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#17" class="md-nav__link">
    17. 栈在括号匹配中的应用
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#18" class="md-nav__link">
    18. 后续表达式计算方式
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#19" class="md-nav__link">
    19. 中缀表达式转换为后缀表达式
  </a>
  
    <nav class="md-nav" aria-label="19. 中缀表达式转换为后缀表达式">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_5" class="md-nav__link">
    手工做法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_6" class="md-nav__link">
    算法思路
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#20" class="md-nav__link">
    20. 队列在层次遍历中的应用
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#21" class="md-nav__link">
    21. 广义的存储结构及获取表头表尾操作的组合
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#22-kmp" class="md-nav__link">
    22. KMP 模式匹配
  </a>
  
    <nav class="md-nav" aria-label="22. KMP 模式匹配">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_7" class="md-nav__link">
    基础概念
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_8" class="md-nav__link">
    算法原理
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#kmp" class="md-nav__link">
    KMP 算法的进一步优化
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#23" class="md-nav__link">
    23. 树的常用性质
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#24" class="md-nav__link">
    24. 二叉树的主要特性
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#25" class="md-nav__link">
    25. 二叉树的遍历
  </a>
  
    <nav class="md-nav" aria-label="25. 二叉树的遍历">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_9" class="md-nav__link">
    递归遍历算法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_10" class="md-nav__link">
    非递归遍历算法
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#26" class="md-nav__link">
    26. 由遍历序列构造二叉树
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#27" class="md-nav__link">
    27. 线索二叉树的基本结构及线索化
  </a>
  
    <nav class="md-nav" aria-label="27. 线索二叉树的基本结构及线索化">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_11" class="md-nav__link">
    中序线索二叉树的构造
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_12" class="md-nav__link">
    中序线索二叉树的遍历
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_13" class="md-nav__link">
    先序线索二叉树和后序线索二叉树
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#28" class="md-nav__link">
    28 树的存储结构
  </a>
  
    <nav class="md-nav" aria-label="28 树的存储结构">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_14" class="md-nav__link">
    双亲表示法（顺序存储）
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_15" class="md-nav__link">
    孩子表示法（顺序+链式存储）
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_16" class="md-nav__link">
    孩子兄弟表示法（顺序+链式存储）
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#29" class="md-nav__link">
    29. 树转换为二叉树
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#28_1" class="md-nav__link">
    28. 森林转换二叉树
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#29_1" class="md-nav__link">
    29. 二叉树转换为森林
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#30" class="md-nav__link">
    30. 树和森林的遍历
  </a>
  
    <nav class="md-nav" aria-label="30. 树和森林的遍历">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_17" class="md-nav__link">
    树的遍历
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_18" class="md-nav__link">
    森林的遍历
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#31" class="md-nav__link">
    31. 二叉排序树的查找、插入、构造及删除
  </a>
  
    <nav class="md-nav" aria-label="31. 二叉排序树的查找、插入、构造及删除">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_19" class="md-nav__link">
    二叉排序树的剔除
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_20" class="md-nav__link">
    二叉排序树的查找效率分析
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#32" class="md-nav__link">
    32. 平衡二叉树的插入、构建及查找
  </a>
  
    <nav class="md-nav" aria-label="32. 平衡二叉树的插入、构建及查找">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_21" class="md-nav__link">
    平衡二叉树的插入
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_22" class="md-nav__link">
    平衡二叉树的查找
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#33" class="md-nav__link">
    33. 哈夫曼树和哈夫曼编码
  </a>
  
    <nav class="md-nav" aria-label="33. 哈夫曼树和哈夫曼编码">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_23" class="md-nav__link">
    哈夫曼树的构造
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_24" class="md-nav__link">
    特点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_25" class="md-nav__link">
    哈夫曼编码
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#34" class="md-nav__link">
    34. 图的存储及存储方式间的相互转换
  </a>
  
    <nav class="md-nav" aria-label="34. 图的存储及存储方式间的相互转换">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_26" class="md-nav__link">
    邻接矩阵法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_27" class="md-nav__link">
    邻接表法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_28" class="md-nav__link">
    十字链表
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_29" class="md-nav__link">
    邻接多重表
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#35" class="md-nav__link">
    35. 图的广度优先算法及深度优先搜索
  </a>
  
    <nav class="md-nav" aria-label="35. 图的广度优先算法及深度优先搜索">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_30" class="md-nav__link">
    广度优先搜索
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_31" class="md-nav__link">
    深度优先搜索
  </a>
  
    <nav class="md-nav" aria-label="深度优先搜索">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_32" class="md-nav__link">
    性能
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#36" class="md-nav__link">
    36. 最小生成树
  </a>
  
    <nav class="md-nav" aria-label="36. 最小生成树">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#prim" class="md-nav__link">
    Prim 算法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#kruskal" class="md-nav__link">
    Kruskal 算法
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#37" class="md-nav__link">
    37. 最短路径
  </a>
  
    <nav class="md-nav" aria-label="37. 最短路径">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#dijkstra" class="md-nav__link">
    Dijkstra 算法求单源最短路径
  </a>
  
    <nav class="md-nav" aria-label="Dijkstra 算法求单源最短路径">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_33" class="md-nav__link">
    辅助数组
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_34" class="md-nav__link">
    算法步骤
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_35" class="md-nav__link">
    案例：
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#floyd" class="md-nav__link">
    Floyd 算法求个定点之间最短路径
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#38" class="md-nav__link">
    38. 拓扑排序
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#39" class="md-nav__link">
    39. 关键路径
  </a>
  
    <nav class="md-nav" aria-label="39. 关键路径">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_36" class="md-nav__link">
    计算步骤
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#39_1" class="md-nav__link">
    39. 折半查找
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#40" class="md-nav__link">
    40. 分块查找
  </a>
  
    <nav class="md-nav" aria-label="40. 分块查找">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_37" class="md-nav__link">
    用折半查找索引表：
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_38" class="md-nav__link">
    查找效率分析
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_39" class="md-nav__link">
    时间复杂度评价
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#41-b" class="md-nav__link">
    41. B 树及其基本操作
  </a>
  
    <nav class="md-nav" aria-label="41. B 树及其基本操作">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_40" class="md-nav__link">
    定义
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#b" class="md-nav__link">
    B 树的高度
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#b_1" class="md-nav__link">
    B 树的查找
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#b_2" class="md-nav__link">
    B 树的插入
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#b_3" class="md-nav__link">
    B 树的删除
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#42" class="md-nav__link">
    42. 散列表
  </a>
  
    <nav class="md-nav" aria-label="42. 散列表">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_41" class="md-nav__link">
    基本概念
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_42" class="md-nav__link">
    散列函数的构造方法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_43" class="md-nav__link">
    散列函数的要求
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_44" class="md-nav__link">
    处理冲突的方法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_45" class="md-nav__link">
    散列查找及性能分析
  </a>
  
    <nav class="md-nav" aria-label="散列查找及性能分析">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_46" class="md-nav__link">
    查找过程
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#43" class="md-nav__link">
    43. 直接插入排序
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#44" class="md-nav__link">
    44. 折半插入排序
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#45" class="md-nav__link">
    45. 希尔排序
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#46" class="md-nav__link">
    46. 交换排序
  </a>
  
    <nav class="md-nav" aria-label="46. 交换排序">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#731" class="md-nav__link">
    7.3.1 冒泡排序
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#46_1" class="md-nav__link">
    46. 快速排序
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#47" class="md-nav__link">
    47. 简单选择排序
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#48" class="md-nav__link">
    48. 堆排序
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#49" class="md-nav__link">
    49. 归并排序
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#50" class="md-nav__link">
    50. 基数排序
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#51" class="md-nav__link">
    51. 各种内部排序算法比较及应用
  </a>
  
    <nav class="md-nav" aria-label="51. 各种内部排序算法比较及应用">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_47" class="md-nav__link">
    内部排序算法的比较
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_48" class="md-nav__link">
    选取排序方法需要考虑的因素
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#52" class="md-nav__link">
    52. 外部排序的方法
  </a>
  
    <nav class="md-nav" aria-label="52. 外部排序的方法">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_49" class="md-nav__link">
    多路平衡归并与败者树
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#-" class="md-nav__link">
    置换 - 选择排序（生成初始归并段）
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_50" class="md-nav__link">
    最佳归并树
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content" data-md-component="content">
            <article class="md-content__inner md-typeset">
              
                


<h1 id="_1">数据结构核心考点<a class="headerlink" href="#_1" title="Permanent link">&para;</a></h1>
<h2 id="1">1. 常见的逻辑结构<a class="headerlink" href="#1" title="Permanent link">&para;</a></h2>
<ul>
<li>线性结构：一般线性表、受限线性表（栈和队列）、线性表推广（数组）</li>
<li>非线性结构：集合结构、树结构、图结构</li>
</ul>
<h2 id="2">2.常见的存储结构<a class="headerlink" href="#2" title="Permanent link">&para;</a></h2>
<table>
<thead>
<tr>
<th>存储结构</th>
<th>定义</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>顺序存储</td>
<td>把逻辑上相邻的元素存储在物理位置上也相邻的存储单元中，元素之间的关系由存储单元的邻接关系来体现</td>
<td>随机存取，占用空间少</td>
<td>使用一整块相邻的存储单元，产生较多碎片</td>
</tr>
<tr>
<td>链式存储</td>
<td>不要求逻辑上相邻的元素在物理位置上也相邻，借助指示元素存储地址的指针来表示元素之间的逻辑关系</td>
<td>不会出现碎片，充分利用所有存储单元</td>
<td>需要额外空间，只能顺序存取</td>
</tr>
<tr>
<td>索引存储</td>
<td>在存储元素信息的同时，还建立附加的索引表。</td>
<td>检索速度快</td>
<td>附加的索引表需要额外空间。增删数据修改索引表时花费时间</td>
</tr>
<tr>
<td>散列存储</td>
<td>根据元素的关键字直接计算出该元素的存储地址，又称哈希(Hash)存储。</td>
<td>检索、增加和删除结点的操作很快</td>
<td>可能出现元素存储单元的冲突，解决冲突会增加时间和空间开销</td>
</tr>
</tbody>
</table>
<h2 id="3">3. 算法复杂度分析步<a class="headerlink" href="#3" title="Permanent link">&para;</a></h2>
<ul>
<li>确定表示输入规模的参数</li>
<li>找出算法的基本操作</li>
<li>检查基本操作的执行次数是否只依赖于输入规模。这决定是否需要考虑最差、平均以及最优情况下的复杂性</li>
<li>对于非递归算法，建立算法基本操作执行次数的求和表达式；</li>
<li>对于递归算法，建立算法基本操作执行次数的递推关系及其初始条件，利用求和公式和法则建立一个操作次数的闭合公式，或者求解递推公式，确定增长的阶</li>
</ul>
<p>加法法则：</p>
<div class="arithmatex">\[T(n)=T_1(n)+T_2(n)=O(f(n))+O(g(n))=O(max(f(n),g(n)))\]</div>
<p>乘法法则：</p>
<div class="arithmatex">\[T(n)=T_1(n)\times T_2(n)=O(f(n))\times O(g(n))=O(f(n))\times O(g(n))\]</div>
<p>常见的复杂度：</p>
<div class="arithmatex">\[O(1) \leq O(log_2n)\leq O(n) \leq O(n log_2n) \leq O(n^2)\]</div>
<div class="arithmatex">\[\leq O(n^3) \leq O(2^n) \leq O(n!) \leq O(n^n)\]</div>
<p>两类递归算法问题的复杂度求解：</p>
<ul>
<li>线性分解</li>
</ul>
<div class="arithmatex">\[T(n)=\begin{cases} O(1) &amp; n=1\\ aT(n-1)+f(n)&amp; n&gt;1 \end{cases}\]</div>
<div class="arithmatex">\[T (n) = a^{n-1}T(1)+\sum_{i=2}^n a^{n-i}f(i)\]</div>
<ul>
<li>指数分解</li>
</ul>
<div class="arithmatex">\[T(n)=\begin{cases} O(1) &amp; n=1\\ aT(\frac nb)+f(n)&amp; n&gt;1 \end{cases}\]</div>
<div class="arithmatex">\[T(n)=n^{log_b a}T(1)+\sum_{j=0}^{log_b n-1}a^jf(\frac n{b^j})\]</div>
<h2 id="4">4. 线性表的顺序实现要点<a class="headerlink" href="#4" title="Permanent link">&para;</a></h2>
<ul>
<li>随机访问</li>
<li>存储密度高</li>
<li>插入删除需要移动大量元素</li>
</ul>
<p><code>注意算法对i的描述是第i个元素，它是以1为起点的</code></p>
<table>
<thead>
<tr>
<th>操作</th>
<th>最好时间复杂度</th>
<th>最坏时间复杂度</th>
<th>平均情况</th>
</tr>
</thead>
<tbody>
<tr>
<td>插入</td>
<td>插到表尾，O(1)</td>
<td>插到表头，O(n)</td>
<td>平均概率 O(n)</td>
</tr>
<tr>
<td>删除</td>
<td>删除表尾，O(1)</td>
<td>删除表头，O(n)</td>
<td>平均概率 O(n)</td>
</tr>
<tr>
<td>按值查找</td>
<td>目标在表头，=O(1)</td>
<td>目标在表尾，O(n)</td>
<td>平均概率O(n)</td>
</tr>
<tr>
<td>按位置访问</td>
<td>O(1)</td>
<td>O(1)</td>
<td>平均概率O(1)</td>
</tr>
</tbody>
</table>
<h2 id="5">5. 线性表的单链表形式<a class="headerlink" href="#5" title="Permanent link">&para;</a></h2>
<ul>
<li>结点描述：</li>
</ul>
<div class="highlight"><pre><span></span><code><a id="__codelineno-0-1" name="__codelineno-0-1" href="#__codelineno-0-1"></a><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">LNode</span><span class="p">{</span><span class="w">        </span><span class="c1">//定义单链表结点类型</span>
<a id="__codelineno-0-2" name="__codelineno-0-2" href="#__codelineno-0-2"></a><span class="w">    </span><span class="n">ElemType</span><span class="w"> </span><span class="n">data</span><span class="p">;</span><span class="w">            </span><span class="c1">//数据域</span>
<a id="__codelineno-0-3" name="__codelineno-0-3" href="#__codelineno-0-3"></a><span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">LNode</span><span class="w"> </span><span class="o">*</span><span class="n">next</span><span class="p">;</span><span class="w">        </span><span class="c1">//指针域</span>
<a id="__codelineno-0-4" name="__codelineno-0-4" href="#__codelineno-0-4"></a><span class="p">}</span><span class="n">LNode</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">LinkList</span><span class="p">;</span><span class="w">        </span><span class="c1">//LinkList为指向结构体LNODE的指针类型</span>
</code></pre></div>
<ul>
<li>通常用头指针来标示一个单链表。</li>
<li>有头结点或者没头结点之分</li>
<li>头结点的作用</li>
<li>便于首元结点的处理，对链表的第一个数据元素的操作与其他数据元素相同，无需特殊处理</li>
<li>便于空表与非空表的统一处理：头指针永远不为空</li>
</ul>
<h3 id="_2">单链表的头插法及尾插法<a class="headerlink" href="#_2" title="Permanent link">&para;</a></h3>
<p><img alt="" src="../../images/20210417202853466.png" />
<div class="highlight"><pre><span></span><code><a id="__codelineno-1-1" name="__codelineno-1-1" href="#__codelineno-1-1"></a><span class="n">LinkList</span><span class="w"> </span><span class="nf">List_HeadInsert</span><span class="p">(</span><span class="n">LinkList</span><span class="w"> </span><span class="o">&amp;</span><span class="n">L</span><span class="p">){</span><span class="w"></span>
<a id="__codelineno-1-2" name="__codelineno-1-2" href="#__codelineno-1-2"></a><span class="w">    </span><span class="n">LNode</span><span class="w"> </span><span class="o">*</span><span class="n">s</span><span class="p">;</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-1-3" name="__codelineno-1-3" href="#__codelineno-1-3"></a><span class="w">    </span><span class="n">L</span><span class="o">=</span><span class="p">(</span><span class="n">LinkList</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">LNode</span><span class="p">));</span><span class="c1">//创建头结点</span>
<a id="__codelineno-1-4" name="__codelineno-1-4" href="#__codelineno-1-4"></a><span class="w">    </span><span class="n">L</span><span class="o">-&gt;</span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w">                    </span><span class="c1">//初始为空链表</span>
<a id="__codelineno-1-5" name="__codelineno-1-5" href="#__codelineno-1-5"></a><span class="w">    </span><span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span><span class="o">&amp;</span><span class="n">x</span><span class="p">);</span><span class="w"></span>
<a id="__codelineno-1-6" name="__codelineno-1-6" href="#__codelineno-1-6"></a><span class="w">    </span><span class="k">while</span><span class="p">(</span><span class="n">x</span><span class="o">!=</span><span class="mi">9999</span><span class="p">){</span><span class="w"></span>
<a id="__codelineno-1-7" name="__codelineno-1-7" href="#__codelineno-1-7"></a><span class="w">        </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">LNode</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">LNode</span><span class="p">));</span><span class="w"></span>
<a id="__codelineno-1-8" name="__codelineno-1-8" href="#__codelineno-1-8"></a><span class="w">        </span><span class="n">s</span><span class="o">-&gt;</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-1-9" name="__codelineno-1-9" href="#__codelineno-1-9"></a><span class="w">        </span><span class="n">s</span><span class="o">-&gt;</span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">L</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-1-10" name="__codelineno-1-10" href="#__codelineno-1-10"></a><span class="w">        </span><span class="n">L</span><span class="o">-&gt;</span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-1-11" name="__codelineno-1-11" href="#__codelineno-1-11"></a><span class="w">        </span><span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span><span class="o">&amp;</span><span class="n">x</span><span class="p">);</span><span class="w"></span>
<a id="__codelineno-1-12" name="__codelineno-1-12" href="#__codelineno-1-12"></a><span class="w">    </span><span class="p">}</span><span class="w"></span>
<a id="__codelineno-1-13" name="__codelineno-1-13" href="#__codelineno-1-13"></a><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">L</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-1-14" name="__codelineno-1-14" href="#__codelineno-1-14"></a><span class="p">}</span><span class="w"></span>
</code></pre></div></p>
<p><img alt="" src="../../images/20210417204450775.png" />
<div class="highlight"><pre><span></span><code><a id="__codelineno-2-1" name="__codelineno-2-1" href="#__codelineno-2-1"></a><span class="n">LinkList</span><span class="w"> </span><span class="nf">List_TailInsert</span><span class="p">(</span><span class="n">LinkList</span><span class="w"> </span><span class="o">&amp;</span><span class="n">L</span><span class="p">){</span><span class="w"></span>
<a id="__codelineno-2-2" name="__codelineno-2-2" href="#__codelineno-2-2"></a><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-2-3" name="__codelineno-2-3" href="#__codelineno-2-3"></a><span class="w">    </span><span class="n">L</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">LinkList</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">LNode</span><span class="p">));</span><span class="w"></span>
<a id="__codelineno-2-4" name="__codelineno-2-4" href="#__codelineno-2-4"></a><span class="w">    </span><span class="n">LNode</span><span class="w"> </span><span class="o">*</span><span class="n">s</span><span class="p">,</span><span class="o">*</span><span class="n">r</span><span class="o">=</span><span class="n">L</span><span class="p">;</span><span class="w">            </span><span class="c1">//r为表尾指针</span>
<a id="__codelineno-2-5" name="__codelineno-2-5" href="#__codelineno-2-5"></a><span class="w">    </span><span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span><span class="o">&amp;</span><span class="n">x</span><span class="p">);</span><span class="w"></span>
<a id="__codelineno-2-6" name="__codelineno-2-6" href="#__codelineno-2-6"></a><span class="w">    </span><span class="k">while</span><span class="p">(</span><span class="n">x</span><span class="o">!=</span><span class="mi">9999</span><span class="p">){</span><span class="w"></span>
<a id="__codelineno-2-7" name="__codelineno-2-7" href="#__codelineno-2-7"></a><span class="w">        </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">LNode</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">LNode</span><span class="p">));</span><span class="w"></span>
<a id="__codelineno-2-8" name="__codelineno-2-8" href="#__codelineno-2-8"></a><span class="w">        </span><span class="n">s</span><span class="o">-&gt;</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-2-9" name="__codelineno-2-9" href="#__codelineno-2-9"></a><span class="w">        </span><span class="n">r</span><span class="o">-&gt;</span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-2-10" name="__codelineno-2-10" href="#__codelineno-2-10"></a><span class="w">        </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-2-11" name="__codelineno-2-11" href="#__codelineno-2-11"></a><span class="w">        </span><span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span><span class="o">&amp;</span><span class="n">x</span><span class="p">);</span><span class="w"></span>
<a id="__codelineno-2-12" name="__codelineno-2-12" href="#__codelineno-2-12"></a><span class="w">    </span><span class="p">}</span><span class="w"></span>
<a id="__codelineno-2-13" name="__codelineno-2-13" href="#__codelineno-2-13"></a><span class="w">    </span><span class="n">r</span><span class="o">-&gt;</span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w">                </span><span class="c1">//尾结点指针置空</span>
<a id="__codelineno-2-14" name="__codelineno-2-14" href="#__codelineno-2-14"></a><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">L</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-2-15" name="__codelineno-2-15" href="#__codelineno-2-15"></a><span class="p">}</span><span class="w"></span>
</code></pre></div></p>
<h3 id="_3">按位序删除<a class="headerlink" href="#_3" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><a id="__codelineno-3-1" name="__codelineno-3-1" href="#__codelineno-3-1"></a><span class="c1">//删除操作:将单链表中的第i个结点删除</span>
<a id="__codelineno-3-2" name="__codelineno-3-2" href="#__codelineno-3-2"></a><span class="kt">bool</span><span class="w"> </span><span class="nf">Delete</span><span class="p">(</span><span class="n">LinkList</span><span class="w"> </span><span class="o">&amp;</span><span class="n">L</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">&amp;</span><span class="n">e</span><span class="p">){</span><span class="w"></span>
<a id="__codelineno-3-3" name="__codelineno-3-3" href="#__codelineno-3-3"></a><span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">1</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">i</span><span class="o">&gt;</span><span class="n">Length</span><span class="p">(</span><span class="n">L</span><span class="p">))</span><span class="w"></span>
<a id="__codelineno-3-4" name="__codelineno-3-4" href="#__codelineno-3-4"></a><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-3-5" name="__codelineno-3-5" href="#__codelineno-3-5"></a><span class="w">    </span><span class="n">LNode</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GetElem</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">i</span><span class="mi">-1</span><span class="p">);</span><span class="w">  </span><span class="c1">//查找第i个位置</span>
<a id="__codelineno-3-6" name="__codelineno-3-6" href="#__codelineno-3-6"></a><span class="w">    </span><span class="n">LNode</span><span class="w"> </span><span class="o">*</span><span class="n">q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-3-7" name="__codelineno-3-7" href="#__codelineno-3-7"></a><span class="w">    </span><span class="n">e</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">q</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-3-8" name="__codelineno-3-8" href="#__codelineno-3-8"></a><span class="w">    </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">q</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-3-9" name="__codelineno-3-9" href="#__codelineno-3-9"></a><span class="w">    </span><span class="n">free</span><span class="p">(</span><span class="n">q</span><span class="p">);</span><span class="w"></span>
<a id="__codelineno-3-10" name="__codelineno-3-10" href="#__codelineno-3-10"></a><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-3-11" name="__codelineno-3-11" href="#__codelineno-3-11"></a><span class="p">}</span><span class="w"></span>
</code></pre></div>
<h3 id="_4">指定结点的删除<a class="headerlink" href="#_4" title="Permanent link">&para;</a></h3>
<p><code>时间复杂度</code>=O(n)</p>
<p>方法：p的后一个为q，p指向q的下一个，把q的值给p，最后释放q</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-4-1" name="__codelineno-4-1" href="#__codelineno-4-1"></a><span class="c1">//删除指定结点p</span>
<a id="__codelineno-4-2" name="__codelineno-4-2" href="#__codelineno-4-2"></a><span class="kt">bool</span><span class="w"> </span><span class="nf">Delete</span><span class="p">(</span><span class="n">LNode</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">){</span><span class="w"></span>
<a id="__codelineno-4-3" name="__codelineno-4-3" href="#__codelineno-4-3"></a><span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="o">==</span><span class="nb">NULL</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-4-4" name="__codelineno-4-4" href="#__codelineno-4-4"></a><span class="w">    </span><span class="n">LNode</span><span class="w"> </span><span class="o">*</span><span class="n">q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-4-5" name="__codelineno-4-5" href="#__codelineno-4-5"></a><span class="w">    </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">q</span><span class="o">-&gt;</span><span class="n">data</span><span class="w"></span>
<a id="__codelineno-4-6" name="__codelineno-4-6" href="#__codelineno-4-6"></a><span class="w">    </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">q</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-4-7" name="__codelineno-4-7" href="#__codelineno-4-7"></a><span class="w">    </span><span class="n">free</span><span class="p">(</span><span class="n">q</span><span class="p">);</span><span class="w"></span>
<a id="__codelineno-4-8" name="__codelineno-4-8" href="#__codelineno-4-8"></a><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-4-9" name="__codelineno-4-9" href="#__codelineno-4-9"></a><span class="p">}</span><span class="w"></span>
</code></pre></div>
<h2 id="6">6. 双链表的结构，其操作类似单链表，注意别漏掉相关的指针设置<a class="headerlink" href="#6" title="Permanent link">&para;</a></h2>
<div class="highlight"><pre><span></span><code><a id="__codelineno-5-1" name="__codelineno-5-1" href="#__codelineno-5-1"></a><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">DNode</span><span class="p">{</span><span class="w"></span>
<a id="__codelineno-5-2" name="__codelineno-5-2" href="#__codelineno-5-2"></a><span class="w">    </span><span class="n">ElemType</span><span class="w"> </span><span class="n">data</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-5-3" name="__codelineno-5-3" href="#__codelineno-5-3"></a><span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">DNode</span><span class="w"> </span><span class="o">*</span><span class="n">prior</span><span class="p">,</span><span class="o">*</span><span class="n">next</span><span class="p">;</span><span class="w">    </span><span class="c1">//前驱和后继指针</span>
<a id="__codelineno-5-4" name="__codelineno-5-4" href="#__codelineno-5-4"></a><span class="p">}</span><span class="n">DNode</span><span class="p">,</span><span class="o">*</span><span class="n">DLinkList</span><span class="p">;</span><span class="w"></span>
</code></pre></div>
<h2 id="7">7. 循环链表初始条件及判空条件的变化<a class="headerlink" href="#7" title="Permanent link">&para;</a></h2>
<ul>
<li>循环单链表</li>
</ul>
<p>初始化和判空(与单链表不一样)
<code>L-&gt;next = NULL改为L-&gt;next = L</code></p>
<ul>
<li>循环双链表</li>
</ul>
<p>初始化和判空(与双链表不一样)
<div class="highlight"><pre><span></span><code><a id="__codelineno-6-1" name="__codelineno-6-1" href="#__codelineno-6-1"></a><span class="n">L</span><span class="o">-&gt;</span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">NULL改为L</span><span class="o">-&gt;</span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">L</span><span class="w"></span>
<a id="__codelineno-6-2" name="__codelineno-6-2" href="#__codelineno-6-2"></a><span class="n">L</span><span class="o">-&gt;</span><span class="n">prior</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">NULL改为L</span><span class="o">-&gt;</span><span class="n">prior</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">L</span><span class="w"></span>
</code></pre></div></p>
<h2 id="8">8. 静态链表<a class="headerlink" href="#8" title="Permanent link">&para;</a></h2>
<p>借助数组来描述线性表的链式存储结构，结点也有数据域<code>data</code>和指针域<code>next</code>，这里的指针是节点的相对地址（数组下标），又称<strong>游标</strong>
<img alt="静态链表" src="../../images/20210418162136494.png" />
<div class="highlight"><pre><span></span><code><a id="__codelineno-7-1" name="__codelineno-7-1" href="#__codelineno-7-1"></a><span class="cp">#define MaxSize 50</span>
<a id="__codelineno-7-2" name="__codelineno-7-2" href="#__codelineno-7-2"></a><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="p">{</span><span class="w"></span>
<a id="__codelineno-7-3" name="__codelineno-7-3" href="#__codelineno-7-3"></a><span class="w">    </span><span class="n">ElemType</span><span class="w"> </span><span class="n">data</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-7-4" name="__codelineno-7-4" href="#__codelineno-7-4"></a><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">next</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-7-5" name="__codelineno-7-5" href="#__codelineno-7-5"></a><span class="p">}</span><span class="n">SLinkList</span><span class="p">[</span><span class="n">MaxSize</span><span class="p">];</span><span class="w"></span>
</code></pre></div></p>
<h2 id="9-nfrac-1-n-1cn_2nfrac1n-1-frac2nn-times-n">9. N个不同元素进栈出栈，出栈的序列个数为：<span class="arithmatex">\(\frac {1} {n-1}C^{n}_{2n}=\frac{1}{n-1} \frac{(2n)!}{n! \times n!}\)</span><a class="headerlink" href="#9-nfrac-1-n-1cn_2nfrac1n-1-frac2nn-times-n" title="Permanent link">&para;</a></h2>
<h2 id="10">10 顺序栈的实现，关键标识的设置<a class="headerlink" href="#10" title="Permanent link">&para;</a></h2>
<p>利用一组地址连续的存储单元存放自栈底到栈顶的数据元素，并附设一个指针<code>top</code>指示当前栈顶元素的位置</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-8-1" name="__codelineno-8-1" href="#__codelineno-8-1"></a><span class="cp">#define MaxSize 50            </span><span class="c1">//定义栈中元素最大个数</span>
<a id="__codelineno-8-2" name="__codelineno-8-2" href="#__codelineno-8-2"></a><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="p">{</span><span class="w"></span>
<a id="__codelineno-8-3" name="__codelineno-8-3" href="#__codelineno-8-3"></a><span class="w">    </span><span class="n">Elemtype</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="n">MaxSize</span><span class="p">];</span><span class="w">    </span><span class="c1">//存放栈中元素</span>
<a id="__codelineno-8-4" name="__codelineno-8-4" href="#__codelineno-8-4"></a><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">top</span><span class="p">;</span><span class="c1">//栈顶指针</span>
<a id="__codelineno-8-5" name="__codelineno-8-5" href="#__codelineno-8-5"></a><span class="p">}</span><span class="w"></span>
</code></pre></div>
<ul>
<li>栈顶指针：<code>S.top</code>，初始时设置<code>S.top=-1</code>；栈顶元素：<code>S.data[S.top]</code></li>
<li>进栈操作：栈不满时，栈顶指针先加 1，再送值到栈顶元素</li>
<li>出栈操作：栈非空时，先取栈顶元素值，再将栈顶指针减 1</li>
<li>栈空条件：<code>S.top==-1</code>；栈满条件：<code>S.top==MaxSize-1</code>；栈长：<code>S.top+1</code></li>
</ul>
<h2 id="11">11. 共享栈的改进<a class="headerlink" href="#11" title="Permanent link">&para;</a></h2>
<p>利用栈底位置相对不变的特性，可让两个顺序栈共享一个一维数组空间，将两个栈的栈底分别设置在共享空间的两端，两个栈顶共享空间的中间延伸。</p>
<ul>
<li>
<p>两个栈的栈顶指针都指向栈顶元素</p>
</li>
<li>
<p><code>top0=-1</code>时 0 号栈为空，<code>top1=MaxSize</code>时<code>1</code>号栈为空</p>
</li>
<li>
<p><code>top1-top0==1</code>为栈满</p>
</li>
<li>
<p>当<code>0</code>号栈进栈时<code>top0</code>先加 1 再赋值，<code>1</code>号栈进栈时<code>top1</code>先减 1 再赋值；出栈是刚好相反</p>
</li>
</ul>
<h2 id="12">12. 栈的链式存储结构， 一般为了方便，没有头节点<a class="headerlink" href="#12" title="Permanent link">&para;</a></h2>
<p>采用链式存储的栈称为<strong>链栈</strong>，链栈的优点是便于多个栈共享存储空间和提高其效率，且不存在栈满上溢的情况。这里规定链栈没有头结点，<code>Lhead</code>指向栈顶元素</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-9-1" name="__codelineno-9-1" href="#__codelineno-9-1"></a><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">Linknode</span><span class="p">{</span><span class="w"></span>
<a id="__codelineno-9-2" name="__codelineno-9-2" href="#__codelineno-9-2"></a><span class="w">    </span><span class="n">ElemType</span><span class="w"> </span><span class="n">data</span><span class="p">;</span><span class="c1">//数据域</span>
<a id="__codelineno-9-3" name="__codelineno-9-3" href="#__codelineno-9-3"></a><span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">Linknode</span><span class="w"> </span><span class="o">*</span><span class="n">next</span><span class="p">;</span><span class="c1">//指针域</span>
<a id="__codelineno-9-4" name="__codelineno-9-4" href="#__codelineno-9-4"></a><span class="p">}</span><span class="w"> </span><span class="o">*</span><span class="n">LiStack</span><span class="p">;</span><span class="c1">//栈类型定义</span>
</code></pre></div>
<h2 id="13">13. 队列的顺序存储及问题<a class="headerlink" href="#13" title="Permanent link">&para;</a></h2>
<p>队列的顺序实现是指分配一块连续的存储单元存放队列中的元素，并附设两个指针：队头指针<code>front</code>指向队头元素，队尾指针<code>rear</code>指向队尾元素的下一个位置</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-10-1" name="__codelineno-10-1" href="#__codelineno-10-1"></a><span class="cp">#define MaxSize 50</span><span class="c1">//定义队列中元素的最大个数</span>
<a id="__codelineno-10-2" name="__codelineno-10-2" href="#__codelineno-10-2"></a><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="p">{</span><span class="w"></span>
<a id="__codelineno-10-3" name="__codelineno-10-3" href="#__codelineno-10-3"></a><span class="w">    </span><span class="n">ElemType</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="n">MaxSize</span><span class="p">];</span><span class="c1">//存放队列元素</span>
<a id="__codelineno-10-4" name="__codelineno-10-4" href="#__codelineno-10-4"></a><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">front</span><span class="p">,</span><span class="n">rear</span><span class="p">;</span><span class="c1">//队头指针和队尾指针</span>
<a id="__codelineno-10-5" name="__codelineno-10-5" href="#__codelineno-10-5"></a><span class="p">}</span><span class="w"> </span><span class="n">SqQueue</span><span class="p">;</span><span class="w"></span>
</code></pre></div>
<ul>
<li>初始状态：<code>Q.front==Q.rear==0</code></li>
<li>进队操作：队不满时，先送值到队尾元素，再将队尾指针加 1</li>
<li>出队操作：队不空时，先取队头元素值，再将队头指针加 1</li>
</ul>
<h2 id="14">14. 队列的顺序存储的改进，循环队列的相关操作步骤及指针的设置<a class="headerlink" href="#14" title="Permanent link">&para;</a></h2>
<p>将顺序队列臆造为一个环状的空间，即把存储队列元素的表从逻辑上视为一个环，称为循环队列。当队首指针<code>Q.front=MaxSize-1</code>后，再前进一个位置就自动到 0，这可以利用除法取余运算<code>%</code>来实现</p>
<ul>
<li>初始状态：<code>Q.front=Q.rear=0</code></li>
<li>队首指针进 1：<code>Q.front=(Q.front+1)%MaxSize</code></li>
<li>队尾指针进 1：<code>Q.rear=(Q.rear+1)%MaxSize</code></li>
<li>队列长度：<code>(Q.rear+MaxSize-Q.front)%MaxSize</code></li>
<li>出队入队时：指针都按顺时针方向进 1</li>
</ul>
<p><strong>判断循环队列队空或队满的三种方式</strong></p>
<ol>
<li>
<p>牺牲一个单元来区分队空和队满，入队时少用一个队列单元，约定以 “队头指针在队尾指针的下一位置作为队满的标志”</p>
<blockquote>
<ul>
<li>队满条件：<code>(Q.rear+1)%MaxSize==Q.front</code></li>
<li>队空条件：<code>Q.front=Q.rear</code></li>
<li>队列中元素的个数：<code>(Q.rear-Q.front+MaxSize)%MaxSize</code></li>
</ul>
</blockquote>
</li>
<li>
<p>类型中增设表示元素个数的数据成员。</p>
<blockquote>
<ul>
<li>队空条件：<code>Q.size==0</code></li>
<li>队满条件：<code>Q.size==MaxSize</code></li>
</ul>
</blockquote>
</li>
<li>
<p>类型中增设<code>tag</code>数据成员，以区分是队满还是队空。</p>
<blockquote>
<ul>
<li><code>tag=0</code>时，若因删除导致<code>Q.front==Q.rear</code>, 则为队空</li>
<li><code>tag=1</code>时，若因插入导致<code>Q.front==Q.rear</code>, 则为队满</li>
</ul>
</blockquote>
</li>
</ol>
<h2 id="15">15. 队列的链式存储结构，通常带有头结点<a class="headerlink" href="#15" title="Permanent link">&para;</a></h2>
<p>队列的链式表示称为链队列，它实际是一个同时带有队头指针和队尾指针的单链表。头指针指向队头结点，尾指针指向队尾结点。</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-11-1" name="__codelineno-11-1" href="#__codelineno-11-1"></a><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="p">{</span><span class="c1">//链式队列结点</span>
<a id="__codelineno-11-2" name="__codelineno-11-2" href="#__codelineno-11-2"></a><span class="w">    </span><span class="n">ElemType</span><span class="w"> </span><span class="n">data</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-11-3" name="__codelineno-11-3" href="#__codelineno-11-3"></a><span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">LinkNdoe</span><span class="w"> </span><span class="o">*</span><span class="n">next</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-11-4" name="__codelineno-11-4" href="#__codelineno-11-4"></a><span class="p">}</span><span class="n">LinkNode</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-11-5" name="__codelineno-11-5" href="#__codelineno-11-5"></a><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="p">{</span><span class="c1">//链式队列</span>
<a id="__codelineno-11-6" name="__codelineno-11-6" href="#__codelineno-11-6"></a><span class="w">    </span><span class="n">LinkNode</span><span class="w"> </span><span class="o">*</span><span class="n">front</span><span class="p">,</span><span class="o">*</span><span class="n">rear</span><span class="p">;</span><span class="c1">//队列的队头和队尾指针</span>
<a id="__codelineno-11-7" name="__codelineno-11-7" href="#__codelineno-11-7"></a><span class="p">}</span><span class="n">LinkQueue</span><span class="p">;</span><span class="w"></span>
</code></pre></div>
<p>通常将链式队列设计成一个带头结点对的单链表，这样插入和删除就统一了</p>
<h2 id="16">16. 双端队列<a class="headerlink" href="#16" title="Permanent link">&para;</a></h2>
<p>双端队列是指允许两端都可进行入队和出队操作的队列，其元素的逻辑结构仍是线性结构。将队列的两端分别称为前端和后端。</p>
<ul>
<li>输出受限的双端队列：允许在一端进行插入和删除，另一端只允许插入的双端队列</li>
<li>输入受限的双端队列：允许在一端进行插入和删除，另一端只允许删除的双端队列</li>
</ul>
<h2 id="17">17. 栈在括号匹配中的应用<a class="headerlink" href="#17" title="Permanent link">&para;</a></h2>
<ul>
<li>初始设置一个空栈，顺序读入括号</li>
<li>若是右括号，则或者置于栈顶的最急迫期待得以消解，或者是不合法的情况</li>
<li>若是左括号，则作为一个新的更急迫的期待压入栈中</li>
<li>算法结束时，栈为空，否则括号序列不匹配</li>
</ul>
<h2 id="18">18. 后续表达式计算方式<a class="headerlink" href="#18" title="Permanent link">&para;</a></h2>
<p>顺序扫描表达式的每一项，然后根据它的类型作出如下相应操作：若该项是操作数，则将其压入栈中；若该项是操作符<code>&lt;op&gt;</code>，则连续从栈中退出两个操作数<code>Y</code>和<code>X</code>，形成运算指令<code>X&lt;op&gt;Y</code>，并将计算结果重新压入栈中。当表达式的所有项扫描并处理完毕后，栈顶存放的就是最后的结果</p>
<h2 id="19">19. 中缀表达式转换为后缀表达式<a class="headerlink" href="#19" title="Permanent link">&para;</a></h2>
<h3 id="_5">手工做法<a class="headerlink" href="#_5" title="Permanent link">&para;</a></h3>
<ul>
<li>按照运算符的优先级对所有的运算单位加括号</li>
<li>转换为前缀或后缀表达式。前缀把运算符移动到对应的括号前面，后缀把运算符移动到对应的括号后面</li>
<li>把括号去掉</li>
</ul>
<h3 id="_6">算法思路<a class="headerlink" href="#_6" title="Permanent link">&para;</a></h3>
<ul>
<li>从左向右开始扫描中缀表达式</li>
<li>遇到数字时，加入后缀表达式</li>
<li>遇到运算符时</li>
<li>若为<code>(</code>, 入栈</li>
<li>若为<code>)</code>，则依次把栈中的运算符加入后缀表达式，直到出现<code>(</code>, 从栈中删除<code>(</code></li>
<li>若为除括号外的其他运算符，当其优先级高于除<code>(</code>外的栈顶运算符时，直接入栈。否则从栈顶开始，依次弹出比当前处理的运算符优先级高和优先级相等的运算符，直到一个比它优先级低的或遇到一个左括号为止。</li>
</ul>
<p><img alt="" src="../../images/%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A1%88%E4%BE%8B.jpg" /></p>
<h2 id="20">20. 队列在层次遍历中的应用<a class="headerlink" href="#20" title="Permanent link">&para;</a></h2>
<ol>
<li>根节点入队</li>
<li>若队空，则结束遍历；否则重复<code>3</code>操作</li>
<li>队列中第一个结点出队，并访问之。若其没有左孩子，则将左孩子入队，若其有左孩子，则将其右孩子入队，返回<code>2</code></li>
</ol>
<h2 id="21">21. 广义的存储结构及获取表头表尾操作的组合<a class="headerlink" href="#21" title="Permanent link">&para;</a></h2>
<p><img alt="" src="../../images/v2-009abd78a500db269dc2cef760fb46d7_r.png" /></p>
<p>最后一个是一个无限深度的广义表<span class="arithmatex">\(B = (a, B)\)</span></p>
<p>已知广义表 <span class="arithmatex">\(L = (a, (b, c), (d, e))\)</span>使用取头函数 GetHead 和取尾函数 GetTail 求出原子 e</p>
<p><code>e = GetHead(GetTail(GetHead(GetTail(GetTail(L))))</code></p>
<h2 id="22-kmp">22. KMP 模式匹配<a class="headerlink" href="#22-kmp" title="Permanent link">&para;</a></h2>
<h3 id="_7">基础概念<a class="headerlink" href="#_7" title="Permanent link">&para;</a></h3>
<ul>
<li>前缀：除最后一个字符以外，字符串的所有头部子串</li>
<li>后缀：除第一个字符外，字符串的所有尾部子串</li>
<li>部分匹配值<code>PM</code>：字符串的前缀和后缀的最长相等前后缀长度</li>
</ul>
<h3 id="_8">算法原理<a class="headerlink" href="#_8" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>编号</th>
<th>描述</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>S</code></td>
<td>字符</td>
<td>a</td>
<td>b</td>
<td>c</td>
<td>a</td>
<td>c</td>
</tr>
<tr>
<td><code>PM</code></td>
<td>子串右移位数=已匹配的字符数-对应的部分匹配值：<code>Move=(j-1)-PM[j-1]</code></td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td><code>next</code>（<code>PM</code>右移一位）</td>
<td>子串右移位数：<code>Move=(j-1)-next[j]</code>，子串的比较指针回退到：<code>j=next[j]+1</code></td>
<td>-1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td><code>next=next+1</code></td>
<td>在子串的第j个字符与主串发生失配时，则跳到子串的<code>next[j]</code>位置重新与主串当前位置进行比较</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>2</td>
</tr>
</tbody>
</table>
<p><img alt="" src="../../images/KMP%E6%A1%88%E4%BE%8B.jpg" /></p>
<h3 id="kmp">KMP 算法的进一步优化<a class="headerlink" href="#kmp" title="Permanent link">&para;</a></h3>
<p><code>nextval[]</code>, 如果出现了 <span class="arithmatex">\(p_j=p_{next[j]}\)</span>​, 则将<code>next[j]</code>修正为<code>next[ next[j] ]</code>, 直到两者不相等</p>
<p><img alt="" src="../../images/KMP%E6%94%B9%E8%BF%9B%E6%A1%88%E4%BE%8B.jpg" /></p>
<h2 id="23">23. 树的常用性质<a class="headerlink" href="#23" title="Permanent link">&para;</a></h2>
<ul>
<li>树中的节点数等于所有结点的度数之和加 1</li>
<li>总结点数 = <span class="arithmatex">\(n_0+n_1+n_2+...+n_m\)</span>​</li>
<li>总分支数 = <span class="arithmatex">\(1n_1+2n_2+...+mn_m\)</span>​</li>
<li>总结点数 = 总分支数 + 1</li>
</ul>
<h2 id="24">24. 二叉树的主要特性<a class="headerlink" href="#24" title="Permanent link">&para;</a></h2>
<ul>
<li>满二叉树：一棵高度为 h，且含有 2 h − 1 2^h-1 2h−1 个结点的二叉树称为满二叉树，除叶子结点外每个结点度数为 2</li>
<li>
<p>完全二叉树：每个结点都与同等高度的满二叉树有同样的编号</p>
<ul>
<li>若 <span class="arithmatex">\(i\leq \lfloor n/2 \rfloor\)</span>, 则结点<code>i</code>为分支结点，否则为叶子结点</li>
<li>当 <span class="arithmatex">\(2i\leq n\)</span> 时，结点<code>i</code>的左孩子编号为 <span class="arithmatex">\(2i\)</span>, 否则无左孩子</li>
<li>当 <span class="arithmatex">\(2i+1\leq n\)</span>时，结点<code>i</code>的右孩子编号为 <span class="arithmatex">\(2i+1\)</span>, 否则无右孩子</li>
<li>结点<code>i</code>所在的层次为 <span class="arithmatex">\(\lfloor log_2i \rfloor\)</span></li>
<li>叶子结点只可能在层次最大的两层上出现，对于最大层次中的叶子结点，都依次排列在该层最左边的位置上</li>
<li>若有度为 1 的节点，则只可能有一个，且只有左孩子没有右孩子</li>
<li>若 n 为奇数，则每个分支结点都有左孩子和右孩子；若 n 为偶数，则编号最大的分支结点只有左孩子，没有右孩子</li>
</ul>
</li>
<li>
<p>非空二叉树上的叶子结点数等于度为 2 的结点数 + 1，即 <span class="arithmatex">\(n_0=n_2+1\)</span></p>
</li>
</ul>
<h2 id="25">25. 二叉树的遍历<a class="headerlink" href="#25" title="Permanent link">&para;</a></h2>
<p>二叉树的遍历是按照某条搜索路径访问树中每个结点，使得每个结点均被访问一次，而且仅被访问一次。共有先序遍历（NLR）、中序（LNR）、后序（LRN）三中遍历方法</p>
<h3 id="_9">递归遍历算法<a class="headerlink" href="#_9" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><a id="__codelineno-12-1" name="__codelineno-12-1" href="#__codelineno-12-1"></a><span class="kt">void</span><span class="w"> </span><span class="nf">PreOrder</span><span class="p">(</span><span class="n">BiTree</span><span class="w"> </span><span class="n">T</span><span class="p">){</span><span class="c1">//PreOrder-先序、InOrder-中序、PostOrder-后序</span>
<a id="__codelineno-12-2" name="__codelineno-12-2" href="#__codelineno-12-2"></a><span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">T</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">){</span><span class="w"></span>
<a id="__codelineno-12-3" name="__codelineno-12-3" href="#__codelineno-12-3"></a><span class="w">        </span><span class="n">visit</span><span class="p">(</span><span class="n">T</span><span class="p">);</span><span class="c1">//访问根结点</span>
<a id="__codelineno-12-4" name="__codelineno-12-4" href="#__codelineno-12-4"></a><span class="w">        </span><span class="n">PreOrder</span><span class="p">(</span><span class="n">T</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="p">);</span><span class="c1">//遍历访问左子树</span>
<a id="__codelineno-12-5" name="__codelineno-12-5" href="#__codelineno-12-5"></a><span class="w">        </span><span class="n">PreOrder</span><span class="p">(</span><span class="n">T</span><span class="o">-&gt;</span><span class="n">rchlid</span><span class="p">);</span><span class="c1">//遍历访问右子树</span>
<a id="__codelineno-12-6" name="__codelineno-12-6" href="#__codelineno-12-6"></a><span class="w">    </span><span class="p">}</span><span class="w"></span>
<a id="__codelineno-12-7" name="__codelineno-12-7" href="#__codelineno-12-7"></a><span class="p">}</span><span class="w"></span>
</code></pre></div>
<h3 id="_10">非递归遍历算法<a class="headerlink" href="#_10" title="Permanent link">&para;</a></h3>
<ul>
<li>先序遍历</li>
</ul>
<div class="highlight"><pre><span></span><code><a id="__codelineno-13-1" name="__codelineno-13-1" href="#__codelineno-13-1"></a><span class="kt">void</span><span class="w"> </span><span class="nf">PreOrder2</span><span class="p">(</span><span class="n">BiTree</span><span class="w"> </span><span class="n">T</span><span class="p">){</span><span class="w"></span>
<a id="__codelineno-13-2" name="__codelineno-13-2" href="#__codelineno-13-2"></a><span class="w">    </span><span class="n">InitStack</span><span class="p">(</span><span class="n">S</span><span class="p">);</span><span class="n">BiTree</span><span class="w"> </span><span class="n">p</span><span class="o">=</span><span class="n">T</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-13-3" name="__codelineno-13-3" href="#__codelineno-13-3"></a><span class="w">    </span><span class="k">while</span><span class="p">(</span><span class="n">p</span><span class="o">||!</span><span class="n">IsEmpty</span><span class="p">(</span><span class="n">S</span><span class="p">)){</span><span class="w"></span>
<a id="__codelineno-13-4" name="__codelineno-13-4" href="#__codelineno-13-4"></a><span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="p">){</span><span class="w"></span>
<a id="__codelineno-13-5" name="__codelineno-13-5" href="#__codelineno-13-5"></a><span class="w">            </span><span class="n">visit</span><span class="p">(</span><span class="n">p</span><span class="p">);</span><span class="n">Push</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">p</span><span class="p">);</span><span class="w"></span>
<a id="__codelineno-13-6" name="__codelineno-13-6" href="#__codelineno-13-6"></a><span class="w">            </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-13-7" name="__codelineno-13-7" href="#__codelineno-13-7"></a><span class="w">        </span><span class="p">}</span><span class="w"></span>
<a id="__codelineno-13-8" name="__codelineno-13-8" href="#__codelineno-13-8"></a><span class="w">        </span><span class="k">else</span><span class="p">{</span><span class="w"></span>
<a id="__codelineno-13-9" name="__codelineno-13-9" href="#__codelineno-13-9"></a><span class="w">            </span><span class="n">Pop</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">p</span><span class="p">);</span><span class="w"></span>
<a id="__codelineno-13-10" name="__codelineno-13-10" href="#__codelineno-13-10"></a><span class="w">            </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-13-11" name="__codelineno-13-11" href="#__codelineno-13-11"></a><span class="w">        </span><span class="p">}</span><span class="w"></span>
<a id="__codelineno-13-12" name="__codelineno-13-12" href="#__codelineno-13-12"></a><span class="w">    </span><span class="p">}</span><span class="w"></span>
<a id="__codelineno-13-13" name="__codelineno-13-13" href="#__codelineno-13-13"></a><span class="p">}</span><span class="w"></span>
</code></pre></div>
<ul>
<li>中序遍历</li>
</ul>
<div class="highlight"><pre><span></span><code><a id="__codelineno-14-1" name="__codelineno-14-1" href="#__codelineno-14-1"></a><span class="kt">void</span><span class="w"> </span><span class="nf">Inorder2</span><span class="p">(</span><span class="n">BiTree</span><span class="w"> </span><span class="n">T</span><span class="p">){</span><span class="w"></span>
<a id="__codelineno-14-2" name="__codelineno-14-2" href="#__codelineno-14-2"></a><span class="w">    </span><span class="n">InitStack</span><span class="p">(</span><span class="n">S</span><span class="p">);</span><span class="n">BiTree</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T</span><span class="p">;</span><span class="c1">//初始化S，p是遍历指针</span>
<a id="__codelineno-14-3" name="__codelineno-14-3" href="#__codelineno-14-3"></a><span class="w">    </span><span class="k">while</span><span class="p">(</span><span class="n">p</span><span class="o">||!</span><span class="n">IsEmpty</span><span class="p">(</span><span class="n">S</span><span class="p">)){</span><span class="w"></span>
<a id="__codelineno-14-4" name="__codelineno-14-4" href="#__codelineno-14-4"></a><span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="p">){</span><span class="c1">//一路向左</span>
<a id="__codelineno-14-5" name="__codelineno-14-5" href="#__codelineno-14-5"></a><span class="w">            </span><span class="n">Push</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">p</span><span class="p">);</span><span class="c1">//当前结点入栈</span>
<a id="__codelineno-14-6" name="__codelineno-14-6" href="#__codelineno-14-6"></a><span class="w">            </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="p">;</span><span class="c1">//左孩子不空，一直往左走</span>
<a id="__codelineno-14-7" name="__codelineno-14-7" href="#__codelineno-14-7"></a><span class="w">        </span><span class="p">}</span><span class="w"></span>
<a id="__codelineno-14-8" name="__codelineno-14-8" href="#__codelineno-14-8"></a><span class="w">        </span><span class="k">else</span><span class="p">{</span><span class="c1">//出栈，并转向出栈结点的左子树</span>
<a id="__codelineno-14-9" name="__codelineno-14-9" href="#__codelineno-14-9"></a><span class="w">            </span><span class="n">Pop</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">p</span><span class="p">);</span><span class="n">visit</span><span class="p">(</span><span class="n">p</span><span class="p">);</span><span class="c1">//栈顶元素出栈，访问出栈结点</span>
<a id="__codelineno-14-10" name="__codelineno-14-10" href="#__codelineno-14-10"></a><span class="w">            </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="p">;</span><span class="c1">//向右子树走</span>
<a id="__codelineno-14-11" name="__codelineno-14-11" href="#__codelineno-14-11"></a><span class="w">        </span><span class="p">}</span><span class="w"></span>
<a id="__codelineno-14-12" name="__codelineno-14-12" href="#__codelineno-14-12"></a><span class="w">    </span><span class="p">}</span><span class="w"></span>
<a id="__codelineno-14-13" name="__codelineno-14-13" href="#__codelineno-14-13"></a>
<a id="__codelineno-14-14" name="__codelineno-14-14" href="#__codelineno-14-14"></a><span class="p">}</span><span class="w"></span>
</code></pre></div>
<ul>
<li>后序遍历</li>
</ul>
<div class="highlight"><pre><span></span><code><a id="__codelineno-15-1" name="__codelineno-15-1" href="#__codelineno-15-1"></a><span class="kt">void</span><span class="w"> </span><span class="nf">PostOrder</span><span class="p">(</span><span class="n">BiTree</span><span class="w"> </span><span class="n">T</span><span class="p">){</span><span class="w"></span>
<a id="__codelineno-15-2" name="__codelineno-15-2" href="#__codelineno-15-2"></a><span class="w">    </span><span class="n">InitStack</span><span class="p">(</span><span class="n">S</span><span class="p">);</span><span class="w"></span>
<a id="__codelineno-15-3" name="__codelineno-15-3" href="#__codelineno-15-3"></a><span class="w">    </span><span class="n">P</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-15-4" name="__codelineno-15-4" href="#__codelineno-15-4"></a><span class="w">    </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-15-5" name="__codelineno-15-5" href="#__codelineno-15-5"></a><span class="w">    </span><span class="k">while</span><span class="p">(</span><span class="n">p</span><span class="o">||!</span><span class="n">IsEmpty</span><span class="p">(</span><span class="n">S</span><span class="p">)){</span><span class="w"></span>
<a id="__codelineno-15-6" name="__codelineno-15-6" href="#__codelineno-15-6"></a><span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="p">){</span><span class="w">                    </span><span class="c1">//走到最左边</span>
<a id="__codelineno-15-7" name="__codelineno-15-7" href="#__codelineno-15-7"></a><span class="w">            </span><span class="n">push</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">p</span><span class="p">);</span><span class="w"></span>
<a id="__codelineno-15-8" name="__codelineno-15-8" href="#__codelineno-15-8"></a><span class="w">            </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-15-9" name="__codelineno-15-9" href="#__codelineno-15-9"></a><span class="w">        </span><span class="p">}</span><span class="w"></span>
<a id="__codelineno-15-10" name="__codelineno-15-10" href="#__codelineno-15-10"></a><span class="w">        </span><span class="k">else</span><span class="p">{</span><span class="w">                            </span><span class="c1">//向右</span>
<a id="__codelineno-15-11" name="__codelineno-15-11" href="#__codelineno-15-11"></a><span class="w">            </span><span class="n">GetTop</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">p</span><span class="p">);</span><span class="w">                </span><span class="c1">//读栈顶结点（非出栈）</span>
<a id="__codelineno-15-12" name="__codelineno-15-12" href="#__codelineno-15-12"></a><span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="o">&amp;&amp;</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="o">!=</span><span class="n">r</span><span class="p">)</span><span class="w">    </span><span class="c1">//若右子树存在，且未被访问过</span>
<a id="__codelineno-15-13" name="__codelineno-15-13" href="#__codelineno-15-13"></a><span class="w">                </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="p">;</span><span class="w">            </span><span class="c1">//转向右</span>
<a id="__codelineno-15-14" name="__codelineno-15-14" href="#__codelineno-15-14"></a><span class="w">            </span><span class="k">else</span><span class="p">{</span><span class="w">                        </span><span class="c1">//否则，弹出结点并访问</span>
<a id="__codelineno-15-15" name="__codelineno-15-15" href="#__codelineno-15-15"></a><span class="w">                </span><span class="n">pop</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">p</span><span class="p">);</span><span class="w">                </span><span class="c1">//将结点弹出</span>
<a id="__codelineno-15-16" name="__codelineno-15-16" href="#__codelineno-15-16"></a><span class="w">                </span><span class="n">visit</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span><span class="w">            </span><span class="c1">//访问该结点</span>
<a id="__codelineno-15-17" name="__codelineno-15-17" href="#__codelineno-15-17"></a><span class="w">                </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="p">;</span><span class="w">                    </span><span class="c1">//记录最近访问过的结点</span>
<a id="__codelineno-15-18" name="__codelineno-15-18" href="#__codelineno-15-18"></a><span class="w">                </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w">                </span><span class="c1">//结点访问完，重置p指针</span>
<a id="__codelineno-15-19" name="__codelineno-15-19" href="#__codelineno-15-19"></a><span class="w">            </span><span class="p">}</span><span class="w"></span>
<a id="__codelineno-15-20" name="__codelineno-15-20" href="#__codelineno-15-20"></a><span class="w">        </span><span class="p">}</span><span class="c1">//else</span>
<a id="__codelineno-15-21" name="__codelineno-15-21" href="#__codelineno-15-21"></a><span class="w">    </span><span class="p">}</span><span class="c1">//while</span>
<a id="__codelineno-15-22" name="__codelineno-15-22" href="#__codelineno-15-22"></a><span class="p">}</span><span class="w"></span>
</code></pre></div>
<ul>
<li>层次遍历</li>
</ul>
<div class="highlight"><pre><span></span><code><a id="__codelineno-16-1" name="__codelineno-16-1" href="#__codelineno-16-1"></a><span class="kt">void</span><span class="w"> </span><span class="nf">LevelOrder</span><span class="p">(</span><span class="n">BiTree</span><span class="w"> </span><span class="n">T</span><span class="p">){</span><span class="w"></span>
<a id="__codelineno-16-2" name="__codelineno-16-2" href="#__codelineno-16-2"></a><span class="w">    </span><span class="n">InitQueue</span><span class="p">(</span><span class="n">Q</span><span class="p">);</span><span class="w"></span>
<a id="__codelineno-16-3" name="__codelineno-16-3" href="#__codelineno-16-3"></a><span class="w">    </span><span class="n">BiTree</span><span class="w"> </span><span class="n">p</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-16-4" name="__codelineno-16-4" href="#__codelineno-16-4"></a><span class="w">    </span><span class="n">EnQueue</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span><span class="n">T</span><span class="p">);</span><span class="c1">//将根结点入队</span>
<a id="__codelineno-16-5" name="__codelineno-16-5" href="#__codelineno-16-5"></a><span class="w">    </span><span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">IsEmpty</span><span class="p">(</span><span class="n">Q</span><span class="p">)){</span><span class="w"></span>
<a id="__codelineno-16-6" name="__codelineno-16-6" href="#__codelineno-16-6"></a><span class="w">        </span><span class="n">DeQueue</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span><span class="n">p</span><span class="p">);</span><span class="w"></span>
<a id="__codelineno-16-7" name="__codelineno-16-7" href="#__codelineno-16-7"></a><span class="w">        </span><span class="n">visit</span><span class="p">(</span><span class="n">p</span><span class="p">);</span><span class="w"></span>
<a id="__codelineno-16-8" name="__codelineno-16-8" href="#__codelineno-16-8"></a><span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span><span class="n">EnQueue</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="p">);</span><span class="w"></span>
<a id="__codelineno-16-9" name="__codelineno-16-9" href="#__codelineno-16-9"></a><span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span><span class="n">EnQueue</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="p">);</span><span class="w"></span>
<a id="__codelineno-16-10" name="__codelineno-16-10" href="#__codelineno-16-10"></a><span class="w">    </span><span class="p">}</span><span class="w"></span>
<a id="__codelineno-16-11" name="__codelineno-16-11" href="#__codelineno-16-11"></a><span class="p">}</span><span class="w"></span>
</code></pre></div>
<h2 id="26">26. 由遍历序列构造二叉树<a class="headerlink" href="#26" title="Permanent link">&para;</a></h2>
<p>由二叉树中序遍历结果和前序、后序、层次中的一个组合，就可唯一确定一棵二叉树
<img alt="" src="../../images/%E5%85%88%E5%BA%8F%E5%92%8C%E4%B8%AD%E5%BA%8F%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91%E6%A1%88%E4%BE%8B.jpg" /></p>
<h2 id="27">27. 线索二叉树的基本结构及线索化<a class="headerlink" href="#27" title="Permanent link">&para;</a></h2>
<p>在含<code>n</code>个结点的二叉树中，有<code>n+1</code>个空指针。引入线索二叉树正是为了加快查找结点前驱和后继的速度。</p>
<p>规定：若无左子树，令<code>lchild</code>指向其前驱结点；若无右子树，令<code>rchild</code>指向其后继结点</p>
<table>
<thead>
<tr>
<th><code>lchild</code></th>
<th><code>ltag</code></th>
<th><code>data</code></th>
<th><code>rtag</code></th>
<th><code>rchild</code></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p><span class="arithmatex">\(ltag= \begin{cases} 0,&amp;lchild域指示结点的左孩子\\ 1，&amp;lchild域指示结点的前驱 \end{cases}\)</span></p>
<p><span class="arithmatex">\(rtag=\begin{cases} 0,&amp;rchild域指示结点的右孩子\\ 1，&amp;rchild域指示结点的后继 \end{cases}\)</span></p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-17-1" name="__codelineno-17-1" href="#__codelineno-17-1"></a><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">ThreadNode</span><span class="p">{</span><span class="w"></span>
<a id="__codelineno-17-2" name="__codelineno-17-2" href="#__codelineno-17-2"></a><span class="w">    </span><span class="n">ElemType</span><span class="w"> </span><span class="n">data</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-17-3" name="__codelineno-17-3" href="#__codelineno-17-3"></a><span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">ThreadNode</span><span class="w"> </span><span class="o">*</span><span class="n">lchild</span><span class="p">,</span><span class="o">*</span><span class="n">rchild</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-17-4" name="__codelineno-17-4" href="#__codelineno-17-4"></a><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">ltag</span><span class="p">,</span><span class="n">rtag</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-17-5" name="__codelineno-17-5" href="#__codelineno-17-5"></a><span class="p">}</span><span class="n">ThreadNode</span><span class="p">,</span><span class="o">*</span><span class="n">ThreadTree</span><span class="p">;</span><span class="w"></span>
</code></pre></div>
<h3 id="_11">中序线索二叉树的构造<a class="headerlink" href="#_11" title="Permanent link">&para;</a></h3>
<p>线索化的实质就是遍历一次二叉树</p>
<h3 id="_12">中序线索二叉树的遍历<a class="headerlink" href="#_12" title="Permanent link">&para;</a></h3>
<p>在对其进行遍历时，只要先找到序列中的第一个节点，然后依次找结点的后继，直至后继为空。在中序线索二叉树中找结点后继的规律是：若其右标志为 “1”，则右链为线索，指示其后继，否则遍历右子树中第一个访问的结点为其后继。</p>
<h3 id="_13">先序线索二叉树和后序线索二叉树<a class="headerlink" href="#_13" title="Permanent link">&para;</a></h3>
<p>后序线索二叉树上找后继时需要知道结点双亲，即需采用带标志域的三叉链表作为存储结构。</p>
<h2 id="28">28 树的存储结构<a class="headerlink" href="#28" title="Permanent link">&para;</a></h2>
<h3 id="_14">双亲表示法（顺序存储）<a class="headerlink" href="#_14" title="Permanent link">&para;</a></h3>
<p><img alt="" src="../../images/20200205124743184.jpg" /></p>
<p>根节点的下标为 0，其伪指针域为<code>-1</code></p>
<h3 id="_15">孩子表示法（顺序+链式存储）<a class="headerlink" href="#_15" title="Permanent link">&para;</a></h3>
<p><img alt="" src="../../images/2020020513261515.png" /></p>
<p>孩子表示法：<code>顺序存储</code>结点数据，结点中保存孩子<code>链表</code>头指针（<code>链式存储</code>）</p>
<p><code>优点</code>：找孩子方便。
<code>缺点</code>：找父节点不方便。</p>
<h3 id="_16">孩子兄弟表示法（顺序+链式存储）<a class="headerlink" href="#_16" title="Permanent link">&para;</a></h3>
<p><img alt="" src="../../images/453_cc517c2353eb55fee933453aec89c3d5.png" /></p>
<p>孩子兄弟表示法：用<code>二叉链表</code>存储<code>树</code>——<code>两个指针</code>：<code>第一个孩子</code>和<code>右兄弟</code></p>
<p>用此方法存储的树，形态上和<code>二叉树</code>类似</p>
<h2 id="29">29. 树转换为二叉树<a class="headerlink" href="#29" title="Permanent link">&para;</a></h2>
<ul>
<li>
<p>规则：<strong>左孩子右兄弟</strong>。每个结点左指针指向它的第一个孩子，右指针指向它在树中的相邻右兄弟</p>
</li>
<li>
<p>画法：</p>
<ul>
<li>
<ol>
<li>在兄弟结点之间加一连线；</li>
</ol>
</li>
<li>
<ol>
<li>对每个结点，只保留它与第一个孩子的连线，而与其他孩子的连线全部抹掉；</li>
</ol>
</li>
<li>
<ol>
<li>以树为轴心，顺时针旋转 45°</li>
</ol>
</li>
</ul>
</li>
<li>
<p>特点：根无右子树</p>
</li>
<li><img alt="1637759667705" src="../../images/1637759667705.png" /></li>
</ul>
<h2 id="28_1">28. 森林转换二叉树<a class="headerlink" href="#28_1" title="Permanent link">&para;</a></h2>
<ul>
<li>规则：先将森林中的每棵树转换为二叉树；把第二棵树的根作为第一课树根的右兄弟，以此类推</li>
<li>画法：<ul>
<li>
<ol>
<li>森林中的每棵树转换为相应的二叉树 </li>
</ol>
</li>
<li>
<ol>
<li>每棵树的根也可视为兄弟关系，在每棵树的根之间加一根连线；</li>
</ol>
</li>
<li>
<ol>
<li>以第一棵树的根为轴心顺时针旋转 45°</li>
</ol>
</li>
</ul>
</li>
<li>特点：森林中每棵树的根节点从第二个开始依次连接到前一棵树的根的右孩子，因此最后一棵树的根节点的右指针为空。另外，每个非终端节点，其所有孩子结点在转换后，最后一个孩子的右指针也为空。</li>
</ul>
<p><img alt="1637759667694" src="../../images/1637759667694.png" /></p>
<h2 id="29_1">29. 二叉树转换为森林<a class="headerlink" href="#29_1" title="Permanent link">&para;</a></h2>
<p>若二叉树非空，则二叉树的根及其左子树为第一棵树的二叉树形式，故将根的右链断开。二叉树根的右子树又可视为由除第一棵树外的森林转换后的二叉树。
<img alt="1637759667683" src="../../images/1637759667683.jpg" /> </p>
<h2 id="30">30. 树和森林的遍历<a class="headerlink" href="#30" title="Permanent link">&para;</a></h2>
<h5 id="_17">树的遍历<a class="headerlink" href="#_17" title="Permanent link">&para;</a></h5>
<ul>
<li>先根遍历</li>
<li>后根遍历</li>
</ul>
<h5 id="_18">森林的遍历<a class="headerlink" href="#_18" title="Permanent link">&para;</a></h5>
<ul>
<li>
<p>先序遍历森林</p>
<ul>
<li>访问森林中第一棵树的根节点</li>
<li>先序遍历第一棵树的根节点的子树森林</li>
<li>先序遍历除去第一棵树后剩余的树构成的森林</li>
</ul>
</li>
<li>
<p>中序遍历森林（又称后根遍历）</p>
<ul>
<li>中序遍历森林中第一课树的根节点的子树森林</li>
<li>访问第一课树的根结点</li>
<li>中序遍历除去第一棵树后剩余的树构成的森林</li>
</ul>
</li>
<li>
<p>树和森林的遍历与二叉树遍历的对应关系</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>树</th>
<th>森林</th>
<th>二叉树</th>
</tr>
</thead>
<tbody>
<tr>
<td>先根遍历</td>
<td>先序遍历</td>
<td>先序遍历</td>
</tr>
<tr>
<td>后根遍历</td>
<td>中序遍历</td>
<td>中序遍历</td>
</tr>
</tbody>
</table>
<h2 id="31">31. 二叉排序树的查找、插入、构造及删除<a class="headerlink" href="#31" title="Permanent link">&para;</a></h2>
<p>先查找到需要插入的位置，直接插入即可；</p>
<h3 id="_19">二叉排序树的剔除<a class="headerlink" href="#_19" title="Permanent link">&para;</a></h3>
<ul>
<li>若被删除结点<code>z</code>是叶子结点，则直接删除</li>
<li>若结点<code>z</code>只有一棵左子树或右子树，则让<code>z</code>的子树成为<code>z</code>父节点的子树，替代<code>z</code>的位置</li>
<li>若结点<code>z</code>有左、右两棵子树，则令<code>z</code>的直接后继替代<code>z</code>，然后从二叉排序树中删去这个直接后继，这样就转换成了上面的两种情况
<img alt="" src="../../images/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E7%9A%84%E5%88%A0%E9%99%A4.jpg" /></li>
</ul>
<h3 id="_20">二叉排序树的查找效率分析<a class="headerlink" href="#_20" title="Permanent link">&para;</a></h3>
<ul>
<li><span class="arithmatex">\(O(log_2n)\)</span>（平衡二叉树）~ <span class="arithmatex">\(O(n)\)</span>(链表)</li>
<li><span class="arithmatex">\(ASL_a\)</span>​: 平均查找长度，具体计算见查找部分</li>
</ul>
<h2 id="32">32. 平衡二叉树的插入、构建及查找<a class="headerlink" href="#32" title="Permanent link">&para;</a></h2>
<h3 id="_21">平衡二叉树的插入<a class="headerlink" href="#_21" title="Permanent link">&para;</a></h3>
<ul>
<li>①LL：在A的<code>左孩子的左子树</code>中插入导致A的不平衡，将A的<code>左孩子右上旋</code>。
  <img alt="" src="../../images/LL%E5%B9%B3%E8%A1%A1%E6%97%8B%E8%BD%AC.png" /></li>
<li>②RR：在A的<code>右孩子的右子树</code>中插入导致A的不平衡，将A的<code>右孩子左上旋</code>。
  <img alt="" src="../../images/RR%E5%B9%B3%E8%A1%A1%E6%97%8B%E8%BD%AC.jpg" /></li>
<li>③LR：在A的<code>左孩子的右子树</code>中插入导致A的不平衡，将A的<code>左孩子的右孩子，先左上旋再右上旋</code>。
  <img alt="" src="../../images/LR%E5%B9%B3%E8%A1%A1%E6%97%8B%E8%BD%AC.png" /></li>
<li>④RL：在A的<code>右孩子的左子树</code>中插入导致A的不平衡，将A的<code>右孩子的左孩子，先右上旋再左上旋</code>。
  <img alt="" src="../../images/RL%E5%B9%B3%E8%A1%A1%E6%97%8B%E8%BD%AC.png" /></li>
</ul>
<p><img alt="" src="../../images/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9E%84%E9%80%A0%E6%A1%88%E4%BE%8B.jpg" /></p>
<h3 id="_22">平衡二叉树的查找<a class="headerlink" href="#_22" title="Permanent link">&para;</a></h3>
<ul>
<li>含有 n 个结点的平衡二叉树的最大深度为 <span class="arithmatex">\(O(log_2n)\)</span>, 平均查找长度为 <span class="arithmatex">\(O(log_2n)\)</span></li>
<li>平衡二叉树结点数的递推关系 <span class="arithmatex">\(n_h=1+n_{h-1}+n_{h-2},n_0=0,n_1=1,n_2=2\)</span>, <span class="arithmatex">\(n_h\)</span>​为构造此高度的平衡二叉树所需的最少结点数
<img alt="" src="../../images/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E6%B7%B1%E5%BA%A6%E5%85%B3%E7%B3%BB.jpg" /></li>
</ul>
<h2 id="33">33. 哈夫曼树和哈夫曼编码<a class="headerlink" href="#33" title="Permanent link">&para;</a></h2>
<ul>
<li>带权路径长度： <span class="arithmatex">\(WPL=\sum_{i=1}^nw_il_i\)</span></li>
<li>含有<code>n</code>个带权结点的二叉树中，带权路径长度<code>WPL</code>最小的二叉树称为哈夫曼树</li>
</ul>
<h3 id="_23">哈夫曼树的构造<a class="headerlink" href="#_23" title="Permanent link">&para;</a></h3>
<ol>
<li>将 n 个结点分别作为<code>n</code>棵仅含有一个结点的二叉树，构成森林<code>F</code></li>
<li>构造一个新结点，从<code>F</code>中选取两棵根结点权值最小的树作为新结点的左、右子树，并且将新结点的权值置为左、右子树上根结点的权值之和</li>
<li>从<code>F</code>中删除刚才选出的两棵树，同时将新得到的树加入<code>F</code>中</li>
<li>重复 2-3 步骤</li>
</ol>
<p><img alt="" src="../../images/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%9E%84%E9%80%A0%E8%BF%87%E7%A8%8B%E6%A1%88%E4%BE%8B.jpg" /></p>
<h3 id="_24">特点<a class="headerlink" href="#_24" title="Permanent link">&para;</a></h3>
<ul>
<li>每个初始节点最终都成为叶结点</li>
<li>构造过程中新建了<code>n-1</code>个结点，哈夫曼树中结点总数为<code>2n-1</code></li>
<li>不存在度为<code>1</code>的节点</li>
</ul>
<h3 id="_25">哈夫曼编码<a class="headerlink" href="#_25" title="Permanent link">&para;</a></h3>
<ul>
<li>固定长度编码：对每个字符用相等长度的二进制位表示</li>
<li>可变长度编码：允许对不同字符用不等长的二进制位表示</li>
<li>前缀编码：没有一个编码是另一个编码的前缀</li>
<li>使用哈夫曼树得到哈夫曼编码：默认为左边为 0，右边为 1（不唯一，没明确规定）
<img alt="1637761333305" src="../../images/1637761333305.jpg" /></li>
</ul>
<h2 id="34">34. 图的存储及存储方式间的相互转换<a class="headerlink" href="#34" title="Permanent link">&para;</a></h2>
<h3 id="_26">邻接矩阵法<a class="headerlink" href="#_26" title="Permanent link">&para;</a></h3>
<p><img alt="" src="../../images/20210309174041355.png" /></p>
<ul>
<li>一个一维数组存储图中顶点的信息</li>
<li>一个二维数组存储图中边的信息，称为<strong>邻接矩阵</strong></li>
<li>设图 <span class="arithmatex">\(G\)</span>的邻接矩阵为 <span class="arithmatex">\(A\)</span>, <span class="arithmatex">\(A^n\)</span> 的元素等于从顶点 i 到 j 的长度为 n 的路径数目</li>
</ul>
<h3 id="_27">邻接表法<a class="headerlink" href="#_27" title="Permanent link">&para;</a></h3>
<p><img alt="" src="../../images/20210414215342883.png" /></p>
<ul>
<li>顶点表结点</li>
</ul>
<p>边表的头指针和顶点的数据信息采用顺序存储</p>
<table>
<thead>
<tr>
<th>顶点域</th>
<th>边表头指针</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>data</code></td>
<td><code>firstarc</code></td>
</tr>
</tbody>
</table>
<ul>
<li>边表结点</li>
</ul>
<p>对每个顶点 <span class="arithmatex">\(v_i\)</span>​建立一个单链表，第 <span class="arithmatex">\(i\)</span>个单链表中的结点表示依附于顶点 <span class="arithmatex">\(v_i\)</span>​的边，这个单链表为顶点 <span class="arithmatex">\(v_i\)</span>​的<strong>边表</strong></p>
<table>
<thead>
<tr>
<th>邻接点域</th>
<th>指针域</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>adjvex</code></td>
<td><code>nextarc</code></td>
</tr>
</tbody>
</table>
<ul>
<li>若存储的是无向图, 空间复杂度为 <span class="arithmatex">\(O(|V|+2|E|)\)</span>；若为有向图，空间复杂度为 <span class="arithmatex">\(O(|V|+|E|)\)</span></li>
</ul>
<h3 id="_28">十字链表<a class="headerlink" href="#_28" title="Permanent link">&para;</a></h3>
<ul>
<li>有向图的一种链式存储结构</li>
<li>对应于有向图中的每条弧有一个结点，对应于每个顶点也有一个结点</li>
</ul>
<p><img alt="" src="../../images/2-1FH010305Y06.png" />
<img alt="" src="../../images/v2-71e203ce285e52c56741ae13cbd90e78_r.jpg" /></p>
<h3 id="_29">邻接多重表<a class="headerlink" href="#_29" title="Permanent link">&para;</a></h3>
<p><img alt="" src="../../images/v2-a4db40f270e4526e2f93d215fd54ac3b_r.jpg" />
* 无向图的链式存储结构
* 与邻接表的区别是，同一条边在邻接多重表中只有一个结点</p>
<h2 id="35">35. 图的广度优先算法及深度优先搜索<a class="headerlink" href="#35" title="Permanent link">&para;</a></h2>
<h3 id="_30">广度优先搜索<a class="headerlink" href="#_30" title="Permanent link">&para;</a></h3>
<ul>
<li>基本思想</li>
</ul>
<p>首先访问起始顶点 <span class="arithmatex">\(v\)</span>, 接着由 <span class="arithmatex">\(v\)</span>出发，依次访问 <span class="arithmatex">\(v\)</span> 的各个未访问过的邻接顶点 <span class="arithmatex">\(w_1,w_2,...,w_i\)</span>​, 然后一次访问<span class="arithmatex">\(w_1,w_2,...,w_i\)</span> ​的所有未被访问的邻接顶点。</p>
<p>换句话说，<code>BFS</code>是以<code>v</code>为起始点，由近及远依次访问和<code>v</code>有路径相通且路径长度为 1,2,… 的顶点</p>
<p><img alt="" src="../../images/v2-9b9fe810f9437a5490378151c164b648_r.jpg" /></p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-18-1" name="__codelineno-18-1" href="#__codelineno-18-1"></a><span class="kt">bool</span><span class="w"> </span><span class="n">visited</span><span class="p">[</span><span class="n">MAX_VERTEX_NUM</span><span class="p">];</span><span class="c1">//访问标记数组</span>
<a id="__codelineno-18-2" name="__codelineno-18-2" href="#__codelineno-18-2"></a><span class="kt">void</span><span class="w"> </span><span class="nf">BFSTraverse</span><span class="p">(</span><span class="n">Graph</span><span class="w"> </span><span class="n">G</span><span class="p">){</span><span class="w">    </span><span class="c1">//对图G进行广度优先遍历</span>
<a id="__codelineno-18-3" name="__codelineno-18-3" href="#__codelineno-18-3"></a><span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">G</span><span class="p">.</span><span class="n">vexnum</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<a id="__codelineno-18-4" name="__codelineno-18-4" href="#__codelineno-18-4"></a><span class="w">        </span><span class="n">visited</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FALSE</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-18-5" name="__codelineno-18-5" href="#__codelineno-18-5"></a><span class="w">    </span><span class="n">InitQueue</span><span class="p">(</span><span class="n">Q</span><span class="p">);</span><span class="w"></span>
<a id="__codelineno-18-6" name="__codelineno-18-6" href="#__codelineno-18-6"></a><span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">G</span><span class="p">.</span><span class="n">vexnum</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"></span>
<a id="__codelineno-18-7" name="__codelineno-18-7" href="#__codelineno-18-7"></a><span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">visited</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="w">        </span><span class="c1">//对每个连通分量调用一次BFS</span>
<a id="__codelineno-18-8" name="__codelineno-18-8" href="#__codelineno-18-8"></a><span class="w">            </span><span class="n">BFS</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">i</span><span class="p">);</span><span class="w"></span>
<a id="__codelineno-18-9" name="__codelineno-18-9" href="#__codelineno-18-9"></a><span class="p">}</span><span class="w"></span>
<a id="__codelineno-18-10" name="__codelineno-18-10" href="#__codelineno-18-10"></a><span class="kt">void</span><span class="w"> </span><span class="nf">BFS</span><span class="p">(</span><span class="n">Graph</span><span class="w"> </span><span class="n">G</span><span class="p">,</span><span class="kt">int</span><span class="w"> </span><span class="n">v</span><span class="p">){</span><span class="c1">//从顶点v出发，广度优先遍历图G</span>
<a id="__codelineno-18-11" name="__codelineno-18-11" href="#__codelineno-18-11"></a><span class="w">    </span><span class="n">visit</span><span class="p">(</span><span class="n">v</span><span class="p">);</span><span class="w"></span>
<a id="__codelineno-18-12" name="__codelineno-18-12" href="#__codelineno-18-12"></a><span class="w">    </span><span class="n">visited</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TRUE</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-18-13" name="__codelineno-18-13" href="#__codelineno-18-13"></a><span class="w">    </span><span class="n">EnQueue</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span><span class="n">v</span><span class="p">);</span><span class="w"></span>
<a id="__codelineno-18-14" name="__codelineno-18-14" href="#__codelineno-18-14"></a><span class="w">    </span><span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">isEmpty</span><span class="p">(</span><span class="n">Q</span><span class="p">)){</span><span class="w"></span>
<a id="__codelineno-18-15" name="__codelineno-18-15" href="#__codelineno-18-15"></a><span class="w">        </span><span class="n">DeQueue</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span><span class="n">v</span><span class="p">);</span><span class="w"></span>
<a id="__codelineno-18-16" name="__codelineno-18-16" href="#__codelineno-18-16"></a><span class="w">        </span><span class="k">for</span><span class="p">(</span><span class="n">w</span><span class="o">=</span><span class="n">FirstNeighbor</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">v</span><span class="p">);</span><span class="n">w</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">;</span><span class="n">w</span><span class="o">=</span><span class="n">Neighbor</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">v</span><span class="p">,</span><span class="n">w</span><span class="p">))</span><span class="w"></span>
<a id="__codelineno-18-17" name="__codelineno-18-17" href="#__codelineno-18-17"></a><span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">visited</span><span class="p">[</span><span class="n">w</span><span class="p">]){</span><span class="w"></span>
<a id="__codelineno-18-18" name="__codelineno-18-18" href="#__codelineno-18-18"></a><span class="w">                </span><span class="n">visit</span><span class="p">(</span><span class="n">w</span><span class="p">);</span><span class="w"></span>
<a id="__codelineno-18-19" name="__codelineno-18-19" href="#__codelineno-18-19"></a><span class="w">                </span><span class="n">visited</span><span class="p">[</span><span class="n">w</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TRUE</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-18-20" name="__codelineno-18-20" href="#__codelineno-18-20"></a><span class="w">                </span><span class="n">EnQueue</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span><span class="n">w</span><span class="p">);</span><span class="w"></span>
<a id="__codelineno-18-21" name="__codelineno-18-21" href="#__codelineno-18-21"></a><span class="w">            </span><span class="p">}</span><span class="w"></span>
<a id="__codelineno-18-22" name="__codelineno-18-22" href="#__codelineno-18-22"></a><span class="w">    </span><span class="p">}</span><span class="w"></span>
<a id="__codelineno-18-23" name="__codelineno-18-23" href="#__codelineno-18-23"></a><span class="p">}</span><span class="w"></span>
</code></pre></div>
<h3 id="_31">深度优先搜索<a class="headerlink" href="#_31" title="Permanent link">&para;</a></h3>
<ul>
<li>基本思想</li>
</ul>
<p>首先访问图中某一起始顶点 <span class="arithmatex">\(v\)</span>, 然后由 <span class="arithmatex">\(v\)</span>出发，访问与 <span class="arithmatex">\(v\)</span> 邻接且未被访问的任一顶点 <span class="arithmatex">\(w_1\)</span>​, 再访问与 <span class="arithmatex">\(w_1\)</span>​邻接且未被访问的任一顶点，重复上述过程</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-19-1" name="__codelineno-19-1" href="#__codelineno-19-1"></a><span class="kt">bool</span><span class="w"> </span><span class="n">visited</span><span class="p">[</span><span class="n">MAX_VERTEX_NUM</span><span class="p">];</span><span class="w"></span>
<a id="__codelineno-19-2" name="__codelineno-19-2" href="#__codelineno-19-2"></a><span class="kt">void</span><span class="w"> </span><span class="nf">DFSTraverse</span><span class="p">(</span><span class="n">Graph</span><span class="w"> </span><span class="n">G</span><span class="p">){</span><span class="w"></span>
<a id="__codelineno-19-3" name="__codelineno-19-3" href="#__codelineno-19-3"></a><span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="n">v</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">v</span><span class="o">&lt;</span><span class="n">G</span><span class="p">.</span><span class="n">vexnum</span><span class="p">;</span><span class="o">++</span><span class="n">v</span><span class="p">)</span><span class="w"></span>
<a id="__codelineno-19-4" name="__codelineno-19-4" href="#__codelineno-19-4"></a><span class="w">        </span><span class="n">visited</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FALSE</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-19-5" name="__codelineno-19-5" href="#__codelineno-19-5"></a><span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="n">v</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">v</span><span class="o">&lt;</span><span class="n">G</span><span class="p">.</span><span class="n">vexnum</span><span class="p">;</span><span class="o">++</span><span class="n">v</span><span class="p">)</span><span class="w"></span>
<a id="__codelineno-19-6" name="__codelineno-19-6" href="#__codelineno-19-6"></a><span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">visited</span><span class="p">[</span><span class="n">v</span><span class="p">])</span><span class="w"></span>
<a id="__codelineno-19-7" name="__codelineno-19-7" href="#__codelineno-19-7"></a><span class="w">            </span><span class="n">DFS</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">v</span><span class="p">);</span><span class="w">        </span>
<a id="__codelineno-19-8" name="__codelineno-19-8" href="#__codelineno-19-8"></a><span class="p">}</span><span class="w"></span>
<a id="__codelineno-19-9" name="__codelineno-19-9" href="#__codelineno-19-9"></a><span class="kt">void</span><span class="w"> </span><span class="nf">DFS</span><span class="p">(</span><span class="n">Graph</span><span class="w"> </span><span class="n">G</span><span class="p">,</span><span class="kt">int</span><span class="w"> </span><span class="n">v</span><span class="p">){</span><span class="w"></span>
<a id="__codelineno-19-10" name="__codelineno-19-10" href="#__codelineno-19-10"></a><span class="w">    </span><span class="n">visit</span><span class="p">(</span><span class="n">v</span><span class="p">);</span><span class="w"></span>
<a id="__codelineno-19-11" name="__codelineno-19-11" href="#__codelineno-19-11"></a><span class="w">    </span><span class="n">visited</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TRUE</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-19-12" name="__codelineno-19-12" href="#__codelineno-19-12"></a><span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="n">w</span><span class="o">=</span><span class="n">FirstNeighbor</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">v</span><span class="p">);</span><span class="n">w</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">;</span><span class="n">w</span><span class="o">=</span><span class="n">NextNeighbor</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">v</span><span class="p">,</span><span class="n">w</span><span class="p">))</span><span class="w"></span>
<a id="__codelineno-19-13" name="__codelineno-19-13" href="#__codelineno-19-13"></a><span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">visited</span><span class="p">[</span><span class="n">w</span><span class="p">]){</span><span class="w"></span>
<a id="__codelineno-19-14" name="__codelineno-19-14" href="#__codelineno-19-14"></a><span class="w">            </span><span class="n">DFS</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">w</span><span class="p">);</span><span class="w"></span>
<a id="__codelineno-19-15" name="__codelineno-19-15" href="#__codelineno-19-15"></a><span class="w">        </span><span class="p">}</span><span class="w"></span>
<a id="__codelineno-19-16" name="__codelineno-19-16" href="#__codelineno-19-16"></a><span class="p">}</span><span class="w"></span>
</code></pre></div>
<h4 id="_32">性能<a class="headerlink" href="#_32" title="Permanent link">&para;</a></h4>
<table>
<thead>
<tr>
<th>性能</th>
<th>广度优先搜索</th>
<th>深度优先搜索</th>
</tr>
</thead>
<tbody>
<tr>
<td>空间复杂度</td>
<td><span class="arithmatex">\(O(\|V\|)\)</span></td>
<td><span class="arithmatex">\(O(\|V\|)\)</span></td>
</tr>
<tr>
<td>时间复杂度-邻接矩阵</td>
<td><span class="arithmatex">\(O(\|V\|^2)\)</span></td>
<td><span class="arithmatex">\(O(\|V\|^2)\)</span></td>
</tr>
<tr>
<td>时间复杂度-邻接表</td>
<td><span class="arithmatex">\(O(\|V\| + \|E\|)\)</span></td>
<td><span class="arithmatex">\(O(\|V\| + \|E\|)\)</span></td>
</tr>
<tr>
<td>生成树</td>
<td>生成树，邻接表不唯一，邻接矩阵唯一</td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="36">36. 最小生成树<a class="headerlink" href="#36" title="Permanent link">&para;</a></h2>
<p>求一个带权连通图的最小生成树<code>Minimum-Spanning-Tree,MST</code></p>
<h3 id="prim">Prim 算法<a class="headerlink" href="#prim" title="Permanent link">&para;</a></h3>
<ul>
<li>基本思想
  <img alt="" src="../../images/v2-3e7e4f6a9393cd87e50691ff9674e50c_r.jpg" /></li>
<li>
<p>初始时从图中任取一顶点加入树 T, 此时树中只含有一个顶点</p>
</li>
<li>
<p>之后选择一个与当前 T 中<strong>顶点集合</strong>距离最近的顶点，且加入后不能出现环，并将该顶点和相应的边加入 T，每次操作后 T 中的顶点数和边数都增 1。</p>
</li>
<li>
<p>重复直到加满</p>
</li>
<li>
<p>时间复杂度： <span class="arithmatex">\(O(|V|^2)\)</span></p>
</li>
</ul>
<p><img alt="" src="../../images/v2-d5f88f830a01559f01c47168c7ce8326_r.jpg" /></p>
<p>最终可能的结果：
<img alt="" src="../../images/v2-dcbb7b3c956bab47af9d9898aa767366_r.jpg" /></p>
<h3 id="kruskal">Kruskal 算法<a class="headerlink" href="#kruskal" title="Permanent link">&para;</a></h3>
<p>基本思想</p>
<ul>
<li>初始时为只有 n 个顶点而无边的非连通图 T，每个顶点自成一个连通分量</li>
<li>按照边的权值由小到大，加入到非连通图 T 中，不能形成环</li>
<li>重复直到加满</li>
<li>时间复杂度： <span class="arithmatex">\(O(|E|log|E|)\)</span>，每轮判断是否属于同一个集合，需要  <span class="arithmatex">\(O(log|E|)\)</span></li>
</ul>
<p><img alt="" src="../../images/v2-d014a0bb409aa2d5d3a62608b40a7e7f_b.jpg" /></p>
<p>Prim算法时间复杂度：<span class="arithmatex">\(O(|V|^2)\)</span>  适合用于边稠密图</p>
<p>Kruskal算法时间复杂度： <span class="arithmatex">\(O(|E|log|E|)\)</span>  适合用于边稀疏图</p>
<h2 id="37">37. 最短路径<a class="headerlink" href="#37" title="Permanent link">&para;</a></h2>
<h3 id="dijkstra">Dijkstra 算法求单源最短路径<a class="headerlink" href="#dijkstra" title="Permanent link">&para;</a></h3>
<h4 id="_33">辅助数组<a class="headerlink" href="#_33" title="Permanent link">&para;</a></h4>
<ul>
<li>集合<code>S</code>：记录以求得的最短路径的顶点</li>
<li><code>dist[]</code>：记录从源点 <span class="arithmatex">\(v_0\)</span>​到其他各顶点当前的最短路径长度</li>
<li><code>path[]</code>：<code>path[i]</code>表示从源点到顶点 i 之间的最短路径的前驱结点。可用于回溯找最短路径</li>
</ul>
<h4 id="_34">算法步骤<a class="headerlink" href="#_34" title="Permanent link">&para;</a></h4>
<ol>
<li>
<p>初始化：集合<code>S</code>初始化为<code>{0}</code>,<code>dist[]</code>的初始值<code>dist[i]=arcs[0][i]</code></p>
</li>
<li>
<p>从顶点集合<code>V-S</code>中选出 <span class="arithmatex">\(v_j\)</span>​, 满足 <span class="arithmatex">\(dist[j]=Min\{dist[i] \ |v_i \in V-S\}\)</span>, 令<span class="arithmatex">\(S=S\cup\{j\}\)</span></p>
</li>
<li>
<p>根据公式修改从 <span class="arithmatex">\(v_0\)</span>​出发到集合 V-S 上任一顶点 <span class="arithmatex">\(v_k\)</span> 可达的最短路径长度,若<code>dist[j]+arcs[j][k]&lt;dist[k]</code>, 则更新</p>
</li>
<li>
<p>重复步骤 2-3 操作共<code>n-1</code>次</p>
</li>
<li>
<p>时间复杂度： <span class="arithmatex">\(O(|V|^2)\)</span></p>
</li>
<li>注意:Dijkstra 算法不适用于有负权值的带权图</li>
</ol>
<h4 id="_35">案例：<a class="headerlink" href="#_35" title="Permanent link">&para;</a></h4>
<ul>
<li>
<p>初始：从<span class="arithmatex">\(V_i\)</span>开始，初始化三个数组信息如下
<img alt="" src="../../images/v2-e277db3ec26a797fd288aa8e009fdc3f_r.jpg" /></p>
</li>
<li>
<p>第 1 轮：循环遍历所有结点，找到还没确定最短路径，且 dist 最小的顶点<span class="arithmatex">\(V_i\)</span>，令 final[i] = ture
<img alt="" src="../../images/v2-459788fef793c835d40f59cd5586abee_r.jpg" />
检查所有邻接自<span class="arithmatex">\(V_i\)</span>的顶点，若其 final 值为 false，则更新 dist 和 path 信息
<img alt="" src="../../images/v2-6a351cad7f222884ebf52b8c0aba2bb6_r.jpg" /></p>
</li>
<li>
<p>第 2 轮：循环遍历所有结点，找到还没确定最短路径，且 dist 最小的顶点<span class="arithmatex">\(V_i\)</span>，令 final[i] = ture
<img alt="" src="../../images/v2-d75e12c3f19a5cc56938dd829e37f019_r.jpg" />
检查所有邻接自<span class="arithmatex">\(V_i\)</span>的顶点，若其 final 值为 false，则更新 dist 和 path 信息
<img alt="" src="../../images/v2-d62624155e4e838820efc56f1bdcf104_b.jpg" /></p>
</li>
<li>
<p>第 3 轮：循环遍历所有结点，找到还没确定最短路径，且 dist 最小的顶点<span class="arithmatex">\(V_i\)</span>，令 final[i] = ture
<img alt="" src="../../images/v2-9c9c3a89a28247c89f34d18f55b66f3c_r.jpg" />
检查所有邻接自<span class="arithmatex">\(V_i\)</span>的顶点，若其 final 值为 false，则更新 dist 和 path 信息
<img alt="" src="../../images/v2-2194e70cbd083f29a0d17d32f6b1cfcd_b.jpg" /></p>
</li>
<li>
<p>第 4 轮：循环遍历所有结点，找到还没确定最短路径，且 dist 最小的顶点<span class="arithmatex">\(V_i\)</span> ，令 final[i] = ture
<img alt="" src="../../images/v2-d5fca76865716e5a65f61337c25633d5_r.jpg" />
因为找不到其他顶点了，也不用更新了，算法结束</p>
</li>
<li>
<p>结果: </p>
<ul>
<li><span class="arithmatex">\(V_0\)</span>到<span class="arithmatex">\(v_2\)</span>的最短（带权）路径长度为：dist[2] = 9</li>
<li>通过 path[] 可知，<span class="arithmatex">\(V_0\)</span>到 <span class="arithmatex">\(V_2\)</span>的最短（带权）路径： <span class="arithmatex">\(V_2\)</span> &lt;- <span class="arithmatex">\(V_4\)</span> &lt;- <span class="arithmatex">\(V_1\)</span>  &lt;- <span class="arithmatex">\(V_0\)</span></li>
</ul>
</li>
</ul>
<h3 id="floyd">Floyd 算法求个定点之间最短路径<a class="headerlink" href="#floyd" title="Permanent link">&para;</a></h3>
<p>算法描述</p>
<ul>
<li>
<p>定义一个 n 阶方阵 <span class="arithmatex">\(A^{(-1)}，A^{(0)}，...,A^{(n-1)}\)</span>, 其中 <span class="arithmatex">\(A^{(-1)}[i][j]=arcs[i][j],\)</span></p>
</li>
<li>
<p>根据递推公式重复<code>n</code>次，计算出 <span class="arithmatex">\(A^{(0)}，...,A^{(n-1)}\)</span></p>
</li>
<li>
<p><span class="arithmatex">\(A^{(k)}[i][j]=Min\{A^{(k-1)}[i][j],A^{(k-1)}[i][k]+A^{(k-1)}[k][j]\},k=0,1,..,n-1\)</span>
    其中，</p>
<ul>
<li><span class="arithmatex">\(A^{(0)}[i][j]\)</span>是从顶点 <span class="arithmatex">\(v_i\)</span> 到 <span class="arithmatex">\(v_j\)</span>​、中间路径是 <span class="arithmatex">\(v_0\)</span>​的最短路径的长度</li>
<li><span class="arithmatex">\(A^{(k)}[i][j]\)</span> 是从顶点 <span class="arithmatex">\(v_i\)</span>​到 <span class="arithmatex">\(v_j\)</span>​、中间顶点的序号不大于 k 的最短路径的长度</li>
</ul>
</li>
<li>
<p>时间复杂度 <span class="arithmatex">\(O(|V|^3)\)</span></p>
</li>
</ul>
<p>案例：</p>
<ul>
<li>
<p>初始：不允许在其他顶点中转，最短路径如下，path = -1 表示没有中转点
<img alt="" src="../../images/v2-a398b44588f84a64861dd7b0d7ba9361_b.jpg" /></p>
</li>
<li>
<p>第一步：允许在<span class="arithmatex">\(V_0\)</span>中转，最短路径是<span class="arithmatex">\(A^{(0)}\)</span>，在<span class="arithmatex">\(path^{(0)}\)</span>中记录中转的点<span class="arithmatex">\(V_2\)</span>到<span class="arithmatex">\(V_1\)</span>之间没有直接通路，但是能经过<span class="arithmatex">\(V_0\)</span>中转的话， <span class="arithmatex">\(V_2\)</span>到<span class="arithmatex">\(V_1\)</span>之间的距离从 ∞ 变为 11,公式化是，
<img alt="" src="../../images/v2-abba795f1e12d043de4aa595e146f0b4_r.jpg" />
其中上述<span class="arithmatex">\(V_0\)</span>在中转后从无穷大变为 11 的路径被找到了： 
<span class="arithmatex">\(A^{(-1)}[2][1] \gt A^{(-1)}[2][0] +  A^{(-1)}[0][1]=11\)</span>,修改矩阵的值为 <span class="arithmatex">\(A^{(0)}[2][1]=11,path^{(0)}[2][1]=0\)</span>：<br />
<img alt="" src="../../images/v2-d7e1c254942ef052e4112a3ca6944e62_r.jpg" /></p>
</li>
<li>
<p>第二步：允许在  <span class="arithmatex">\(V_0\)</span>、<span class="arithmatex">\(V_1\)</span> 中转，求<span class="arithmatex">\(A^{(1)}\)</span>和 <span class="arithmatex">\(path^{(1)}\)</span>, 继续根据公式
<img alt="" src="../../images/v2-c2c1488397b0b0291cce560ad53a43d1_b.jpg" />
找到了：
<img alt="" src="../../images/v2-08e8995bf7d7bf85fcd2a266a6f6d6b7_b.png" />
<img alt="" src="../../images/v2-c0e6ecd9075f3668d2084ae987f9d5cf_b.jpg" /></p>
</li>
<li>
<p>第三步：允许在  <span class="arithmatex">\(V_0\)</span>、<span class="arithmatex">\(V_1\)</span> 、<span class="arithmatex">\(V_2\)</span>  中转，求<span class="arithmatex">\(A^{(2)}\)</span>和 <span class="arithmatex">\(path^{(2)}\)</span> ,找到了
<img alt="" src="../../images/v2-55f33681af4d597a43abcf0bb1851d5e_r.png" />
<img alt="" src="../../images/v2-189fdc7c3740b0bde3cab19e4a52a339_b.jpg" /></p>
</li>
<li>
<p>根据  可知，<span class="arithmatex">\(V_1\)</span> 到 <span class="arithmatex">\(V_2\)</span> 最短路径长度为 4，根据  可知，完整路径信息为 <span class="arithmatex">\(V_1-V_2\)</span></p>
</li>
<li>
<p>根据  可知，<span class="arithmatex">\(V_0\)</span> 到 <span class="arithmatex">\(V_2\)</span> 最短路径长度为 10，根据  可知，完整路径信息为 <span class="arithmatex">\(V_0-V_1-V_2\)</span></p>
</li>
<li>
<p>根据  可知，<span class="arithmatex">\(V_1\)</span> 到 <span class="arithmatex">\(V_0\)</span> 最短路径长度为 9，根据  可知，完整路径信息为 <span class="arithmatex">\(V_1-V_2-V_0\)</span></p>
</li>
</ul>
<h2 id="38">38. 拓扑排序<a class="headerlink" href="#38" title="Permanent link">&para;</a></h2>
<ul>
<li><code>AOV网</code></li>
</ul>
<p>若用<code>AVG</code>表示一个工程，其顶点表示活动，用有向边 <span class="arithmatex">\(&lt;V_i,V_j&gt;\)</span> 表示活动 <span class="arithmatex">\(V_i\)</span> ​必须先于活动 <span class="arithmatex">\(V_j\)</span> ​进行的这样一种关系，则将这种有向图称为<strong>顶点表示活动的网络</strong></p>
<ul>
<li>
<p>拓扑排序：在图论中，由一个有向无环图的顶点组成的序列，当且仅当满足下列条件时，称为该图的一个拓扑排序</p>
<ul>
<li>每个顶点出现且只出现一次</li>
<li>若顶点<code>A</code>在序列中排在顶点 B 的前面，则在图中不存在从顶点 B 到顶点 A 的路径</li>
</ul>
</li>
<li>
<p>拓扑排序算法</p>
<ol>
<li>从<code>AOV</code>网中选择一个没有前驱的顶点并输出</li>
<li>从网中删除该顶点和所有以它为起点的有向边</li>
<li>重复 1-2，直到当前<code>AOV</code>网为空</li>
</ol>
</li>
<li>
<p>时间复杂度 <span class="arithmatex">\(O(|V|+|E|)\)</span>,采用邻接矩阵时间复杂度 <span class="arithmatex">\(O(|V|^2)\)</span></p>
</li>
<li>
<p>逆拓扑排序</p>
<ol>
<li>从<code>AOV</code>网中选择一个没有后继的顶点并输出</li>
<li>从网中删除该顶点和所有以它为重点的有向边</li>
<li>重复 1-2 直到<code>AOV</code>为空</li>
</ol>
</li>
<li>
<p>案例：
<img alt="" src="../../images/v2-72625858f7a6c5b09c05e136665cb838_r.jpg" />
<img alt="" src="../../images/v2-c8cb97c38afd30d70eeff5e7f0805da9_r.jpg" />
<img alt="" src="../../images/v2-478f7d47e7ecf4a2f2c42b705e25f835_r.jpg" /></p>
</li>
</ul>
<h2 id="39">39. 关键路径<a class="headerlink" href="#39" title="Permanent link">&para;</a></h2>
<p>在带权有向图中，以顶点表示事件，以有向边表示活动，以边上的权值表示完成该活动的开销，称之为<strong>用边表示活动的网络</strong>，简称<code>AOE网</code></p>
<p><img alt="" src="../../images/v2-21a577c594a72044dca81ae088cb12ff_r.jpg" /></p>
<ul>
<li>
<p><code>AOE网</code>中仅有一个入度为 0 的顶点，称为开始顶点（源点）；只存在一个出度为 0 的顶点，称之为结束顶点（汇点）</p>
</li>
<li>
<p>具有最大路径长度的路径称为<strong>关键路径</strong>，而把关键路径上的活动称为<strong>关键活动</strong></p>
</li>
<li>
<p>关键路径并不唯一，只提高其中一条关键路径上的关键活动速度不能缩短整个工程的工期。</p>
</li>
</ul>
<p>重要概念：</p>
<ul>
<li><strong>事件<span class="arithmatex">\(v_i\)</span>的最迟发生时间 <span class="arithmatex">\(v(k)\)</span></strong>:它是指在不推迟整个工程完成的前提下，该事件最迟必须发生的时间（紫色标注）</li>
<li><strong>活动 <span class="arithmatex">\(a_i\)</span> 的最迟开始时间 <span class="arithmatex">\(l(i)\)</span></strong>：它是指该活动弧的终点所表示事件的最迟发生时间与该活动所需时间之差（绿色标注）</li>
</ul>
<p><img alt="" src="../../images/v2-f43bff7a99a3af2806d5b526e6b3d27c_b.jpg" /></p>
<ul>
<li><strong>活动 <span class="arithmatex">\(a_i\)</span> 的最早开始时间 <span class="arithmatex">\(e(i)\)</span></strong>：指该活动弧的起点所表示的事件的最早发生时间（红色标注）</li>
<li><strong>活动 ai 的时间余量 <span class="arithmatex">\(d(i) = l(i) - e(i)\)</span></strong>，表示在不增加完成整个工程所需总时间的情况下，活动 ai 可以拖延的时间</li>
<li>若<span class="arithmatex">\(d(i) = 0\)</span> 即 <span class="arithmatex">\(l(i) = e(i)\)</span> 的活动 <strong><span class="arithmatex">\(a_i\)</span> 是关键活动</strong></li>
<li>由关键活动组成的路径就是<strong>关键路径</strong></li>
</ul>
<p><img alt="" src="../../images/v2-e4554b9c09dc9ca62fc6f000e11d6101_r.jpg" /></p>
<h5 id="_36">计算步骤<a class="headerlink" href="#_36" title="Permanent link">&para;</a></h5>
<ol>
<li>
<p><strong>事件 <span class="arithmatex">\(v_k\)</span>​的最早发生时间 <span class="arithmatex">\(ve(k)\)</span></strong></p>
<ul>
<li><span class="arithmatex">\(ve(源点)=0\)</span></li>
<li><span class="arithmatex">\(ve(k)=Max\{ve(j)+Weight(v_j,v_k\}\)</span></li>
</ul>
</li>
<li>
<p><strong>事件 <span class="arithmatex">\(v_k\)</span> ​的最迟发生时间 <span class="arithmatex">\(vl(k)\)</span></strong></p>
<ul>
<li><span class="arithmatex">\(vl(汇点)=ve(汇点)\)</span></li>
<li><span class="arithmatex">\(vl(k)=Min\{vl(j)-Weight(v_k,v_j\}\)</span></li>
</ul>
</li>
<li>
<p><strong>活动 <span class="arithmatex">\(a_i\)</span> ​的最早开始时间 <span class="arithmatex">\(e(i)\)</span></strong></p>
<ul>
<li>它是指该活动弧的起点所表示的事件最早发生时间。</li>
<li>若边 <span class="arithmatex">\(&lt;v_k,v_j&gt;\)</span>表示活动 <span class="arithmatex">\(a_i\)</span>​, 则有 <span class="arithmatex">\(e(i)=ve(k)\)</span></li>
</ul>
</li>
<li>
<p><strong>活动 <span class="arithmatex">\(a_i\)</span>​的最迟开始时间 <span class="arithmatex">\(l(i)\)</span></strong></p>
<ul>
<li>它是指该活动弧的终点所表示事件的最迟发生时间与该活动所需时间之差</li>
<li>若边 <span class="arithmatex">\(&lt;v_k,v_j&gt;\)</span> 表示活动 <span class="arithmatex">\(a_i\)</span> ​, 则有<span class="arithmatex">\(l(i)=vl(j)-Weight(v_k,v_j)\)</span></li>
</ul>
</li>
<li>
<p><strong>求所有活动的时间余量 <span class="arithmatex">\(d(i)=l(i)-e(i)\)</span></strong>, <span class="arithmatex">\(d(i)=0\)</span>的活动 <span class="arithmatex">\(a_i\)</span>​是关键活动</p>
</li>
</ol>
<p>案例：</p>
<ol>
<li>
<p>求所有事件的最早发生时间 <span class="arithmatex">\(ve\)</span></p>
<ul>
<li>(1) 计算拓扑排序序列:
    <img alt="" src="../../images/v2-9b359a8ba713ef6724fbe7bd1ae9831b_b.jpg" />
     <span class="arithmatex">\(V_1、V_3、V_2、V_5、V_4、V_6\)</span></li>
<li>(2) 按照序列计算最早发生时间<ul>
<li><span class="arithmatex">\(ve(1) = 0\)</span></li>
<li><span class="arithmatex">\(ve(3) = 2\)</span></li>
<li><span class="arithmatex">\(ve(2) = 3\)</span></li>
<li><span class="arithmatex">\(ve(5) = 6\)</span></li>
<li><span class="arithmatex">\(ve(4) = Max\{ve(2) + 2, ve(3) + 4\}= 6\)</span></li>
<li><span class="arithmatex">\(ve(6) = Max\{ve(5) + 1, ve(4) + 2, v(3) + 3\} = 8\)</span></li>
</ul>
</li>
</ul>
</li>
<li>
<p>求所有事件的最迟发生时间 <span class="arithmatex">\(vl\)</span></p>
<ul>
<li>(1) 计算逆拓扑排序序列：<span class="arithmatex">\(V_6、V_5、V_4、V_2、V_3、V_1\)</span></li>
<li>(2) 按照序列计算最迟发生时间<ul>
<li><span class="arithmatex">\(vl(6) = ve(6) = 8\)</span></li>
<li><span class="arithmatex">\(vl(5) = vl(6) - 1 = 7\)</span></li>
<li><span class="arithmatex">\(vl(4) = vl(6) - 2 = 6\)</span></li>
<li><span class="arithmatex">\(vl(2) = Min\{vl(5) - 1, vl(4) - 2\} = 4\)</span></li>
<li><span class="arithmatex">\(vl(3) = Min\{vl(4) - 4, vl(6) - 3\} = 2\)</span></li>
<li><span class="arithmatex">\(vl(1) = Min\{vl(2) - 3, vl(3) - 2\} = 0\)</span></li>
</ul>
</li>
</ul>
</li>
<li>
<p>求所有活动的最早发生时间 <span class="arithmatex">\(e\)</span>
<img alt="" src="../../images/v2-c54cf7ff92b9f11d7ec2e51a71dbec8d_r.jpg" />
<img alt="" src="../../images/v2-322ac25afe334e110eb308ddf1e06474_b.jpg" />
所有活动的最早发生时间, 若边 <span class="arithmatex">\(&lt;v_k,v_j&gt;\)</span>表示活动 <span class="arithmatex">\(a_i\)</span>​, 则有 <span class="arithmatex">\(e(i)=ve(k)\)</span>
<img alt="" src="../../images/v2-3f86f48fe1ab2418f59aad6243a8b730_r.jpg" /></p>
</li>
<li>
<p>求所有活动的最迟发生时间 <span class="arithmatex">\(l\)</span></p>
<ul>
<li>边 <span class="arithmatex">\(&lt;v_k,v_j&gt;\)</span> 表示活动 <span class="arithmatex">\(a_i\)</span> ​, 则有<span class="arithmatex">\(l(i)=vl(j)-Weight(v_k,v_j)\)</span></li>
<li>得到以下结果：
<img alt="" src="../../images/v2-34a4aea2c8200d80348406206ae42185_b.jpg" /></li>
</ul>
</li>
<li>
<p>求所有活动的时间余量:<span class="arithmatex">\(d(i) = l(i) - e(i)\)</span>, 得到：
  <img alt="" src="../../images/v2-3d54ec435830e61271ea6256ce6e3a05_b.jpg" /></p>
<ul>
<li>关键活动：<span class="arithmatex">\(a_2、a_5、a_7\)</span></li>
<li>关键路径：<span class="arithmatex">\(V_1 -&gt; V_3 -&gt; V_4 -&gt; V_6\)</span></li>
</ul>
</li>
</ol>
<h2 id="39_1">39. 折半查找<a class="headerlink" href="#39_1" title="Permanent link">&para;</a></h2>
<ul>
<li>基本思想</li>
</ul>
<p>首先将给定的<code>key</code>与表的中间位置的关键字比较，成功后返回；否则根据<code>key</code>与关键字的大小判断查找左边还是右边</p>
<p>折半查找整个算法中，关于 mid 的取值向上 / 向下需要统一</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-20-1" name="__codelineno-20-1" href="#__codelineno-20-1"></a><span class="kt">int</span><span class="w"> </span><span class="nf">Binary_Search</span><span class="p">(</span><span class="n">SeqList</span><span class="w"> </span><span class="n">L</span><span class="p">,</span><span class="n">ElemType</span><span class="w"> </span><span class="n">key</span><span class="p">){</span><span class="w"></span>
<a id="__codelineno-20-2" name="__codelineno-20-2" href="#__codelineno-20-2"></a><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">low</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">high</span><span class="o">=</span><span class="n">L</span><span class="p">.</span><span class="n">TableLen</span><span class="mi">-1</span><span class="p">,</span><span class="n">mid</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-20-3" name="__codelineno-20-3" href="#__codelineno-20-3"></a><span class="w">    </span><span class="k">while</span><span class="p">(</span><span class="n">low</span><span class="o">&lt;=</span><span class="n">high</span><span class="p">){</span><span class="w"></span>
<a id="__codelineno-20-4" name="__codelineno-20-4" href="#__codelineno-20-4"></a><span class="w">        </span><span class="n">mid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">low</span><span class="o">+</span><span class="n">high</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span><span class="w">        </span><span class="c1">//取中间位置</span>
<a id="__codelineno-20-5" name="__codelineno-20-5" href="#__codelineno-20-5"></a><span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">L</span><span class="p">.</span><span class="n">elem</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span><span class="o">==</span><span class="n">key</span><span class="p">)</span><span class="w"></span>
<a id="__codelineno-20-6" name="__codelineno-20-6" href="#__codelineno-20-6"></a><span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">mid</span><span class="p">;</span><span class="w">    </span>
<a id="__codelineno-20-7" name="__codelineno-20-7" href="#__codelineno-20-7"></a><span class="w">        </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="n">L</span><span class="p">.</span><span class="n">elem</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span><span class="o">&gt;</span><span class="n">key</span><span class="p">)</span><span class="w"></span>
<a id="__codelineno-20-8" name="__codelineno-20-8" href="#__codelineno-20-8"></a><span class="w">            </span><span class="n">high</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mid</span><span class="mi">-1</span><span class="p">;</span><span class="c1">//从前半部分继续查找</span>
<a id="__codelineno-20-9" name="__codelineno-20-9" href="#__codelineno-20-9"></a><span class="w">        </span><span class="k">else</span><span class="w"></span>
<a id="__codelineno-20-10" name="__codelineno-20-10" href="#__codelineno-20-10"></a><span class="w">            </span><span class="n">low</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span><span class="c1">//从后半部分继续查找</span>
<a id="__codelineno-20-11" name="__codelineno-20-11" href="#__codelineno-20-11"></a><span class="w">    </span><span class="p">}</span><span class="w"></span>
<a id="__codelineno-20-12" name="__codelineno-20-12" href="#__codelineno-20-12"></a><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span><span class="w">        </span><span class="c1">//查找失败，返回-1</span>
<a id="__codelineno-20-13" name="__codelineno-20-13" href="#__codelineno-20-13"></a><span class="p">}</span><span class="w"></span>
</code></pre></div>
<ul>
<li>折半查找又称二分查找，仅适用于有序的顺序表</li>
<li>
<p>仅适用于顺序存储结构，不适用于链式存储结构</p>
</li>
<li>
<p>生成<strong>判定树</strong>
<img alt="uTools_1638256209356" src="../../images/uTools_1638256209356.png" />
<img alt="uTools_1638256305668" src="../../images/uTools_1638256305668.png" />
<img alt="uTools_1638256324365" src="../../images/uTools_1638256324365.png" /></p>
</li>
</ul>
<p>判定树特性：
<img alt="uTools_1638256115837" src="../../images/uTools_1638256115837.png" /></p>
<ul>
<li>是平衡二叉树</li>
<li>有 <span class="arithmatex">\(n\)</span> 个圆形结点代表原数据或成功结点，<span class="arithmatex">\(n+1\)</span> 个方框结点代表不成功结点</li>
<li>每个圆形结点都不是叶子结点，一定有方框子结点</li>
<li>元素个数为<span class="arithmatex">\(n\)</span>时，树高度为 <span class="arithmatex">\(h=\lceil \log_2{(n+1)} \rceil\)</span></li>
</ul>
<p>与<code>折半查找判定树</code>的高度h有关。高度越小，查找效率越高
- 最好情况，平均查找长度=<span class="arithmatex">\(O(1)\)</span>
- 最坏情况，平均查找长度=<span class="arithmatex">\(O(log_2n)\)</span>
- 则<code>时间复杂度</code>=<span class="arithmatex">\(O(log_2n)\)</span></p>
<h2 id="40">40. 分块查找<a class="headerlink" href="#40" title="Permanent link">&para;</a></h2>
<p><code>分块查找</code>，又叫<code>索引顺序查找</code>。</p>
<p><code>算法思想</code>：用一个<code>索引表</code>给数据归类。</p>
<p>算法过程：
- ①在<code>索引表</code>中确定待查记录所属的分块（<code>可顺序、可折半</code>）
- ②在<code>块内顺序查找</code></p>
<p><img alt="uTools_1638257539381" src="../../images/uTools_1638257539381.png" /></p>
<h3 id="_37">用折半查找索引表：<a class="headerlink" href="#_37" title="Permanent link">&para;</a></h3>
<p>若索引表中不包含目标关键字，则折半查找索引表<code>最终停在low&gt;high</code>，要<code>在low所指分块中查找</code></p>
<h3 id="_38">查找效率分析<a class="headerlink" href="#_38" title="Permanent link">&para;</a></h3>
<p><img alt="uTools_1638258212238" src="../../images/uTools_1638258212238.png" /></p>
<p><img alt="uTools_1638258279430" src="../../images/uTools_1638258279430.png" /></p>
<h3 id="_39">时间复杂度评价<a class="headerlink" href="#_39" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>查找算法</th>
<th><span class="arithmatex">\(ASL_{成功}\)</span></th>
<th><span class="arithmatex">\(ASL_{失败}\)</span></th>
</tr>
</thead>
<tbody>
<tr>
<td>顺序查找-无序表</td>
<td><span class="arithmatex">\(\frac{n+1}{2}\)</span></td>
<td><span class="arithmatex">\(n+1\)</span></td>
</tr>
<tr>
<td>顺序查找-有序表</td>
<td><span class="arithmatex">\(\frac{n+1}{2}\)</span></td>
<td><span class="arithmatex">\(\frac{n} {2} +\frac{n}{n+1}\)</span></td>
</tr>
<tr>
<td>折半查找</td>
<td><span class="arithmatex">\(sum(圆形结点*对应层数)/n\)</span></td>
<td><span class="arithmatex">\(sum(方结点∗对应层数−1)/(n+1)\)</span></td>
</tr>
<tr>
<td>分块查找</td>
<td><span class="arithmatex">\(ASL=L_I+L_S\)</span></td>
<td>-</td>
</tr>
</tbody>
</table>
<h2 id="41-b">41. B 树及其基本操作<a class="headerlink" href="#41-b" title="Permanent link">&para;</a></h2>
<p>B 树又称<strong>多路平衡查找树</strong>，B 树中所有结点的孩子个数的最大值称为 B 树的阶，通常用<code>m</code>表示。</p>
<p>B 树是所有结点的平衡因子都等于 0 的多路平衡查找树</p>
<h3 id="_40">定义<a class="headerlink" href="#_40" title="Permanent link">&para;</a></h3>
<p><img alt="f" src="../../images/v2-ed4c157ae0382c3c3451a6d2f48e337b_b.jpg" />
* 树中每个结点至多有 m 棵子树，即至多含有 m-1 个关键字
* 若根结点不是终端节点，则至少有两棵子树
* 除根结点外的所有非叶结点至少有 <span class="arithmatex">\(\lceil m/2 \rceil\)</span>棵子树，即至少含有 <span class="arithmatex">\(\lceil m/2 \rceil-1\)</span> 个关键字
* 所有非叶子结点的结构如下:
<span class="arithmatex">\(n\)</span> | <span class="arithmatex">\(P_0\)</span> | <span class="arithmatex">\(K_1\)</span> | <span class="arithmatex">\(P_1\)</span> |<span class="arithmatex">\(K_2\)</span> | <span class="arithmatex">\(P_2\)</span> |<span class="arithmatex">\(...\)</span> | <span class="arithmatex">\(K_n\)</span> | <span class="arithmatex">\(P_n\)</span>
 其中， <span class="arithmatex">\(K_i\)</span>为结点的关键字， <span class="arithmatex">\(P_i\)</span>​为指向子树根结点的指针，且:
    - 指针 <span class="arithmatex">\(P_{i-1}\)</span> ​所指子树中所有结点的关键字均小于 <span class="arithmatex">\(K_i\)</span>
    - 指针<span class="arithmatex">\(P_i\)</span>​所指子树中所有结点的关键字均大于 <span class="arithmatex">\(K_i\)</span>​
    - 结点的孩子个数等于该节点中关键字个数加 1</p>
<ul>
<li>所有的叶节点都出现在同一层次上，并且不带信息，称为外部结点</li>
</ul>
<h3 id="b">B 树的高度<a class="headerlink" href="#b" title="Permanent link">&para;</a></h3>
<p>B 树的高度不包括最后的外部结点那一层</p>
<p><span class="arithmatex">\(\log_m(n+1) \leq h \leq \log_{\lceil m/2\rceil}((n+1)/2)+1\)</span></p>
<h3 id="b_1">B 树的查找<a class="headerlink" href="#b_1" title="Permanent link">&para;</a></h3>
<ul>
<li>在 B 树中找结点，在磁盘中进行</li>
<li>在结点在找关键字，在内存中进行</li>
</ul>
<h3 id="b_2">B 树的插入<a class="headerlink" href="#b_2" title="Permanent link">&para;</a></h3>
<ol>
<li>定位：利用 B 树的查找算法，找出插入该关键字的最低层中的某个非叶结点</li>
<li>插入：在 B 树中，每个失败结点的关键字个数都在区间 <span class="arithmatex">\([\ \lceil m/\rceil-1.m-1]\)</span> 内。插入后的结点关键字个数小于 m，可以直接插入。如果插入后关键字个数大于<code>m-1</code>, 必须进行分裂</li>
<li>分裂方法是<ul>
<li>取一个新结点，在插入 key 后的原结点，从中间位置将其中的关键字分为两部分</li>
<li>左部分包含的关键字放在原结点中，右部分包含的关键字放到新结点中</li>
<li>中间位置 1 的节点插入原节点的父节点。</li>
<li>若此时导致父节点也超过了上限，则对父节点继续分裂
<img alt="" src="../../images/v2-20c52fd3a6f984111eb8b9fb8d052bfd_r.jpg" />
<img alt="" src="../../images/v2-b108319de2a49504f01c1073999f7319_r.jpg" /></li>
</ul>
</li>
</ol>
<h3 id="b_3">B 树的删除<a class="headerlink" href="#b_3" title="Permanent link">&para;</a></h3>
<ul>
<li>
<p>当被删关键字<code>k</code><strong>不在终端结点</strong>时，可以用 k 的前驱或后继<code>k'</code>替代<code>k</code>, 然后在相应的结点中删除<code>k'</code>。关键字<code>k'</code>必定落在某个终端节点中，则转换成了被删关键字在终端结点中的情形
<img alt="" src="../../images/v2-38e3307125dbdda94e581440a099145b_r.jpg" /></p>
</li>
<li>
<p>当被删关键字<code>k</code><strong>在终端结点</strong>中时</p>
<ul>
<li>
<p><strong>直接删除关键字</strong>：若被删除关键字所在结点的关键字个数 &gt; <span class="arithmatex">\(\lceil m/2 \rceil\)</span>, 表明删除该关键字后仍满足 B 树的定义，则直接是删除该关键字</p>
</li>
<li>
<p><strong>兄弟够借</strong>：若被删除关键字所在结点的关键字个数 = <span class="arithmatex">\(\lceil m/2 \rceil-1\)</span>, 且与此节点相邻的右（左）兄弟节点的关键字个数 <span class="arithmatex">\(\geq \lceil m/2 \rceil\)</span>, 则需要调整该节点、右（左）兄弟结点及其双亲结点（父子换位法），以达到新的平衡
<img alt="" src="../../images/v2-1375aefdf486f8a76801fd460c843a7a_b.jpg" /></p>
</li>
<li><strong>兄弟不够借</strong>：若被删除关键字所在结点的关键字个数 = <span class="arithmatex">\(\lceil m/2 \rceil-1\)</span>, 且与此节点相邻的右（左）兄弟节点的关键字个数均 <span class="arithmatex">\(\lceil m/2 \rceil-1\)</span>, 则将关键字删除后与左（或右）兄弟结点及双亲结点中的关键字进行合并。
<img alt="" src="../../images/v2-7cb4ba6217df024401e8c39e457fe4f7_r.jpg" />
<img alt="" src="../../images/v2-a57a6f7ba9a6d9ac9163b014a0b756a3_b.jpg" />
在合并过程中，双亲结点中的关键字个数会减 1。若其双亲结点是根结点且关键字个数减少至 0，则直接将根结点删除，合并后的新结点成为根；若其双亲结点不是根结点，且关键字减少超过下限，在继续合并操作。
<img alt="" src="../../images/v2-faed443f4f805d1eda4be4da6ea4bcd3_r.jpg" />
<img alt="" src="../../images/v2-7048b1c5a0236267367d0edfc70b900c_r.jpg" />
<img alt="" src="../../images/v2-d3fae5bf722b762154ba2719aabe50c7_r.jpg" /></li>
</ul>
</li>
</ul>
<p>B树的构造及操作案例
<img alt="" src="../../images/B%E6%A0%91%E7%9A%84%E6%9E%84%E5%BB%BA%E6%A1%88%E4%BE%8B-1.jpg" />
<img alt="" src="../../images/B%E6%A0%91%E7%9A%84%E6%9E%84%E5%BB%BA%E6%A1%88%E4%BE%8B-2.jpg" /></p>
<h2 id="42">42. 散列表<a class="headerlink" href="#42" title="Permanent link">&para;</a></h2>
<h3 id="_41">基本概念<a class="headerlink" href="#_41" title="Permanent link">&para;</a></h3>
<ul>
<li>散列函数：一个把查找表中关键字映射成该关键字对应的地址的函数，记为<code>Hash(key)=Addr</code></li>
<li>冲突：散列函数把两个或两个以上的不同关键字映射到同一地址的现象</li>
<li>同义词：引起冲突的关键字</li>
<li>散列表：根据关键字而直接进行访问的数据结构。散列表建立了关键字和存储地址之间的一种直接映射关系</li>
</ul>
<h3 id="_42">散列函数的构造方法<a class="headerlink" href="#_42" title="Permanent link">&para;</a></h3>
<h3 id="_43">散列函数的要求<a class="headerlink" href="#_43" title="Permanent link">&para;</a></h3>
<ul>
<li>定义域包含全部关键字，值域依赖于散列表的大小或地址范围</li>
<li>散列函数计算出的地址应该能等概率、均匀的分布在整个地址空间中，减少冲突发生</li>
<li>尽可能简单，能够快速计算出散列地址</li>
</ul>
<table>
<thead>
<tr>
<th>常见构造函数</th>
<th>公式</th>
<th>评价</th>
</tr>
</thead>
<tbody>
<tr>
<td>直接定地法</td>
<td><span class="arithmatex">\(H(key)=key\)</span> 或H <span class="arithmatex">\(H(key)=a \times key+b\)</span></td>
<td>最简单，不会产生冲突。适合关键字的分布基本连续的情况</td>
</tr>
<tr>
<td>除留余数法</td>
<td><span class="arithmatex">\(H(key)=key\%p\)</span>，<span class="arithmatex">\(p\)</span> 为不大于散列表表长<span class="arithmatex">\(m\)</span>但最接近或等于<span class="arithmatex">\(m\)</span>的质数</td>
<td></td>
</tr>
<tr>
<td>数字分析法</td>
<td>设关键字是r进制数，选取数码分布比较均匀的若干位作为散列地址</td>
<td>适合于一致的关键字集合，若更换了关键字，则需要重新构造新的散列函数</td>
</tr>
<tr>
<td>平方取中法</td>
<td>取关键字对的平方值的中间几位作为散列值</td>
<td>适用于关键字的每位取值都不均匀或均小于散列地址所需的位数</td>
</tr>
</tbody>
</table>
<h3 id="_44">处理冲突的方法<a class="headerlink" href="#_44" title="Permanent link">&para;</a></h3>
<ul>
<li>开放定址法， <span class="arithmatex">\(H_i=(H(key)+d_i)\%m\)</span>, <span class="arithmatex">\(m\)</span> 表示散列表表长，<span class="arithmatex">\(d_i\)</span>​为增量序列</li>
</ul>
<table>
<thead>
<tr>
<th>开放定址法</th>
<th><span class="arithmatex">\(d_i\)</span></th>
<th>补充说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>线性探测法</td>
<td><span class="arithmatex">\(0,1,2,...,m-1\)</span></td>
<td>可能出现大量元素在相邻地址上聚集，降低查找效率</td>
</tr>
<tr>
<td>平方探测法</td>
<td><span class="arithmatex">\(0^2,1^2,-1^2,2^2,-2^2,...,k^2,-k^2\)</span></td>
<td>散列表长度m必须是一个可以表示成4k+3的素数</td>
</tr>
<tr>
<td>再散列法</td>
<td><span class="arithmatex">\(i*Hash_2(key)\)</span></td>
<td>i是冲突的次数</td>
</tr>
<tr>
<td>伪随机序列法</td>
<td><span class="arithmatex">\(d_i==随机序列\)</span></td>
<td></td>
</tr>
</tbody>
</table>
<ul>
<li>拉链法</li>
</ul>
<p>把所有的同义词存储在一个线性链表中，这个线性链表由其散列地址唯一标识</p>
<h3 id="_45">散列查找及性能分析<a class="headerlink" href="#_45" title="Permanent link">&para;</a></h3>
<h5 id="_46">查找过程<a class="headerlink" href="#_46" title="Permanent link">&para;</a></h5>
<ol>
<li>初始化<code>Addr=Hash(key)</code></li>
<li>检测查找表中地址为<code>Addr</code>的位置上是否有记录，若无记录，返回查找失败；若有记录。比较它与 key 的值，若相等，则返回查找成功的标志，否则执行步骤 3</li>
<li>用给定的处理冲突方法计算 “下一个散列地址”，并将<code>Addr</code>置为此地址，转入步骤 2</li>
</ol>
<p><strong>散列表的查找效率取决于散列函数、处理冲突的方法和装填因子</strong></p>
<ul>
<li>
<p>装填因子<span class="arithmatex">\(\alpha\)</span>定义为一个表的装满程度<br />
<span class="arithmatex">\(\alpha = \frac{表中记录数 n}{散列表长度 m}\)</span></p>
</li>
<li>
<p>线性探测
<img alt="1638281466946" src="../../images/1638281466946.jpg" />
<img alt="uTools_1638352055034" src="../../images/uTools_1638352055034.png" /></p>
</li>
</ul>
<p><img alt="uTools_1638352323225" src="../../images/uTools_1638352323225.png" /></p>
<p><img alt="uTools_1638352359885" src="../../images/uTools_1638352359885.png" /></p>
<ul>
<li>链地址法
<img alt="1638350479082" src="../../images/1638350479082.jpg" /></li>
</ul>
<h2 id="43">43. 直接插入排序<a class="headerlink" href="#43" title="Permanent link">&para;</a></h2>
<p>要将<code>L(i)</code>插入已有序的子序列<code>L[1...i-1]</code>，需要执行以下操作</p>
<ul>
<li>
<p>查找出<code>L(i)</code>在<code>L[1...i-1]</code>中的插入位置<code>k</code></p>
</li>
<li>
<p>将<code>L[k...i-1]</code>中的所有元素依次后移一个位置</p>
</li>
<li>
<p>将<code>L(i)</code>复制到<code>L(k)</code>
<img alt="" src="../../images/%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E6%A1%88%E4%BE%8B.jpg" /></p>
</li>
</ul>
<div class="highlight"><pre><span></span><code><a id="__codelineno-21-1" name="__codelineno-21-1" href="#__codelineno-21-1"></a><span class="kt">void</span><span class="w"> </span><span class="nf">InsertSort</span><span class="p">(</span><span class="n">ElemType</span><span class="w"> </span><span class="n">A</span><span class="p">[],</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">){</span><span class="w"></span>
<a id="__codelineno-21-2" name="__codelineno-21-2" href="#__codelineno-21-2"></a><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-21-3" name="__codelineno-21-3" href="#__codelineno-21-3"></a><span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">2</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w">    </span><span class="c1">//依次将A[2]...A[n]插入到前面已排序的序列</span>
<a id="__codelineno-21-4" name="__codelineno-21-4" href="#__codelineno-21-4"></a><span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="mi">-1</span><span class="p">]){</span><span class="w">    </span><span class="c1">//若A[i]小于前驱，则将其插入前面的有序表</span>
<a id="__codelineno-21-5" name="__codelineno-21-5" href="#__codelineno-21-5"></a><span class="w">            </span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w">    </span><span class="c1">//哨兵</span>
<a id="__codelineno-21-6" name="__codelineno-21-6" href="#__codelineno-21-6"></a><span class="w">            </span><span class="k">for</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="mi">-1</span><span class="p">;</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&lt;</span><span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">];</span><span class="o">--</span><span class="n">j</span><span class="p">)</span><span class="w">    </span><span class="c1">//从i-1开始比较，比较一次，向后移动一次</span>
<a id="__codelineno-21-7" name="__codelineno-21-7" href="#__codelineno-21-7"></a><span class="w">                </span><span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">];</span><span class="w">    </span>
<a id="__codelineno-21-8" name="__codelineno-21-8" href="#__codelineno-21-8"></a><span class="w">            </span><span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w">        </span><span class="c1">//找到插入位置，赋值</span>
<a id="__codelineno-21-9" name="__codelineno-21-9" href="#__codelineno-21-9"></a><span class="w">        </span><span class="p">}</span><span class="w"></span>
<a id="__codelineno-21-10" name="__codelineno-21-10" href="#__codelineno-21-10"></a><span class="p">}</span><span class="w"></span>
</code></pre></div>
<h2 id="44">44. 折半插入排序<a class="headerlink" href="#44" title="Permanent link">&para;</a></h2>
<ul>
<li>查找有序子表时用折半查找来实现</li>
<li>确定待插入位置后，同意以地向后移动元素</li>
</ul>
<div class="highlight"><pre><span></span><code><a id="__codelineno-22-1" name="__codelineno-22-1" href="#__codelineno-22-1"></a><span class="kt">void</span><span class="w"> </span><span class="nf">InsertSort</span><span class="p">(</span><span class="n">ElemType</span><span class="w"> </span><span class="n">A</span><span class="p">[],</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">){</span><span class="w"></span>
<a id="__codelineno-22-2" name="__codelineno-22-2" href="#__codelineno-22-2"></a><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">low</span><span class="p">,</span><span class="n">high</span><span class="p">,</span><span class="n">mid</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-22-3" name="__codelineno-22-3" href="#__codelineno-22-3"></a><span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">2</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span><span class="w">        </span><span class="c1">//依次将A[2]...A[n]插入到前面已排序的序列</span>
<a id="__codelineno-22-4" name="__codelineno-22-4" href="#__codelineno-22-4"></a><span class="w">        </span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w">        </span><span class="c1">//暂存单元，不是哨兵</span>
<a id="__codelineno-22-5" name="__codelineno-22-5" href="#__codelineno-22-5"></a><span class="w">        </span><span class="n">low</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="n">high</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="mi">-1</span><span class="p">;</span><span class="w">    </span>
<a id="__codelineno-22-6" name="__codelineno-22-6" href="#__codelineno-22-6"></a><span class="w">        </span><span class="k">while</span><span class="p">(</span><span class="n">low</span><span class="o">&lt;=</span><span class="n">high</span><span class="p">){</span><span class="w">        </span><span class="c1">//折半查找</span>
<a id="__codelineno-22-7" name="__codelineno-22-7" href="#__codelineno-22-7"></a><span class="w">            </span><span class="n">mid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">low</span><span class="o">+</span><span class="n">high</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-22-8" name="__codelineno-22-8" href="#__codelineno-22-8"></a><span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">min</span><span class="p">]</span><span class="o">&gt;</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="w"> </span><span class="n">high</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mid</span><span class="mi">-1</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-22-9" name="__codelineno-22-9" href="#__codelineno-22-9"></a><span class="w">            </span><span class="k">else</span><span class="w"> </span><span class="n">low</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-22-10" name="__codelineno-22-10" href="#__codelineno-22-10"></a><span class="w">        </span><span class="p">}</span><span class="w"></span>
<a id="__codelineno-22-11" name="__codelineno-22-11" href="#__codelineno-22-11"></a><span class="w">        </span><span class="k">for</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="mi">-1</span><span class="p">;</span><span class="n">j</span><span class="o">&gt;=</span><span class="n">high</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span><span class="o">--</span><span class="n">j</span><span class="p">)</span><span class="w">    </span><span class="c1">//统一后移元素</span>
<a id="__codelineno-22-12" name="__codelineno-22-12" href="#__codelineno-22-12"></a><span class="w">            </span><span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">];</span><span class="w"></span>
<a id="__codelineno-22-13" name="__codelineno-22-13" href="#__codelineno-22-13"></a><span class="w">        </span><span class="n">A</span><span class="p">[</span><span class="n">high</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w">            </span><span class="c1">//赋值</span>
<a id="__codelineno-22-14" name="__codelineno-22-14" href="#__codelineno-22-14"></a><span class="w">    </span><span class="p">}</span><span class="w"></span>
<a id="__codelineno-22-15" name="__codelineno-22-15" href="#__codelineno-22-15"></a><span class="p">}</span><span class="w"></span>
</code></pre></div>
<h2 id="45">45. 希尔排序<a class="headerlink" href="#45" title="Permanent link">&para;</a></h2>
<p>基本思想：先将待排序表分割成若干形如<code>L[i,i+d,i+2d,...,i+kd]</code>的特殊子表，即把相隔某个 “增量” 的记录组成一个子表，对每个子表分别进行直接插入排序，当整个表中的元素已呈 “毕本有序” 时，再对全体记录进行一次直接插入排序</p>
<p><strong>过程</strong></p>
<ul>
<li>先取一个小于 n 的步长 <span class="arithmatex">\(d_1\)</span>​, 把表中的全部记录分成 <span class="arithmatex">\(d_1\)</span>​组，所有距离为 <span class="arithmatex">\(d_1\)</span>​的倍数的记录放在同一组，在各组内进行直接插入排序</li>
<li>然后取第二个步长 <span class="arithmatex">\(d_2&lt;d_1\)</span>​.</li>
<li>重复上述过程，直到所取到的 <span class="arithmatex">\(d_t=1\)</span>，即所有记录已放在同一组，再进行直接插入排序</li>
</ul>
<p><strong>增量序列：</strong> <span class="arithmatex">\(d_1=n/2,d_{i+1}=\lfloor d_i/2 \rfloor\)</span>, 最后一个增量等于 1</p>
<p><img alt="" src="../../images/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%E6%A1%88%E4%BE%8B.jpg" /></p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-23-1" name="__codelineno-23-1" href="#__codelineno-23-1"></a><span class="kt">void</span><span class="w"> </span><span class="nf">ShellSort</span><span class="p">(</span><span class="n">ElemType</span><span class="w"> </span><span class="n">A</span><span class="p">[],</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">){</span><span class="w"></span>
<a id="__codelineno-23-2" name="__codelineno-23-2" href="#__codelineno-23-2"></a><span class="w">    </span><span class="c1">//A[0]只是暂存单元，不是哨兵</span>
<a id="__codelineno-23-3" name="__codelineno-23-3" href="#__codelineno-23-3"></a><span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="n">dk</span><span class="o">=</span><span class="n">n</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span><span class="n">dk</span><span class="o">&gt;=</span><span class="mi">1</span><span class="p">;</span><span class="n">dk</span><span class="o">=</span><span class="n">dk</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="w">        </span><span class="c1">//步长变换</span>
<a id="__codelineno-23-4" name="__codelineno-23-4" href="#__codelineno-23-4"></a><span class="w">        </span><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="n">dk</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w">        </span><span class="c1">//对d_i个组进行直接插入排序</span>
<a id="__codelineno-23-5" name="__codelineno-23-5" href="#__codelineno-23-5"></a><span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="n">dk</span><span class="p">]){</span><span class="w">        </span><span class="c1">//需要将A[i]插入所在的有序子表中</span>
<a id="__codelineno-23-6" name="__codelineno-23-6" href="#__codelineno-23-6"></a><span class="w">                </span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w">        </span><span class="c1">//暂存A[i]</span>
<a id="__codelineno-23-7" name="__codelineno-23-7" href="#__codelineno-23-7"></a><span class="w">                </span><span class="k">for</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="o">-</span><span class="n">dk</span><span class="p">;</span><span class="n">j</span><span class="o">&gt;</span><span class="mi">0</span><span class="o">&amp;&amp;</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&lt;</span><span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">];</span><span class="n">j</span><span class="o">-=</span><span class="n">dk</span><span class="p">)</span><span class="c1">//寻找插入位置</span>
<a id="__codelineno-23-8" name="__codelineno-23-8" href="#__codelineno-23-8"></a><span class="w">                    </span><span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="n">dk</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">];</span><span class="w">        </span><span class="c1">//记录后移</span>
<a id="__codelineno-23-9" name="__codelineno-23-9" href="#__codelineno-23-9"></a><span class="w">                </span><span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="n">dk</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w">            </span><span class="c1">//插入</span>
<a id="__codelineno-23-10" name="__codelineno-23-10" href="#__codelineno-23-10"></a><span class="w">            </span><span class="p">}</span><span class="w"></span>
<a id="__codelineno-23-11" name="__codelineno-23-11" href="#__codelineno-23-11"></a><span class="p">}</span><span class="w"></span>
</code></pre></div>
<h2 id="46">46. 交换排序<a class="headerlink" href="#46" title="Permanent link">&para;</a></h2>
<h4 id="731">7.3.1 冒泡排序<a class="headerlink" href="#731" title="Permanent link">&para;</a></h4>
<p>基本思想：从后往前（或从前往后）两两比较相邻元素的值，若为逆序则交换，指导序列比较完。</p>
<p><img alt="" src="../../images/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E6%A1%88%E4%BE%8B.jpg" /></p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-24-1" name="__codelineno-24-1" href="#__codelineno-24-1"></a><span class="kt">void</span><span class="w"> </span><span class="nf">BubbleSort</span><span class="p">(</span><span class="n">ElemType</span><span class="w"> </span><span class="n">A</span><span class="p">[],</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">){</span><span class="w"></span>
<a id="__codelineno-24-2" name="__codelineno-24-2" href="#__codelineno-24-2"></a><span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="mi">-1</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span><span class="w"></span>
<a id="__codelineno-24-3" name="__codelineno-24-3" href="#__codelineno-24-3"></a><span class="w">        </span><span class="n">flag</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w">                </span><span class="c1">//表示本趟冒泡是否发生交换的标志</span>
<a id="__codelineno-24-4" name="__codelineno-24-4" href="#__codelineno-24-4"></a><span class="w">        </span><span class="k">for</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="n">n</span><span class="mi">-1</span><span class="p">;</span><span class="n">j</span><span class="o">&gt;</span><span class="n">i</span><span class="p">;</span><span class="n">j</span><span class="o">--</span><span class="p">)</span><span class="w">            </span><span class="c1">//一趟冒泡过程</span>
<a id="__codelineno-24-5" name="__codelineno-24-5" href="#__codelineno-24-5"></a><span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="mi">-1</span><span class="p">]</span><span class="o">&gt;</span><span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">]){</span><span class="w">        </span><span class="c1">//若为逆序</span>
<a id="__codelineno-24-6" name="__codelineno-24-6" href="#__codelineno-24-6"></a><span class="w">                </span><span class="n">swap</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="mi">-1</span><span class="p">],</span><span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span><span class="w">    </span><span class="c1">//交换</span>
<a id="__codelineno-24-7" name="__codelineno-24-7" href="#__codelineno-24-7"></a><span class="w">                </span><span class="n">flag</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-24-8" name="__codelineno-24-8" href="#__codelineno-24-8"></a><span class="w">            </span><span class="p">}</span><span class="w"></span>
<a id="__codelineno-24-9" name="__codelineno-24-9" href="#__codelineno-24-9"></a><span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">flag</span><span class="o">==</span><span class="nb">false</span><span class="p">)</span><span class="w"></span>
<a id="__codelineno-24-10" name="__codelineno-24-10" href="#__codelineno-24-10"></a><span class="w">            </span><span class="k">return</span><span class="p">;</span><span class="w">            </span><span class="c1">//本趟遍历后没有发生交换，说明表已经有序</span>
<a id="__codelineno-24-11" name="__codelineno-24-11" href="#__codelineno-24-11"></a><span class="w">    </span><span class="p">}</span><span class="w"></span>
<a id="__codelineno-24-12" name="__codelineno-24-12" href="#__codelineno-24-12"></a><span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>注意：冒泡排序所产生的有序子序列是全局有序的。每一趟排序都会将一个元素放置到其最终的位置上</p>
<h2 id="46_1">46. 快速排序<a class="headerlink" href="#46_1" title="Permanent link">&para;</a></h2>
<p>基本思想：在待排序表<code>L[1...n]</code>中任取一个元素<code>pivot</code>作为<strong>枢轴</strong>, 通过一趟排序将待排序表划分为独立的两个部分<code>L[1...k-1]</code>和<code>L[k+1...n]</code>, 使得<code>L[1...k-1]</code>中的所有元素小于<code>pivot</code>,<code>L[k+1...n]</code>中的所有元素大于等于<code>pivot</code>, 则<code>pivot</code>放在了其最终位置<code>L(k)</code>上，这个过程称为一趟快速排序。然后分别对左右两部分重复上述过程，直到每个部分只有一个元素。</p>
<p><img alt="" src="../../images/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E6%A1%88%E4%BE%8B.jpg" /></p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-25-1" name="__codelineno-25-1" href="#__codelineno-25-1"></a><span class="kt">void</span><span class="w"> </span><span class="nf">QuickSort</span><span class="p">(</span><span class="n">ElemType</span><span class="w"> </span><span class="n">A</span><span class="p">[],</span><span class="kt">int</span><span class="w"> </span><span class="n">low</span><span class="p">,</span><span class="kt">int</span><span class="w"> </span><span class="n">high</span><span class="p">){</span><span class="w"></span>
<a id="__codelineno-25-2" name="__codelineno-25-2" href="#__codelineno-25-2"></a><span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">low</span><span class="o">&lt;</span><span class="n">high</span><span class="p">){</span><span class="w"></span>
<a id="__codelineno-25-3" name="__codelineno-25-3" href="#__codelineno-25-3"></a><span class="w">        </span><span class="c1">//Partition()就是划分操作，将表划分成满足条件的两个子表</span>
<a id="__codelineno-25-4" name="__codelineno-25-4" href="#__codelineno-25-4"></a><span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">pivotpos</span><span class="o">=</span><span class="n">Partition</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">low</span><span class="p">,</span><span class="n">high</span><span class="p">);</span><span class="w">    </span><span class="c1">//划分</span>
<a id="__codelineno-25-5" name="__codelineno-25-5" href="#__codelineno-25-5"></a><span class="w">        </span><span class="n">QuickSort</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">low</span><span class="p">,</span><span class="n">pivotpos</span><span class="mi">-1</span><span class="p">);</span><span class="w"></span>
<a id="__codelineno-25-6" name="__codelineno-25-6" href="#__codelineno-25-6"></a><span class="w">        </span><span class="n">QuickSort</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">pivots</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">high</span><span class="p">);</span><span class="w"></span>
<a id="__codelineno-25-7" name="__codelineno-25-7" href="#__codelineno-25-7"></a><span class="w">    </span><span class="p">}</span><span class="w"></span>
<a id="__codelineno-25-8" name="__codelineno-25-8" href="#__codelineno-25-8"></a><span class="p">}</span><span class="w"></span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><a id="__codelineno-26-1" name="__codelineno-26-1" href="#__codelineno-26-1"></a><span class="kt">int</span><span class="w"> </span><span class="nf">Partition</span><span class="p">(</span><span class="n">ElemType</span><span class="w"> </span><span class="n">A</span><span class="p">[],</span><span class="kt">int</span><span class="w"> </span><span class="n">low</span><span class="p">,</span><span class="kt">int</span><span class="w"> </span><span class="n">high</span><span class="p">){</span><span class="w">    </span><span class="c1">//一趟划分</span>
<a id="__codelineno-26-2" name="__codelineno-26-2" href="#__codelineno-26-2"></a><span class="w">    </span><span class="n">ElemType</span><span class="w"> </span><span class="n">pivot</span><span class="o">=</span><span class="n">A</span><span class="p">[</span><span class="n">low</span><span class="p">];</span><span class="w"></span>
<a id="__codelineno-26-3" name="__codelineno-26-3" href="#__codelineno-26-3"></a><span class="w">    </span><span class="k">while</span><span class="p">(</span><span class="n">low</span><span class="o">&lt;</span><span class="n">high</span><span class="p">){</span><span class="w"></span>
<a id="__codelineno-26-4" name="__codelineno-26-4" href="#__codelineno-26-4"></a><span class="w">        </span><span class="k">while</span><span class="p">(</span><span class="n">low</span><span class="o">&lt;</span><span class="n">high</span><span class="o">&amp;&amp;</span><span class="n">A</span><span class="p">[</span><span class="n">high</span><span class="p">]</span><span class="o">&gt;=</span><span class="n">pivot</span><span class="p">)</span><span class="w"> </span><span class="o">--</span><span class="n">high</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-26-5" name="__codelineno-26-5" href="#__codelineno-26-5"></a><span class="w">        </span><span class="n">A</span><span class="p">[</span><span class="n">low</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="n">high</span><span class="p">];</span><span class="w">        </span><span class="c1">//将比枢轴小的元素移动到左边</span>
<a id="__codelineno-26-6" name="__codelineno-26-6" href="#__codelineno-26-6"></a><span class="w">        </span><span class="k">while</span><span class="p">(</span><span class="n">low</span><span class="o">&lt;</span><span class="n">high</span><span class="o">&amp;&amp;</span><span class="n">A</span><span class="p">[</span><span class="n">low</span><span class="p">]</span><span class="o">&lt;=</span><span class="n">pivot</span><span class="p">)</span><span class="w"> </span><span class="o">++</span><span class="n">low</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-26-7" name="__codelineno-26-7" href="#__codelineno-26-7"></a><span class="w">        </span><span class="n">A</span><span class="p">[</span><span class="n">high</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="n">low</span><span class="p">];</span><span class="w">        </span><span class="c1">//将比枢轴大的元素移动到右边</span>
<a id="__codelineno-26-8" name="__codelineno-26-8" href="#__codelineno-26-8"></a><span class="w">    </span><span class="p">}</span><span class="w"></span>
<a id="__codelineno-26-9" name="__codelineno-26-9" href="#__codelineno-26-9"></a><span class="w">    </span><span class="n">A</span><span class="p">[</span><span class="n">low</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pivot</span><span class="p">;</span><span class="w">            </span><span class="c1">//枢轴放到最终位置</span>
<a id="__codelineno-26-10" name="__codelineno-26-10" href="#__codelineno-26-10"></a><span class="w">    </span><span class="n">reutrn</span><span class="w"> </span><span class="n">low</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-26-11" name="__codelineno-26-11" href="#__codelineno-26-11"></a><span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>快速排序是所有内部排序算法中平均性能最优的排序算法</p>
<h2 id="47">47. 简单选择排序<a class="headerlink" href="#47" title="Permanent link">&para;</a></h2>
<p>基本思想：假设排序表为<code>L[1...n]</code>, 第<code>i</code>趟排序即从<code>L[i...n]</code>中选择关键字最小的元素与<code>L(i)</code>交换，每一趟排序可以确定一个元素的最终位置，经过 n-1 趟排序可以使整个排序表有序</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-27-1" name="__codelineno-27-1" href="#__codelineno-27-1"></a><span class="kt">void</span><span class="w"> </span><span class="nf">SelectSort</span><span class="p">(</span><span class="n">ElemType</span><span class="w"> </span><span class="n">A</span><span class="p">[],</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">){</span><span class="w"></span>
<a id="__codelineno-27-2" name="__codelineno-27-2" href="#__codelineno-27-2"></a><span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="mi">-1</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span><span class="w">                </span><span class="c1">//一共进行n-1趟</span>
<a id="__codelineno-27-3" name="__codelineno-27-3" href="#__codelineno-27-3"></a><span class="w">        </span><span class="n">min</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w">                    </span><span class="c1">//记录最小元素位置</span>
<a id="__codelineno-27-4" name="__codelineno-27-4" href="#__codelineno-27-4"></a><span class="w">        </span><span class="k">for</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">)</span><span class="w">            </span><span class="c1">//在A[1...n-1]中选择最小的元素</span>
<a id="__codelineno-27-5" name="__codelineno-27-5" href="#__codelineno-27-5"></a><span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">&lt;</span><span class="n">A</span><span class="p">[</span><span class="n">min</span><span class="p">])</span><span class="w"> </span><span class="n">min</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">j</span><span class="p">;</span><span class="w">    </span><span class="c1">//更新最小的元素</span>
<a id="__codelineno-27-6" name="__codelineno-27-6" href="#__codelineno-27-6"></a><span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">min</span><span class="o">!=</span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="n">swap</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">A</span><span class="p">[</span><span class="n">min</span><span class="p">]);</span><span class="w">    </span><span class="c1">//封装的swap()函数共移动3次</span>
<a id="__codelineno-27-7" name="__codelineno-27-7" href="#__codelineno-27-7"></a><span class="w">    </span><span class="p">}</span><span class="w"></span>
<a id="__codelineno-27-8" name="__codelineno-27-8" href="#__codelineno-27-8"></a><span class="p">}</span><span class="w"></span>
</code></pre></div>
<h2 id="48">48. 堆排序<a class="headerlink" href="#48" title="Permanent link">&para;</a></h2>
<ul>
<li>
<p>大根堆：<code>L(i)&gt;=L(2i) &amp; L(i)&gt;=L(2i+1)</code>, 最大元素在根结点</p>
</li>
<li>
<p>小根堆：<code>L(i)&lt;=L(2i) &amp; L(i)&lt;=L(2i+1)</code>, 最小元素在根结点</p>
</li>
<li>
<p>堆的插入：把新结点放到堆的末端，后进行向上调整</p>
</li>
<li>
<p>构造初始堆：</p>
<ul>
<li>n 个结点的完全二叉树，最后一个结点是第 <span class="arithmatex">\(\lfloor n/2 \rfloor\)</span>个结点的孩子。对第<span class="arithmatex">\(\lfloor n/2 \rfloor\)</span>个结点为根的子树筛选（对于的大根堆，若根结点的关键字小于左右孩子中关键字较大者，则交换），使该子树成为堆。</li>
<li>之后向前依次对各节点<span class="arithmatex">\(\lfloor n/2 \rfloor-1 \sim 1\)</span> 为根的子树进行筛选，看该结点值是否大于其左右子节点的值，不大于的话进行交换</li>
<li>交换后可能会破坏下一级的堆，使用上述办法继续构造下一级的堆，直到以根结点形成堆为止</li>
</ul>
</li>
<li>
<p>输出堆顶元素，重新构建堆，重复这一过程</p>
</li>
</ul>
<p><img alt="" src="../../images/%E5%A4%A7%E9%A1%B6%E5%A0%86%E7%9A%84%E5%BB%BA%E7%AB%8B%E5%8F%8A%E8%B0%83%E6%95%B4.jpg" /></p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-28-1" name="__codelineno-28-1" href="#__codelineno-28-1"></a><span class="kt">void</span><span class="w"> </span><span class="nf">BuildMaxHead</span><span class="p">(</span><span class="n">ElemType</span><span class="w"> </span><span class="n">A</span><span class="p">[],</span><span class="kt">int</span><span class="w"> </span><span class="n">len</span><span class="p">){</span><span class="w"></span>
<a id="__codelineno-28-2" name="__codelineno-28-2" href="#__codelineno-28-2"></a><span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="n">len</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span><span class="n">i</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">--</span><span class="p">)</span><span class="w">    </span><span class="c1">//从i=n/2开始，反复调整堆</span>
<a id="__codelineno-28-3" name="__codelineno-28-3" href="#__codelineno-28-3"></a><span class="w">        </span><span class="n">HeadAdjust</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">len</span><span class="p">);</span><span class="w">    </span>
<a id="__codelineno-28-4" name="__codelineno-28-4" href="#__codelineno-28-4"></a><span class="p">}</span><span class="w"></span>
<a id="__codelineno-28-5" name="__codelineno-28-5" href="#__codelineno-28-5"></a><span class="kt">void</span><span class="w"> </span><span class="nf">HeadAdjust</span><span class="p">(</span><span class="n">ElemType</span><span class="w"> </span><span class="n">A</span><span class="p">[],</span><span class="kt">int</span><span class="w"> </span><span class="n">k</span><span class="p">,</span><span class="kt">int</span><span class="w"> </span><span class="n">len</span><span class="p">){</span><span class="w"></span>
<a id="__codelineno-28-6" name="__codelineno-28-6" href="#__codelineno-28-6"></a><span class="w">    </span><span class="c1">//将元素k为根的子树进行调整</span>
<a id="__codelineno-28-7" name="__codelineno-28-7" href="#__codelineno-28-7"></a><span class="w">    </span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="n">k</span><span class="p">];</span><span class="w">    </span><span class="c1">//A[0]暂存子树的根节点</span>
<a id="__codelineno-28-8" name="__codelineno-28-8" href="#__codelineno-28-8"></a><span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">2</span><span class="o">*</span><span class="n">k</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">len</span><span class="p">;</span><span class="n">i</span><span class="o">*</span><span class="mi">2</span><span class="p">){</span><span class="w">        </span><span class="c1">//沿key较大的子节点向下筛选</span>
<a id="__codelineno-28-9" name="__codelineno-28-9" href="#__codelineno-28-9"></a><span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="o">&lt;</span><span class="n">len</span><span class="o">&amp;&amp;</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span><span class="n">i</span><span class="o">++</span><span class="p">;</span><span class="w">    </span><span class="c1">//取i为较大子结点</span>
<a id="__codelineno-28-10" name="__codelineno-28-10" href="#__codelineno-28-10"></a><span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&gt;=</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="k">break</span><span class="p">;</span><span class="w">    </span><span class="c1">//筛选结束</span>
<a id="__codelineno-28-11" name="__codelineno-28-11" href="#__codelineno-28-11"></a><span class="w">        </span><span class="k">else</span><span class="p">{</span><span class="w"></span>
<a id="__codelineno-28-12" name="__codelineno-28-12" href="#__codelineno-28-12"></a><span class="w">            </span><span class="n">A</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">=</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w">            </span><span class="c1">//将A[i]调整到双亲结点上</span>
<a id="__codelineno-28-13" name="__codelineno-28-13" href="#__codelineno-28-13"></a><span class="w">            </span><span class="n">k</span><span class="o">=</span><span class="n">i</span><span class="p">;</span><span class="w">        </span><span class="c1">//修改k值，继续向下筛选</span>
<a id="__codelineno-28-14" name="__codelineno-28-14" href="#__codelineno-28-14"></a><span class="w">        </span><span class="p">}</span><span class="w"></span>
<a id="__codelineno-28-15" name="__codelineno-28-15" href="#__codelineno-28-15"></a><span class="w">    </span><span class="p">}</span><span class="w"></span>
<a id="__codelineno-28-16" name="__codelineno-28-16" href="#__codelineno-28-16"></a><span class="w">    </span><span class="n">A</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w">        </span><span class="c1">//被筛选结点的值放入最终位置</span>
<a id="__codelineno-28-17" name="__codelineno-28-17" href="#__codelineno-28-17"></a><span class="p">}</span><span class="w"></span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><a id="__codelineno-29-1" name="__codelineno-29-1" href="#__codelineno-29-1"></a><span class="kt">void</span><span class="w"> </span><span class="nf">HeapSort</span><span class="p">(</span><span class="n">ElemType</span><span class="w"> </span><span class="n">A</span><span class="p">[],</span><span class="kt">int</span><span class="w"> </span><span class="n">len</span><span class="p">){</span><span class="w"></span>
<a id="__codelineno-29-2" name="__codelineno-29-2" href="#__codelineno-29-2"></a><span class="w">    </span><span class="n">BuildMAxHeap</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">len</span><span class="p">);</span><span class="w"></span>
<a id="__codelineno-29-3" name="__codelineno-29-3" href="#__codelineno-29-3"></a><span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="n">len</span><span class="p">;</span><span class="n">i</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">--</span><span class="p">){</span><span class="w">        </span><span class="c1">//n-1趟的交换和建堆过程</span>
<a id="__codelineno-29-4" name="__codelineno-29-4" href="#__codelineno-29-4"></a><span class="w">        </span><span class="n">Swap</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span><span class="w">    </span><span class="c1">//输出堆顶元素，和堆底元素交换</span>
<a id="__codelineno-29-5" name="__codelineno-29-5" href="#__codelineno-29-5"></a><span class="w">        </span><span class="n">HeadAdjust</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="mi">-1</span><span class="p">);</span><span class="c1">//调整，把剩余的i-1个元素整理成堆</span>
<a id="__codelineno-29-6" name="__codelineno-29-6" href="#__codelineno-29-6"></a><span class="w">    </span><span class="p">}</span><span class="w"></span>
<a id="__codelineno-29-7" name="__codelineno-29-7" href="#__codelineno-29-7"></a><span class="p">}</span><span class="w"></span>
</code></pre></div>
<h2 id="49">49. 归并排序<a class="headerlink" href="#49" title="Permanent link">&para;</a></h2>
<p>假定待排序表含有 n 个记录，则可将其视为 n 个有序的子表，每个子表的长度为 1，然后两两合并，得到 <span class="arithmatex">\(\lceil n/2 \rceil\)</span>个长度为 2 或 1 的有序表，继续两两合并。这种排序方法称为 2 路归并排序。</p>
<p>一趟归并排序的操作是，调用 <span class="arithmatex">\(\lceil n/2h \rceil\)</span> 次算法<code>merge()</code>, 将<code>L[1...n]</code>中前后相邻且长度为 h 的有序段进行两两归并，得到前后相邻、长度为 2h 的有序段进行两两归并，得到前后相邻、长度为 2h 的有序段，整个归并排序需要进行 <span class="arithmatex">\(\lceil log_2n\rceil\)</span>趟</p>
<p><img alt="" src="../../images/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E6%A1%88%E4%BE%8B.jpg" /></p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-30-1" name="__codelineno-30-1" href="#__codelineno-30-1"></a><span class="n">ELemType</span><span class="w"> </span><span class="o">*</span><span class="n">B</span><span class="o">=</span><span class="p">(</span><span class="n">ElemType</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">((</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="n">ElemType</span><span class="p">));</span><span class="w">    </span><span class="c1">//辅助数组B</span>
<a id="__codelineno-30-2" name="__codelineno-30-2" href="#__codelineno-30-2"></a><span class="kt">void</span><span class="w"> </span><span class="nf">Merge</span><span class="p">(</span><span class="n">ElemType</span><span class="w"> </span><span class="n">A</span><span class="p">[],</span><span class="kt">int</span><span class="w"> </span><span class="n">low</span><span class="p">,</span><span class="kt">int</span><span class="w"> </span><span class="n">mid</span><span class="p">,</span><span class="kt">int</span><span class="w"> </span><span class="n">high</span><span class="p">){</span><span class="w"></span>
<a id="__codelineno-30-3" name="__codelineno-30-3" href="#__codelineno-30-3"></a><span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">k</span><span class="o">=</span><span class="n">low</span><span class="p">;</span><span class="n">k</span><span class="o">&lt;=</span><span class="n">high</span><span class="p">;</span><span class="n">k</span><span class="o">++</span><span class="p">)</span><span class="n">B</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="n">k</span><span class="p">];</span><span class="w">    </span><span class="c1">//将A中元素放到B中</span>
<a id="__codelineno-30-4" name="__codelineno-30-4" href="#__codelineno-30-4"></a><span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="n">low</span><span class="p">,</span><span class="n">j</span><span class="o">=</span><span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">k</span><span class="o">=</span><span class="n">i</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">mid</span><span class="o">&amp;&amp;</span><span class="n">j</span><span class="o">&lt;=</span><span class="n">high</span><span class="p">;</span><span class="n">k</span><span class="o">++</span><span class="p">){</span><span class="w"></span>
<a id="__codelineno-30-5" name="__codelineno-30-5" href="#__codelineno-30-5"></a><span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;=</span><span class="n">B</span><span class="p">[</span><span class="n">j</span><span class="p">])</span><span class="n">A</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">];</span><span class="w">    </span><span class="c1">//将较小值赋值到A中</span>
<a id="__codelineno-30-6" name="__codelineno-30-6" href="#__codelineno-30-6"></a><span class="w">        </span><span class="k">else</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">B</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">];</span><span class="w"></span>
<a id="__codelineno-30-7" name="__codelineno-30-7" href="#__codelineno-30-7"></a><span class="w">    </span><span class="p">}</span><span class="w"></span>
<a id="__codelineno-30-8" name="__codelineno-30-8" href="#__codelineno-30-8"></a><span class="w">    </span><span class="k">while</span><span class="p">(</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">mid</span><span class="p">)</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="n">k</span><span class="o">++</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">];</span><span class="w">    </span><span class="c1">//若一个表未检测完，赋值</span>
<a id="__codelineno-30-9" name="__codelineno-30-9" href="#__codelineno-30-9"></a><span class="w">    </span><span class="k">while</span><span class="p">(</span><span class="n">j</span><span class="o">&lt;=</span><span class="n">high</span><span class="p">)</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="n">k</span><span class="o">++</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">B</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">];</span><span class="w">    </span><span class="c1">//若第二个表未检测完，赋值</span>
<a id="__codelineno-30-10" name="__codelineno-30-10" href="#__codelineno-30-10"></a><span class="p">}</span><span class="w"></span>
<a id="__codelineno-30-11" name="__codelineno-30-11" href="#__codelineno-30-11"></a><span class="kt">void</span><span class="w"> </span><span class="nf">MergeSort</span><span class="p">(</span><span class="n">ElemType</span><span class="w"> </span><span class="n">A</span><span class="p">[],</span><span class="kt">int</span><span class="w"> </span><span class="n">low</span><span class="p">,</span><span class="kt">int</span><span class="w"> </span><span class="n">high</span><span class="p">){</span><span class="w"></span>
<a id="__codelineno-30-12" name="__codelineno-30-12" href="#__codelineno-30-12"></a><span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">low</span><span class="o">&lt;</span><span class="n">high</span><span class="p">){</span><span class="w"></span>
<a id="__codelineno-30-13" name="__codelineno-30-13" href="#__codelineno-30-13"></a><span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">mid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">low</span><span class="o">+</span><span class="n">high</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span><span class="w"></span>
<a id="__codelineno-30-14" name="__codelineno-30-14" href="#__codelineno-30-14"></a><span class="w">        </span><span class="n">MergeSort</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">low</span><span class="p">,</span><span class="n">mid</span><span class="p">);</span><span class="w"></span>
<a id="__codelineno-30-15" name="__codelineno-30-15" href="#__codelineno-30-15"></a><span class="w">        </span><span class="n">MergeSort</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">high</span><span class="p">);</span><span class="w"></span>
<a id="__codelineno-30-16" name="__codelineno-30-16" href="#__codelineno-30-16"></a><span class="w">        </span><span class="n">Merge</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">low</span><span class="p">,</span><span class="n">mid</span><span class="p">,</span><span class="n">high</span><span class="p">);</span><span class="w">    </span><span class="c1">//归并</span>
<a id="__codelineno-30-17" name="__codelineno-30-17" href="#__codelineno-30-17"></a><span class="w">    </span><span class="p">}</span><span class="w"></span>
<a id="__codelineno-30-18" name="__codelineno-30-18" href="#__codelineno-30-18"></a><span class="p">}</span><span class="w"></span>
</code></pre></div>
<h2 id="50">50. 基数排序<a class="headerlink" href="#50" title="Permanent link">&para;</a></h2>
<ul>
<li>最高位优先法<code>MSD</code>: 将关键字位权重递减一次逐层划分成若干更小的子序列，最后将所有子序列依次连接成一个有序序列</li>
<li>最低位优先法<code>LSD</code>：将关键字权重递增一次进行排序，最后形成一个有序序列</li>
</ul>
<p>排序过程：</p>
<ul>
<li>
<p>在排序中，使用 r 个队列 <span class="arithmatex">\(Q_0,Q_1,...,Q_{r-1}\)</span>​</p>
</li>
<li>
<p>对 <span class="arithmatex">\(i=0,1,...,d-1\)</span>，依次做一次<strong>分配</strong>和<strong>收集</strong>，每个关键字结点 <span class="arithmatex">\(a_j\)</span>​由 d 元组组成</p>
</li>
<li>
<p>分配：开始时，把 <span class="arithmatex">\(Q_0,Q_1,...,Q_{r-1}\)</span>​各个队列置成空队列，然后依次考察线性表中的每个结点 <span class="arithmatex">\(a_j\)</span>​, 若 <span class="arithmatex">\(a_j\)</span> ​的关键字 <span class="arithmatex">\(k_j^i=k\)</span>，就把 <span class="arithmatex">\(a_j\)</span> ​放进 <span class="arithmatex">\(Q_k\)</span> ​队列中</p>
</li>
<li>
<p>收集：把 <span class="arithmatex">\(Q_0,Q_1,...,Q_{r-1}\)</span>​各个队列中的结点依次首尾相连，得到新的结点序列，从而组成新的线性表</p>
</li>
</ul>
<p><img alt="" src="../../images/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F%E6%A1%88%E4%BE%8B.jpg" /></p>
<h2 id="51">51. 各种内部排序算法比较及应用<a class="headerlink" href="#51" title="Permanent link">&para;</a></h2>
<h3 id="_47">内部排序算法的比较<a class="headerlink" href="#_47" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>算法种类</th>
<th>时间复杂度-最好</th>
<th>时间复杂度-平均</th>
<th>时间复杂度-最坏</th>
<th>空间复杂度</th>
<th>是否稳定</th>
</tr>
</thead>
<tbody>
<tr>
<td>直接插入排序</td>
<td><span class="arithmatex">\(O(n)\)</span></td>
<td><span class="arithmatex">\(O(n^2)\)</span></td>
<td><span class="arithmatex">\(O(n^2)\)</span></td>
<td><span class="arithmatex">\(O(1)\)</span></td>
<td>是</td>
</tr>
<tr>
<td>冒泡排序</td>
<td><span class="arithmatex">\(O(n)\)</span></td>
<td><span class="arithmatex">\(O(n^2)\)</span></td>
<td><span class="arithmatex">\(O(n^2)\)</span></td>
<td><span class="arithmatex">\(O(1)\)</span></td>
<td>是</td>
</tr>
<tr>
<td>简单选择排序</td>
<td><span class="arithmatex">\(O(n^2)\)</span></td>
<td><span class="arithmatex">\(O(n^2)\)</span></td>
<td><span class="arithmatex">\(O(n^2)\)</span></td>
<td><span class="arithmatex">\(O(1)\)</span></td>
<td>否</td>
</tr>
<tr>
<td>希尔排序</td>
<td></td>
<td></td>
<td></td>
<td><span class="arithmatex">\(O(1)\)</span></td>
<td>否</td>
</tr>
<tr>
<td>快速排序</td>
<td><span class="arithmatex">\(O(n\log_2n)\)</span></td>
<td><span class="arithmatex">\(O(n\log_2n)\)</span></td>
<td><span class="arithmatex">\(O(n^2)\)</span></td>
<td><span class="arithmatex">\(O(\log_2n)\)</span></td>
<td>否</td>
</tr>
<tr>
<td>堆排序</td>
<td><span class="arithmatex">\(O(n\log_2n)\)</span></td>
<td><span class="arithmatex">\(O(n\log_2n)\)</span></td>
<td><span class="arithmatex">\(O(n\log_2n)\)</span></td>
<td><span class="arithmatex">\(O(1)\)</span></td>
<td>否</td>
</tr>
<tr>
<td>2路归并排序</td>
<td><span class="arithmatex">\(O(n\log_2n)\)</span></td>
<td><span class="arithmatex">\(O(n\log_2n)\)</span></td>
<td><span class="arithmatex">\(O(n\log_2n)\)</span></td>
<td><span class="arithmatex">\(O(n)\)</span></td>
<td>是</td>
</tr>
<tr>
<td>基数排序</td>
<td><span class="arithmatex">\(O(d(n+r))\)</span></td>
<td><span class="arithmatex">\(O(d(n+r))\)</span></td>
<td><span class="arithmatex">\(O(d(n+r))\)</span></td>
<td><span class="arithmatex">\(O(r)\)</span></td>
<td>是</td>
</tr>
</tbody>
</table>
<h3 id="_48">选取排序方法需要考虑的因素<a class="headerlink" href="#_48" title="Permanent link">&para;</a></h3>
<ul>
<li>待排序的元素数目 n：较小考虑直接插入和简单选择排序，较大考虑快排】堆排序、归并排序</li>
<li>元素本身信息量的大小：是否选取移动量较少的排序方法</li>
<li>关键字的结构及其分布情况：如已经有序，则选取直接插入或冒泡排序</li>
<li>稳定性的要求</li>
<li>语言工具的要求，存储结构及辅助空间的大小等</li>
</ul>
<h2 id="52">52. 外部排序的方法<a class="headerlink" href="#52" title="Permanent link">&para;</a></h2>
<ul>
<li>根据内存缓冲区的大小，将外存上的文件分成若干长度为 <span class="arithmatex">\(l\)</span> 的子文件，依次读入内存并利用内部排序方法对它们进行排序，并将排序后得到的有序子文件重新写回外存，称这些有序子文件称为归并段或顺串</li>
<li>对这些归并段进行逐趟归并，使归并段逐渐由小到大，直至得到整个有序文件为止</li>
<li><code>外部排序的总时间=内部排序所需时间+外存信息读写的时间+内部归并所需的时间</code></li>
<li>在进行归并的时候，需要使用输入缓冲区和输出缓冲区，在内存和外存中传输数据</li>
<li>对<code>r</code>个初始段归并，做<code>k</code>路平衡归并，归并树可用严格 k 叉树来表示，树的高度 = <span class="arithmatex">\(\lceil \log_kr\rceil\)</span> = 归并趟数 S</li>
</ul>
<h3 id="_49">多路平衡归并与败者树<a class="headerlink" href="#_49" title="Permanent link">&para;</a></h3>
<ul>
<li>
<p>做内部归并时，在 k 个元素中选择关键字最小的记录需要比较 k-1 次，S 趟归并总需的比较次数是 <span class="arithmatex">\(S(n-1)(k-1)=\lceil \log_kr\rceil(n-1)(k-1)=\lceil \log_2r \rceil (n-1)(k-1)\lceil \log_2k \rceil\)</span></p>
</li>
<li>
<p>引入败者树后，在 k 个元素中选择关键字最小的记录需要比较 <span class="arithmatex">\(\lceil \log_2k \rceil\)</span> 次，内部归并的比较次数与 k 无关。因此只要内存允许，增大归并路数 k 将有效减少归并树的高度，提高外部排序的速度</p>
</li>
<li>
<p>败者树</p>
<ul>
<li>k 个叶结点分别存放 k 个归并段在归并过程中当前参加比较的记录</li>
<li>内存结点用来记忆左右子树中的失败者，而让胜者往上继续比较，一直到根结点</li>
<li>根结点记录胜者</li>
<li>叶结点进行编号 <span class="arithmatex">\(b0 \sim bk\)</span>, 内存结点编号 <span class="arithmatex">\(ls[0] \sim ls[k]\)</span>, <span class="arithmatex">\(ls[0]\)</span> 为根结点
<img alt="" src="../../images/5%E8%B7%AF%E5%BD%92%E5%B9%B6%E8%B4%A5%E8%80%85%E6%A0%91.jpg" /></li>
</ul>
</li>
</ul>
<h3 id="-">置换 - 选择排序（生成初始归并段）<a class="headerlink" href="#-" title="Permanent link">&para;</a></h3>
<p>初始待排文件<code>FI</code>, 初始归并段输出文件为<code>FO</code>, 内存工作区为<code>WA</code>,<code>FO</code>与<code>WA</code>的初始状态为空，<code>WA</code>可容纳 w w w 个记录</p>
<ol>
<li>从<code>FI</code>输入 w 个记录到工作区<code>WA</code></li>
<li>从<code>WA</code>中选出其中关键字取最小值的记录，记为<code>MINIMAX</code></li>
<li>将<code>MINIMAX</code>就输出到<code>FO</code>中去</li>
<li>若<code>FI</code>不为空，则从 FI 输入下一个记录到<code>WA</code>中</li>
<li>从<code>WA</code>中所有关键字比<code>MINIMAX</code>记录的关键字大的记录中选出最小关键字记录，作为新的<code>MINIMAX</code></li>
<li>重复<code>3-5</code>，直至在<code>WA</code>中选不出新的<code>MINIMAX</code>记录为止，由此得到一个初始归并段，输出一个归并段的结束标志至<code>FO</code>中去</li>
<li>重复<code>2-6</code>，直至<code>WA</code>为空，由此得到全部初始归并段</li>
</ol>
<p><img alt="" src="../../images/%E7%BD%AE%E6%8D%A2%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E6%A1%88%E4%BE%8B.jpg" /></p>
<h3 id="_50">最佳归并树<a class="headerlink" href="#_50" title="Permanent link">&para;</a></h3>
<p>把归并段的长度作为权值，进行严格 k 叉树的哈夫曼树思想，构造最佳归并树</p>
<ul>
<li><span class="arithmatex">\((n_0-1)\%(k-1)=0\)</span>, 不需要添加</li>
<li><span class="arithmatex">\((n_0-1)\%(k-1)=u\neq0\)</span>, 需要添加 <span class="arithmatex">\(k-1-u\)</span> 个长度为 0 的虚段</li>
</ul>
<p><img alt="" src="../../images/%E6%9C%80%E4%BD%B3%E5%BD%92%E5%B9%B6%E6%A0%91%E6%A1%88%E4%BE%8B.jpg" /></p>

              
            </article>
            
          </div>
        </div>
        
          <a href="#" class="md-top md-icon" data-md-component="top" hidden>
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12Z"/></svg>
            回到页面顶部
          </a>
        
      </main>
      
        <footer class="md-footer">
  
    
    <nav class="md-footer__inner md-grid" aria-label="页脚" >
      
        
        <a href="../summary/" class="md-footer__link md-footer__link--prev" aria-label="上一页: 核心知识点" rel="prev">
          <div class="md-footer__button md-icon">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
          </div>
          <div class="md-footer__title">
            <div class="md-ellipsis">
              <span class="md-footer__direction">
                上一页
              </span>
              核心知识点
            </div>
          </div>
        </a>
      
      
    </nav>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    <script id="__config" type="application/json">{"base": "../..", "features": ["navigation.tabs", "navigation.indexes", "navigation.top", "header.shadow", "content.code.annotate"], "search": "../../assets/javascripts/workers/search.b97dbffb.min.js", "translations": {"clipboard.copied": "\u5df2\u590d\u5236", "clipboard.copy": "\u590d\u5236", "search.config.lang": "ja", "search.config.pipeline": "trimmer, stemmer", "search.config.separator": "[\\s\\-\uff0c\u3002]+", "search.placeholder": "\u641c\u7d22", "search.result.more.one": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.other": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 # \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.term.missing": "\u7f3a\u5c11", "select.version.title": "\u9009\u62e9\u5f53\u524d\u7248\u672c"}}</script>
    
    
      <script src="../../assets/javascripts/bundle.6c7ad80a.min.js"></script>
      
        <script src="../../javascripts/mathjax.js"></script>
      
        <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
      
        <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
      
    
  </body>
</html>